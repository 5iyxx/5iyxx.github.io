<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Nginx]]></title>
    <url>%2F2017%2F06%2F22%2FRed%20Hat%207%20%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[Red Hat 7 安装后环境配置 配置静态的ip地址 查看系统的使用的网卡ifconfig 我本地网卡为eno16777736 打开配置文件vi /etc/sysconfig/network-scripts/ifcfg-eno16777736 静态ip设置，需要根据自己的网络参数修改配置文件BOOTPROTO=static 指定地址的获取方式IPADDR=192.168.0.225 ip地址NETMASK=255.255.255.0 子网掩码GATEWAY=192.168.0.1 网关 重启服务systemctl restart network ping测试ping 8.8.8.8PING 8.8.8.8 (8.8.8.8) 56(84) bytes of data.64 bytes from 8.8.8.8: icmp_seq=1 ttl=45 time=241 ms测试如上结果，成功！]]></content>
      <categories>
        <category>operations</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring中每个jar包的作用]]></title>
    <url>%2F2017%2F03%2F10%2Fspring%E4%B8%AD%E6%AF%8F%E4%B8%AAjar%E5%8C%85%E7%9A%84%E4%BD%9C%E7%94%A8%2F</url>
    <content type="text"><![CDATA[一个工程需要很多个关于spring的jar包，下面详细说明每个jar的作用。 spring.jar包含有完整发布模块的单个jar 包。但是不包括mock.jar, aspects.jar, spring-portlet.jar, and spring-hibernate2.jar。 spring-src.zip就是所有的源代码压缩包。 除了spring.jar 文件，Spring 还包括有其它21 个独立的jar 包，各自包含着对应的Spring组件，用户可以根据自己的需要来选择组合自己的jar 包，而不必引入整个spring.jar 的所有类文件。 spring-core.jar这个jar 文件包含Spring 框架基本的核心工具类。Spring 其它组件要都要使用到这个包里的类，是其它组件的基本核心，当然你也可以在自己的应用系统中使用这些工具类。外部依赖Commons Logging， (Log4J)。 spring-beans.jar这个jar 文件是所有应用都要用到的，它包含访问配置文件、创建和管理bean 以及进行Inversion of Control / Dependency Injection（IoC/DI）操作相关的所有类。如果应用只需基本的IoC/DI 支持，引入spring-core.jar 及spring-beans.jar 文件就可以了。外部依赖spring-core，(CGLIB)。 spring-aop.jar这个jar 文件包含在应用中使用Spring 的AOP 特性时所需的类和源码级元数据支持。使用基于AOP 的Spring特性，如声明型事务管理（Declarative Transaction Management），也要在应用里包含这个jar包。外部依赖spring-core， (spring-beans，AOP Alliance， CGLIB，Commons Attributes)。 spring-context.jar这个jar 文件为Spring 核心提供了大量扩展。可以找到使用Spring ApplicationContext特性时所需的全部类，JDNI 所需的全部类，instrumentation组件以及校验Validation 方面的相关类。外部依赖spring-beans, (spring-aop)。 spring-dao.jar这个jar 文件包含Spring DAO、Spring Transaction 进行数据访问的所有类。为了使用声明型事务支持，还需在自己的应用里包含spring-aop.jar。外部依赖spring-core，(spring-aop， spring-context， JTA API)。 spring-jdbc.jar这个jar 文件包含对Spring 对JDBC 数据访问进行封装的所有类。外部依赖spring-beans，spring-dao。 spring-support.jar这个jar 文件包含支持UI模版（Velocity，FreeMarker，JasperReports），邮件服务，脚本服务(JRuby)，缓存Cache（EHCache），任务计划Scheduling（uartz）方面的类。外部依赖spring-context, (spring-jdbc, Velocity, FreeMarker, JasperReports, BSH, Groovy, JRuby, Quartz, EHCache) spring-web.jar这个jar 文件包含Web 应用开发时，用到Spring 框架时所需的核心类，包括自动载入Web Application Context 特性的类、Struts 与JSF 集成类、文件上传的支持类、Filter 类和大量工具辅助类。外部依赖spring-context, Servlet API, (JSP API, JSTL, Commons FileUpload, COS)。 spring-webmvc.jar这个jar 文件包含Spring MVC 框架相关的所有类。包括框架的Servlets，Web MVC框架，控制器和视图支持。当然，如果你的应用使用了独立的MVC 框架，则无需这个JAR 文件里的任何类。外部依赖spring-web, (spring-support，Tiles，iText，POI)。 spring-portlet.jarspring自己实现的一个类似Spring MVC的框架。包括一个MVC框架和控制器。外部依赖spring-web， Portlet API，(spring-webmvc)。 spring-struts.jarStruts框架支持，可以更方便更容易的集成Struts框架。外部依赖spring-web，Struts。 spring-remoting.jar这个jar 文件包含支持EJB、远程调用Remoting（RMI、Hessian、Burlap、Http Invoker、JAX-RPC）方面的类。外部依赖spring-aop， (spring-context，spring-web，Hessian，Burlap，JAX-RPC，EJB API)。 spring-jmx.jar这个jar包提供了对JMX 1.0/1.2的支持类。外部依赖spring-beans，spring-aop， JMX API。 spring-jms.jar这个jar包提供了对JMS 1.0.2/1.1的支持类。外部依赖spring-beans，spring-dao，JMS API。 spring-jca.jar对JCA 1.0的支持。外部依赖spring-beans，spring-dao， JCA API。 spring-jdo.jar对JDO 1.0/2.0的支持。外部依赖spring-jdbc， JDO API， (spring-web)。 spring-jpa.jar对JPA 1.0的支持。外部依赖spring-jdbc， JPA API， (spring-web)。 spring-hibernate2.jar对Hibernate 2.1的支持，已经不建议使用。外部依赖spring-jdbc，Hibernate2，(spring-web)。 spring-hibernate3.jar对Hibernate 3.0/3.1/3.2的支持。外部依赖spring-jdbc，Hibernate3，(spring-web)。 spring-toplink.jar对TopLink框架的支持。外部依赖spring-jdbc，TopLink。 spring-ibatis.jar对iBATIS SQL Maps的支持。外部依赖spring-jdbc，iBATIS SQL Maps。 另外的两个包。 spring-mock.jar这个jar 文件包含Spring 一整套mock 类来辅助应用的测试。Spring 测试套件使用了其中大量mock 类，这样测试就更加简单。模拟HttpServletRequest 和HttpServletResponse 类在Web 应用单元测试是很方便的。并且提供了对JUnit的支持。外部依赖spring-core。 spring-aspects.jar提供对AspectJ的支持，以便可以方便的将面向方面的功能集成进IDE中，比如Eclipse AJDT。外部依赖。 WEAVER JARS (dist/weavers)说明。 spring-agent.jarSpring的InstrumentationSavingAgent (为InstrumentationLoadTimeWeaver)，一个设备代理包，可以参考JDK1.5的Instrumentation功能获得更多信息。外部依赖none (for use at JVM startup: “-javaagent:spring-agent.jar”)。 spring-tomcat-weaver.jar扩展Tomcat的ClassLoader，使其可以使用instrumentation（设备）类。外部依赖none (for deployment into Tomcat’s “server/lib” directory)。]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>blog</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Jar包添加到maven本地仓库]]></title>
    <url>%2F2017%2F03%2F07%2FJar%E5%8C%85%E6%B7%BB%E5%8A%A0%E5%88%B0maven%E6%9C%AC%E5%9C%B0%E4%BB%93%E5%BA%93%2F</url>
    <content type="text"><![CDATA[maven在应用的过程中，有 maven在应用的过程中，有些jar包在仓库上面是没法找到的，这需要我们自己手动导入到仓库中，些jar包在仓库上面是没法找到的，这需要我们自己手动导入到仓库中。 例子zxing-3.21.jar是根据github上面项目ZXing Project自己生成的jar包，该包主要应用于二维码生成，下面讲述怎么把怎么把zxing-3.21.jar添加到本地的maven仓库中。 环境要求需要配置JDK和maven环境，完成后以管理员身份打开命令提示符窗口(cmd),再输入下面相关的语法。 语法1234567891011121314151617181920212223mvn install:install-file -Dfile=jar包的位置(参数一) -DgroupId=groupId(参数二) -DartifactId=artifactId(参数三) -Dversion=version(参数四) -Dpackaging=jareg:mvn install:install-file -Dfile=&quot;C:\Users\eric\Desktop\zxing\3.21\zxing-3.21.jar&quot; -DgroupId=com.eric -DartifactId=zxing -Dversion=3.21 -Dpackaging=jarresult：[INFO] Scanning for projects...[INFO][INFO] ------------------------------------------------------------------------[INFO] Building Maven Stub Project (No POM) 1[INFO] ------------------------------------------------------------------------[INFO][INFO] --- maven-install-plugin:2.4:install-file (default-cli) @ standalone-pom ---[INFO] Installing C:\Users\eric\Desktop\zxing\3.21\zxing-3.21.jar to C:\Users\eric\.m2\repository\com\eric\zxing\3.21\zxing-3.21.jar[INFO] Installing C:\Users\eric\AppData\Local\Temp\mvninstall6543969167446403883.pom to C:\Users\eric\.m2\repository\com\eric\zxing\3.21\zxing-3.21.pom[INFO] ------------------------------------------------------------------------[INFO] BUILD SUCCESS[INFO] ------------------------------------------------------------------------[INFO] Total time: 0.836 s[INFO] Finished at: 2017-03-08T00:24:12+08:00[INFO] Final Memory: 7M/117M[INFO] ------------------------------------------------------------------------(添加成功！) 注意：地址+jar包名,即C:\Users\eric\Desktop\zxing\3.21\zxing-3.21.jar要加引号””,”参数二\参数三\参数四”这也是jar包在仓库中的地址。 查看生成的依赖查看添加的zxing-3.21.jar的dependency 通过设置的对应参数获取.即 1-DgroupId=groupId(参数二) -DartifactId=artifactId(参数三) -Dversion=version(参数四) 参看本地仓库中pom文件C:\Users\eric.m2\repository\com\eric\zxing\3.21\zxing-3.21.pom，可以看到: 123&lt;groupId&gt;com.eric&lt;/groupId&gt;&lt;artifactId&gt;zxing&lt;/artifactId&gt;&lt;version&gt;3.21&lt;/version&gt;]]></content>
      <categories>
        <category>maven</category>
      </categories>
      <tags>
        <tag>blog</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java核心技术]]></title>
    <url>%2F2017%2F03%2F06%2FJava%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%2F</url>
    <content type="text"><![CDATA[CayS.Horstmann等编著的《Java核心技术》(CoreJava)自第1版出版以来，一直备受广大Java程序设计人员的青睐，畅销不衰，是Java经典书籍。第8版针对JavaSE6平台进行了全面更新，囊括了Java平台标准版(JavaSE/J2SE)的全部基础知识，提供了大量完整且具有实际意义的应用实例，详细介绍了Java语言基础知识、面向对象程序设计、接口与内部类、事件监听器模型、swing图形用户界面程序设计、打包应用程序、异常处理、登录与调试、泛型程序设计、集合框架、多线程等内容。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Book</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[精通Hibernate]]></title>
    <url>%2F2017%2F03%2F01%2F%E7%B2%BE%E9%80%9Ahibernate%2F</url>
    <content type="text"><![CDATA[今天去公司上班了，公司后台框架是hibernate+springMvc,虽然之前看过hibernate，但是没有在实际的开发过程中用到，很多都忘记了，就准备看孙卫琴的《精通Hibernate》。 Java对象持久化技术概论从不同的角度解释hibernate： 它是连接Java应用程序和关系数据库的中间件。 它对JDBC API进行了封装，负责Java的持久化。 在分层软件架构中它位于持久化层，封装了所有数据访问细节，使业务逻辑层可以专注与实现业务逻辑。 它是一只ORM映射工具，能够建立面向对象的域模型和关系数据模型之间的映射。 本章介绍软件的三种模型：概念模型、域模型和数据模型，然后介绍了Java对象的持久化概念，并介绍了实现对象持久化的几种模式： 业务逻辑和数据访问耦合 主动域对象模式 ORM模式 JDO模式 CMP模式 应用程序的分层体系结构四层结构应用软件的结构。 表述层：提供与用户交互的界面。GUI(图形用户界面)和web页面而是表述层的两个典型的例子。 业务逻辑层：实现各种业务逻辑。例如当用户发出生产订单的请求时，业务逻辑层负责计算的价格、验证订单的信息。 持久层：封装数据访问细节，为业务逻辑提供了面向对象的API 数据库层：负责存放和管理应用的持久性业务数据。例如对于电子商务网站应用，在数据库中保存了客户、订单和商品等业务数据。关系数据库依然是目前最流行的数据库。 软件分层的优点恰当地为软件分层，将会提高软件的以下性能。 伸缩性：伸缩性指应用程序是否能支持更多的用户。 可维护性：当发生需求变化，只需修改软件的某一部分，不会影响其他部分的代码。层次越多，可维护性也会不断提高，因为修改软件的某一部分的实现，不会影响其它层。 可扩展性：是在现有的系统中增加新功能的难易程度。层数越少，添加新功能就越容易破坏现有的程序结构。层数越多，就可以在每个层次中提供扩展点，不会打破应用的整体框架。 可重复性：程序代码有冗余，同一个程序就能满足多种需求。 可管理性：管理系统的难易程度。将应用程序分为多层后，可以将工作分解给不同的开发小组，从而便于管理。应用越复杂，规模越大，需要的层就越多。 软件分层的缺点 软件分层越多，对软件设计人员的要求就越高。 在设计阶段，必须花时间构思合理的体系结构。 开发流程相对复杂，降低开发效率。 Java应用的持久化层Hibernate API简介hibernate中的接口可分为以下几类： 提供访问数据库的操作（如保存、更新、删除和查询对象）的接口。这些接口包括：Session、Transaction和Quer接口。 用于配置Hibernate的接口：Configuration。 回调接口，使应用程序接受Hibernate内部发生的事件，并做出相应的回应。这些接口包括：Interceptor、Lifecycle和Validatable接口。 用于扩展Hibernate的功能的接口，如UserType、CompositeUserType和IdentifierGenerator接口，如果需要的话，应用程序可以扩展这些接口。 Hibernate入门Hibernate是Java应用和关系型数据库之间的桥梁，内部封装了通过JDBC访问数据库的操作，向上层应用提供了面向对象的数据访问API。在Java应用中使用hibernate包含以下步骤。 创建Hibernate的配置文件。 创建持久化类。 创建对象-关系映射文件。 通过HibernateAPI编写访问数据库的代码。 创建Hibernate的配置文件hibernate的配置文件中读取了数据库连接的有关信息，有两种形式：一种是XML格式文件；还有一种是Java属性文件，采用“健=值”的形式。配置文件的属性：hibernate.properties 123456hibernate.dialect=net.sf.hibernate.dialect.MySQLDialct //指定数据库使用SQL方言hibernate.connection.driver_class=com.mysql.jdbc.Driver //指定数据库的驱动程序hibernate.connection.url=jdbc:mysql://localhost:3306/SAMPLEDB //指定数据库的URLhibernate.connection.username=root //指定数据库的连接名hibernate.connection.password=root //指定数据库的口令hibernate.show_sql=ture //是否在控制台输出SQL语句 创建持久化类持久化类是指其实例需要被Hibernate持久化到数据库中的类。持久化类通常都是域模型中的实体域类。持久化类符合JavaBean的规范，包含一些属性，以及与之对应的getXXX()和setXXX()方法。下列中定义了一个名为Customer的持久化类。 123456789package mypack;import java.io.Serializable;import java.sql.Date;import java.sql.Timestamp;public class Customer implements Serializable &#123;-&#125; 持久化类符合JavaBean的规范，包含一些属性，以及与之对应的getXXX()和setXXX()方法。getXXX()和setXXX()方法必须符合特定的命名规范，”get”和”set”后面紧跟属性的名字，并且属性名的首字母为大写，例如name属性的getName(),如果把get方法写为getname()或者getNANE(),会导致Hibernate在运行时抛出以下的异常： 1net.sf.hibernate.PropertNotFountException:Could not find a getter for property name in class mypack.Customer 如果为boolean类型可以用isXXX()或者getXXX().Hibernate并不要求持久化类必须实现java.io.Serializable接口，但是对于采用分布式结构的Java应用，当Java对象在不同的进程点之间传输时，这个对象所属的类必须实现Serializable接口，此外，在Java web应用中，如果希望对HttpSession中存放的Java对象进行持久化，那么这个Java对象所属的类也必须实现Serializable接口。Customer持久化类有一个id属性，用来唯一标识Customer类的每个属性。在面向对象术语中，这个id属性称为对象标识符(OID,Object Identifier)。通常为整数也可以为其他类型。Hibernate要求持久化类必须提供一个不带参数的默认构造方法，在程序运行时，Hibernate运用Java反射机制，调用java.lang.reflenct.Constructor.newInstance()方法来构造持久化的实例。如果对这个持久化类使用延迟检索策略，为了使Hibernate能够在运行时为这个持久化类创建动态代理，要求持久化类的默认构造方法的访问级别必须是public或protected类型，而不是default 或private类型。在Customer类中没有引入任何Hibernate API，Customer类不需要继承Hibernate的类或者实现Hibernate的接口，这提高了持久化类的独立性。 创建数据库Schema下面为Customer类对应的数据库表名为CUSTOMERS，它在MySQL数据库中的DDL定义如下： 1234567891011121314create table CUSTOMERS( ID bigint not null primary key, NAME varchar(15) not null, EMAIL varchar(128) not null, PASSWORD varchar(8) not null, PHONE int, ADDRESS varchar(255), SEX char(1), IS_MARRIED bit, DESCRIPTION text, IMAGE blob, BIRTHDAY date, REGISTERED_TIME timestamp); 创建对象-关系映射文件Hibernate采用XML格式的文件来指定对象和关系数据之间的映射。在运行时，Hibernate将根据这个映射文件来生成各种SQL语句。下面的Customer.hbm.xml把Customer类映射到CUSTOMERS表： 12345678910111213141516171819&lt;?xml version=&quot;1.0&quot;?&gt;&lt;!DOCTYPE hibernate-mapping PUBLIC &quot;-//Hibernate/Hibernate Mapping DTD 2.0//EN&quot;&quot;http://hibernate.sourceforge.net/hibernate-mapping-2.0.dtd&quot;&gt; &lt;hibernate-mapping&gt;&lt;class name=&quot;mypack.Customer&quot; table=&quot;CUSTOMERS&quot;&gt;&lt;id name=&quot;id&quot; column=&quot;ID&quot; type=&quot;long&quot;&gt;&lt;generator class=&quot;increment&quot;/&gt;&lt;/id&gt;&lt;property name=&quot;name&quot; column=&quot;NAME&quot; type=&quot;string&quot; not-null=&quot;true&quot;/&gt;&lt;property name=&quot;email&quot; column=&quot;EMAIL&quot; type=&quot;string&quot; not-null=&quot;true&quot;/&gt;&lt;property name=&quot;password&quot; column=&quot;PASSWORD&quot; type=&quot;string&quot; not-null=&quot;true&quot;/&gt;&lt;property name=&quot;phone&quot; column=&quot;PHONE&quot; type=&quot;int&quot;/&gt;&lt;property name=&quot;address&quot; column=&quot;ADDRESS&quot; type=&quot;string&quot;/&gt;&lt;property name=&quot;sex&quot; column=&quot;SEX&quot; type=&quot;character&quot;/&gt;&lt;property name=&quot;married&quot; column=&quot;IS_MARRIED&quot; type=&quot;boolean&quot;/&gt;&lt;property name=&quot;description&quot; column=&quot;DESCRIPTION&quot; type=&quot;text&quot;/&gt;&lt;property name=&quot;image&quot; column=&quot;IMAGE&quot; type=&quot;binary&quot;/&gt;&lt;property name=&quot;birthday&quot; column=&quot;BIRTHDAY&quot; type=&quot;date&quot;/&gt;&lt;property name=&quot;registeredTime&quot; column=&quot;REGISTEREDTIME&quot; type=&quot;timestamp&quot;/&gt;&lt;/class&gt;&lt;/hibernate-mapping&gt; 映射文件的文档类型定义（DTD）Customer.hbm.xml文件的开头定义声明DTD（Document Type Definition,文档类型定义），它对XML文件的语法和格式做了定义。]]></content>
      <categories>
        <category>hibernate</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[MySQL数据库常见面试题目]]></title>
    <url>%2F2017%2F02%2F20%2FMySQL%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98%E7%9B%AE%2F</url>
    <content type="text"><![CDATA[在准备面试，就在网上收集了一些MySQL面试题目。 如何登陆mysql数据库MySQL -u username -p 如何开启/关闭mysql服务service mysql start/stop 查看mysql的状态service mysql status 如何显示数所有数据库show databases 如何获取表内所有字段对象的名称和类型describe table_name; MYSQL支持事务吗？在缺省模式下，MYSQL是autocommit模式的，所有的数据库更新操作都会即时提交，所以在缺省情况下，mysql是不支持事务的。但是如果你的MYSQL表类型是使用InnoDB Tables 或 BDB tables的话，你的MYSQL就可以使用事务处理,使用SET AUTOCOMMIT=0就可以使MYSQL允许在非autocommit模式，在非autocommit模式下，你必须使用COMMIT来提交你的更改，或者用ROLLBACK来回滚你的更改。示例如下：START TRANSACTION;SELECT @A:=SUM(salary) FROM table1 WHERE type=1;UPDATE table2 SET summmary=@A WHERE type=1;COMMIT; MYSQL相比于其他数据库有哪些特点？MySQL是一个小型关系型数据库管理系统，开发者为瑞典MySQL AB公司，现在已经被Sun公司收购，支持FreeBSD、Linux、MAC、Windows等多种操作系统与其他的大型数据库例如Oracle、DB2、SQL Server等相比功能稍弱一些1、可以处理拥有上千万条记录的大型数据2、支持常见的SQL语句规范3、可移植行高，安装简单小巧4、良好的运行效率，有丰富信息的网络支持5、调试、管理，优化简单（相对其他大型数据库） varchar和char的区别Char是一种固定长度的类型，varchar是一种可变长度的类型 数据库事物有哪几种？隔离性、持续性、一致性、原子性 请简洁地描述下MySQL中InnoDB支持的四种事务隔离级别名称，以及逐级之间的区别？SQL标准定义的四个隔离级别为：read uncommited：读取未提交内容read committed：读取提交内容repeatable read：可重读serializable：可串行化详细解释如下：Read Uncommitted（读取未提交内容）在该隔离级别，所有事务都可以看到其他未提交事务的执行结果。本隔离级别很少用于实际应用，因为它的性能也不比其他级别好多少。读取未提交的数据，也被称之为脏读（Dirty Read）。Read Committed（读取提交内容）这是大多数数据库系统的默认隔离级别（但不是MySQL默认的）。它满足了隔离的简单定义：一个事务只能看见已经提交事务所做的改变。这种隔离级别也支持所谓的不可重复读（Nonrepeatable Read），因为同一事务的其他实例在该实例处理其间可能会有新的commit，所以同一select可能返回不同结果。Repeatable Read（可重读）这是MySQL的默认事务隔离级别，它确保同一事务的多个实例在并发读取数据时，会看到同样的数据行。不过理论上，这会导致另一个棘手的问题：幻读（Phantom Read）。简单的说，幻读指当用户读取某一范围的数据行时，另一个事务又在该范围内插入了新行，当用户再读取该范围的数据行时，会发现有新的“幻影” 行。InnoDB和Falcon存储引擎通过多版本并发控制（MVCC，Multiversion Concurrency Control 间隙锁）机制解决了该问题。注：其实多版本只是解决不可重复读问题，而加上间隙锁（也就是它这里所谓的并发控制）才解决了幻读问题。Serializable（可串行化）这是最高的隔离级别，它通过强制事务排序，使之不可能相互冲突，从而解决幻读问题。简言之，它是在每个读的数据行上加上共享锁。在这个级别，可能导致大量的超时现象和锁竞争。对于不同的事务，采用不同的隔离级别分别有不同的结果。不同的隔离级别有不同的现象。主要有下面3种现在：1、脏读（dirty read）：一个事务可以读取另一个尚未提交事务的修改数据。2、非重复读（nonrepeatable read）：在同一个事务中，同一个查询在T1时间读取某一行，在T2时间重新读取这一行时候，这一行的数据已经发生修改，可能被更新了（update），也可能被删除了（delete）。3、幻像读（phantom read）：在同一事务中，同一查询多次进行时候，由于其他插入操作（insert）的事务提交，导致每次返回不同的结果集。不同的隔离级别有不同的现象，并有不同的锁定/并发机制，隔离级别越高，数据库的并发性就越差，4种事务隔离级别分别表现的现象如下表：这里写图片描述 mysql数据库引擎MyISAM和InnoDB的区别这里写图片描述 mysql有关权限的表都有哪几个MySQL服务器通过权限表来控制用户对数据库的访问，权限表存放在mysql数据库里，由mysql_install_db脚本初始化。这些权限表分别user，db，table_priv，columns_priv和host。下面分别介绍一下这些表的结构和内容：user权限表：记录允许连接到服务器的用户帐号信息，里面的权限是全局级的。db权限表：记录各个帐号在各个数据库上的操作权限。table_priv权限表：记录数据表级的操作权限。columns_priv权限表：记录数据列级的操作权限。host权限表：配合db权限表对给定主机上数据库级操作权限作更细致的控制。这个权限表不受GRANT和REVOKE语句的影响。 mysql存储引擎有哪些？如何修改mysql存储引擎？MyISAM indexed sequential access method (有索引的顺序访问方法)MyISAM 具有检查和修复表格的大多数工具。表格可以被压缩，而且支持全文收索不是事务安全的，而且不支持外键。MEMORY 也是以前的(HEAP) 该类型表存储在内存中，表的索引是哈希分布的。merge 这些表为了查询目的，把myisam 表集合作为单个表，因此你可以在某些操作系统中避开最大文件大小的限制。archive 这种类型的表只支持，insert ,select 不支持delete,update,replace ,不使用索引。csv 这些表保存在服务器的单个文件中，它包含了用逗号间隔的数据。 innodb 这种表是事务安全的。提供了commit（提交） rollback（实务回滚）支持外键，比myisam慢。修改mysql存储引擎alter table tablename type = innodb; MYSQL 数据表修复及数据恢复面试题MYSQL数据表在什么情况下容易损坏？服务器突然断电导致数据文件损坏。强制关机，没有先关闭mysql 服务等。数据表损坏后的主要现象是什么？从表中选择数据之时，得到如下错误：Incorrect key file for table: ‘…’. Try to repair it查询不能在表中找到行或返回不完全的数据。Error: Table ‘p’ is marked as crashed and should be repaired 。打开表失败： Can’t open file: ‘×××.MYI’ (errno: 145) 。数据表损坏的修复方式有哪些？使用 myisamchk 来修复，具体步骤：1）修复前将mysql服务停止。2）打开命令行方式，然后进入到mysql的/bin目录。3）执行myisamchk –recover 数据库所在路径/*.MYI使用repair table 或者 OPTIMIZE table命令来修复，REPAIR TABLE table_name 修复表 OPTIMIZE TABLE table_name 优化表 REPAIR TABLE 用于修复被破坏的表。OPTIMIZE TABLE 用于回收闲置的数据库空间，当表上的数据行被删除时，所占据的磁盘空间并没有立即被回收，使用了OPTIMIZE TABLE命令后这些空间将被回收，并且对磁盘上的数据行进行重排（注意：是磁盘上，而非数据库） MYSQL数据库服务器性能分析的方法命令有哪些?Show status一些值得监控的变量值：Bytes_received和Bytessent和服务器之间来往的流量。Com服务器正在执行的命令。Created_在查询执行期限间创建的临时表和文件。Handler*存储引擎操作。Select不同类型的联接执行计划。Sort_几种排序信息。Show session status like ‘Select’;Show profilesSET profiling=1;Show profiles\GShow profile; mysql里记录货币用什么字段类型好NUMERIC和DECIMAL类型被MySQL实现为同样的类型，这在SQL92标准允许。他们被用于保存值，该值的准确精度是极其重要的值，例如与金钱有关的数据。当声明一个类是这些类型之一时，精度和规模的能被(并且通常是)指定；例如：salary DECIMAL(9,2)在这个例子中，9(precision)代表将被用于存储值的总的小数位数，而2(scale)代表将被用于存储小数点后的位数。因此，在这种情况下，能被存储在salary列中的值的范围是从-9999999.99到9999999.99。在ANSI/ISO SQL92中，句法DECIMAL(p)等价于DECIMAL(p,0)。同样，句法DECIMAL等价于DECIMAL(p,0)，这里实现被允许决定值p。MySQL当前不支持DECIMAL/NUMERIC数据类型的这些变种形式的任一种。这一般说来不是一个严重的问题，因为这些类型的主要益处得自于明显地控制精度和规模的能力。DECIMAL和NUMERIC值作为字符串存储，而不是作为二进制浮点数，以便保存那些值的小数精度。一个字符用于值的每一位、小数点(如果scale&gt;0)和“-”符号(对于负值)。如果scale是0，DECIMAL和NUMERIC值不包含小数点或小数部分。DECIMAL和NUMERIC值得最大的范围与DOUBLE一样，但是对于一个给定的DECIMAL或NUMERIC列，实际的范围可由制由给定列的precision或scale限制。当这样的列赋给了小数点后面的位超过指定scale所允许的位的值，该值根据scale四舍五入。当一个DECIMAL或NUMERIC列被赋给了其大小超过指定(或缺省的）precision和scale隐含的范围的值，MySQL存储表示那个范围的相应的端点值。]]></content>
      <categories>
        <category>Database</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mybatis]]></title>
    <url>%2F2017%2F02%2F12%2FMybatis%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[初学mybatis。 SqlSessionSqlSession的作用： 向SQL语句传入参数 执行SQL语句 获取执行SQL语句的结果 事务的控制 如何得到SqlSession: 通过配置文件获取数据库连接相关信息 通过配置信息构建SqlSessionFactory 通过SqlSessionFactory打开数据库会话各层分工servlet 负责接收页面的值，向页面传值，如果有相应的业务逻辑需要处理，则调用相应service层。service 负责接收servlet传过来的值，并做执行处理，业务的操作、算法等等，如果有需要要调用相应的dao层。dao 完成与数据库的交互，执行相应的sql语句bean 对象]]></content>
      <categories>
        <category>Mybatis</category>
      </categories>
      <tags>
        <tag>Mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Nginx]]></title>
    <url>%2F2017%2F02%2F11%2FNginx%2F</url>
    <content type="text"><![CDATA[Nginx安装手册 nginx安装环境nginx是C语言开发，建议在linux上运行，本教程使用Centos6.5作为安装环境。 gcc安装nginx需要先将官网下载的源码进行编译，编译依赖gcc环境，如果没有gcc环境，需要安装gcc：yum install gcc-c++ PCREPCRE(Perl Compatible Regular Expressions)是一个Perl库，包括 perl 兼容的正则表达式库。nginx的http模块使用pcre来解析正则表达式，所以需要在linux上安装pcre库。yum install -y pcre pcre-devel注：pcre-devel是使用pcre开发的一个二次开发库。nginx也需要此库。 zlibzlib库提供了很多种压缩和解压缩的方式，nginx使用zlib对http包的内容进行gzip，所以需要在linux上安装zlib库。yum install -y zlib zlib-devel opensslOpenSSL 是一个强大的安全套接字层密码库，囊括主要的密码算法、常用的密钥和证书封装管理功能及SSL协议，并提供丰富的应用程序供测试或其它目的使用。 nginx不仅支持http协议，还支持https（即在ssl协议上传输http），所以需要在linux安装openssl库。yum install -y openssl openssl-devel 编译安装将nginx-1.8.0.tar.gz拷贝至linux服务器。解压： tar -zxvf nginx-1.8.0.tar.gz cd nginx-1.8.0 configure./configure –help查询详细参数 参数设置如下：./configure \1234567891011--prefix=/usr/local/nginx \--pid-path=/var/run/nginx/nginx.pid \--lock-path=/var/lock/nginx.lock \--error-log-path=/var/log/nginx/error.log \--http-log-path=/var/log/nginx/access.log \--with-http_gzip_static_module \--http-client-body-temp-path=/var/temp/nginx/client \--http-proxy-temp-path=/var/temp/nginx/proxy \--http-fastcgi-temp-path=/var/temp/nginx/fastcgi \--http-uwsgi-temp-path=/var/temp/nginx/uwsgi \--http-scgi-temp-path=/var/temp/nginx/scgi 注意：上边将临时文件目录指定为/var/temp/nginx，需要在/var下创建temp及nginx目录 编译安装makemake install安装成功查看安装目录 ：]]></content>
      <categories>
        <category>operations</category>
      </categories>
      <tags>
        <tag>Nginx</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL数据库应用从入门到精通]]></title>
    <url>%2F2017%2F01%2F12%2FMySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E5%BA%94%E7%94%A8%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A%2F</url>
    <content type="text"><![CDATA[最近在看《MySQL数据库应用从入门到精通》这本书是基于MySQL5.5版本的，下面是看书过程记录下来的笔记。 数据库概述 SQL主要功能：数据定义语言（DDL）,数据操作语言（DML）,数据控制语言（DCL). 数据可基本操作create Database database_name;创建数据库SHOW DATABASES;查看数据库USE database_name; 选择数据库DROP DATABASE database_name;删除数据库 在执行SQL语句中，可以用”;”、”\g”、”\G”符号表示语句结束。其中前两个符号的作用一样，而最后一个符号除了表示语句结束外，还可以使得结果显示的更加美观。 mysql中的存储引擎和数据类型存储引擎查询存储引擎 存储引擎是MySQL数据库管理系统的一个重要特征，在具体开发时，为了提高MySQL数据库管理系统的使用效率和灵活性，可以根据实际需要来选择存储引擎。因为存储引擎指定了表的类型，即如何存储和索引数据、是否支持事物等，同时存储引擎也决定了表在计算机中的存储方式。SHOW ENGINES;显示支持的存储引擎show variables like &#39;%storage_engine%&#39;;当前默认的存储引擎: 选择存储引擎 下图是3种常用的存储引擎介绍。 上面主要介绍了MyISAM、InnoDB和MEMORY三种存储引擎特性的对比，接下来将详细介绍这3个存储引擎的应用场合并给出相应的建议。 MyISAM:由于该存储引擎不支持事务、也不支持外键，所以访问速度比较快。因为此对事务完整性没有要求并以访问为主的应用适用于该存储引擎。 InnoDB:由于该存储引擎在事务上具有优势，即支持具有提交、回滚和崩溃恢复能力的事务安装，所以比MyISAM存储引擎占用更多的磁盘空间。因此需要进行频繁的更新、删除操作，同时还对事务的完整性要求比较高，需要实现必发控制，此时适用适用该存储引擎。 MEMORY:该存储引擎使用内存来存储数据，因此该存储引擎的数据访问速度比较快，但是安全上没有保障。如果应用中涉及数据比较小，需要进行快速访问，则适用使用该存储引擎。 关于图形化的存储引擎修改这里不做记录，下面讲解通过修改my.ini配置来配置存储引擎。 如果想要修改默认存储引擎，只需修改[mysqld]组中的default-storage-engine参数。如：default-storage-engine=MyISAM 注意：如果修改参数后，需重启MySQL服务才能生效 数据类型整形 整型具体特性如下图： 浮点数类型、定点数类型和位类型当需要精确到小数点后10位以上是，需要选择DOUBLE类型。当需要小数数据精确度非常高时，则可以选择DEC和DECIMAL类型，它们的精确度比DOUBLE类型还要高。FLOAT、DOUBLE数据类型存储数据是存储的是近似数，而DECIMAL存储的是字符串，因此提供了更高的精度。 浮点数类型具体特性如下图： 定点数类型具体特性如下图： FLOAT数据类型和DECIMAL数据类型的区别如下：结果为： 位类型具体类型如下：BIT类型的使用 日期和时间类型 日期和时间类型具体特性如下图： 字符串类型 CHAR系列字符串类型具体特性如下： TEXT系列字符串类型具体特性如下： BINARY系列字符串类型具体特性如下：BINARY可以存储二进制数据（例如图片、音乐或者视频文件），而后者只能存储字符数据。如果二进制数据长度经常变化则选择VARBINARY类型，否则选择BINARY。 BLOB系列字符类型具体特性如下：上面的四种类型与TEXT系列字符串类型非常类似，不同的是，前者可以存储二进制数据（例如图片、音乐或者视频文件），而后者只能存储字符数据。如果需要存储电影等视频文件时则根据实际选择合适长度的BLOB类型 表的操作表的基本概念表是包含数据库中所有数据的数据库对象，表中的数据库对象包含列、索引和触发器。 表的基本语法使用USE database_name;进入要操作的数据库。 创建表的语法形式 可以使用下面几种语法查看表定义DESCRIBE table_name;SHOW CREATE TABLE table_name;DESC table_name; 删除表DROP TABLE table_name; 修改表ALTER TABLE old_name RENAME [TO] new_table_name;修改表名ALTER TABLE table_name ADD 属性名 属性类型；在表的最后一个位置添加字段ALTER TABLE table_name ADD 属性名 属性类型 FIRST；在表的第一个位置添加字段ALTER TABLE table_name ADD 属性名 属性类型 AFTER 属性名；在表指定字段之后添加字段ALTER TABLE table_name DROP 属性名;删除表中指定的属性ALTER TABLE table_name MODIFY 属性名 数据类型;修改字段的数据类型ALTER TABLE table_name CHANGE 旧属性名 新属性名 旧属类型;修改字段名字ALTER TABLE table_name CHANGE 旧属性名 新属性名 新属类型;同时修改字段名字和属性ALTER TABLE table_name MODIFY 属性名1 数据类型 FIRST |AFTER 属性名2;修改字段的顺序 MySQL支持的完整性约束所谓完整性是指数据的准确性和一致性，而完整性检查就是指检查数据的准确性和一致性。MySQL数据库管理系统提供了一致机制来检查数据库表中的数据是否满足规定的条件，以保证数据库中数据的准确性和一致性，这种机制就是约束。完整性约束如下图：CREATE TABLE table_name( 属性名 数据类型 NOT NULL, ...... );非空约束（NOT NULL,NK）CREATE TABLE table_name( 属性名 数据类型 DEFAULT 默认值, ...... );默认值（DEFAULT）CREATE TABLE table_name( 属性名 数据类型 UNIQUE, ...... );唯一约束（UNIQUE,UK）CREATE TABLE table_name( 属性名 数据类型 PRIMARY KEY, ..... );单字段主键（PRIMARY KEY,PK）CREATE TABLE table_name( 属性名 数据类型,.....[CONSTRAINT 约束名]PRIMARY KEY(属性名,属性名......) );多字段主键（PRIMARY KEY,PK）CREATE TABLE table_name( 属性名 数据类型 AUTO_INCREMENT, ..... );自动增加（AUTO_INCREMENT）CREATE TABLE table_name( 属性名 数据类型, 属性名 数据类型, ..... CONSTRAINT 外键约束名 FOREIGN KEY (属性名) REFERENCES 表名 （属性名2） );外键约束（FOREIGN KEY,FK） 注意：如果想给字段上的约束设置一个约束名字，可以执行SQL语句CONSTRAINT.例如：CONSTRAINT 约束名字 约束 (属性名); 索引的操作数据库对象索引其实与书的目录非常类似，主要是为了提高从表中检索数据的速度。InnoDB和MyISAM存储引擎支持BTREE类型索引，MEMORY存储引擎支持HASH类型索引，默认为前者索引。MySQL支持6种索引，分别为普通索引、唯一索引、全文索引、单列索引、多列索引和空间索引。 创建和查看索引ASC参数用来指定为升序排序，DESC参数用来指定为降序排序 普通索引创表时创建普通索引如下： 1234567CREATE TABLE table_name( 属性名 数据类型, 属性名 数据类型, ...... 属性名 数据类型, INDEX|KEY [索引名] (属性名1 [(长度)] [ASC|DESC])); CREATE INDEX 索引名 ON表名(属性名 [(长度)] [ASC|DESC]);在已经存在的表上创建普通索引ALTER TABLE table_name ADD INDEX|KEY 索引名 （属性名 [(长度)] [ASC|DESC]);通过SQL语句ALTER TABLE 创建普通索引 唯一索引注意：explain用法EXPLAIN tbl_name或EXPLAIN [EXTENDED] SELECT select_options前者可以得出一个表的字段结构等等，后者主要是给出相关的一些索引信息，而今天要讲述的重点是后者。创建表时创建唯一索引如下： 1234567CREATE TABLE table_name( 属性名 数据类型, 属性名 数据类型, ...... 属性名 数据类型, UNIQUE INDEX|KEY [索引名] （属性名1 [(长度)] [ASC|DESC])); CREATE UNIQUE INDEX 索引名 ON表名(属性名 [(长度)] [ASC|DESC]);在已经存在的表上创建唯一索引ALTER TABLE table_name ADD UNIQUE INDEX|KEY 索引名 （属性名 [(长度)] [ASC|DESC]);通过SQL语句ALTER TABLE 创建唯一索引 全文索引创建表时创建全文索引如下： 1234567CREATE TABLE table_name( 属性名 数据类型, 属性名 数据类型, ...... 属性名 数据类型, FULLTEXT INDEX|KEY [索引名] （属性名1 [(长度)] [ASC|DESC]) ); CREATE FULLTEXT INDEX 索引名 ON表名(属性名 [(长度)] [ASC|DESC]);在已经存在的表上创建全文索引 ALTER TABLE table_name ADD FULLTEXT INDEX|KEY 索引名 （属性名 [(长度)] [ASC|DESC]);通过SQL语句ALTER TABLE 创建全文索引 多列索引创建表时创建全文索引如下： 123456789CREATE TABLE table_name( 属性名 数据类型, 属性名 数据类型, ...... 属性名 数据类型, INDEX|KEY [索引名] （属性名1 [(长度)] [ASC|DESC], ...... 属性名n [(长度)] [ASC|DESC]) ); 在已经存在的表上创建多列索引如下： 12345CREATE INDEX 索引名 ON 表名（属性名1 [(长度)] [ASC|DESC], ...... 属性名n [(长度)] [ASC|DESC] ）; 通过SQL语句ALTER TABLE创建多列索引 12345ALTER TABLE table_name( ADD INDEX|KEY 索引名（属性名1 [(长度)] [ASC|DESC], ...... 属性名n [(长度)] [ASC|DESC] ）; 删除索引DROP INDEX index_name ON table_name;删除索引 视图的操作视图的特点特点如下： 视图的列可以来自不同的表，是表的抽象和在逻辑意义上建立的新关系。 视图是由基本表（实表）产生的表（虚表）。 视图的建立和删除不影响基本表。 对视图内容的更新（添加、删除和修改）直接影响基本表。 当视图来自多个基本表是，不允许添加和删除数据。 创建视图CREATE VIEW view_name AS 查询语句;创建视图USE view;使用视图 常量视图具体语句如下：123CREATE VIEW view_test1 AS SELECT 3.1415926; 封装使用聚合函数（SUM、MIN、MAX、COUNT等）查询语句的视图具体语句如下：1234CREATE VIEW view_test2 AS SELECT COUNT(name) FROM database_name; 封装了实现功能（ORDER BY）查询语句的视图具体语句如下：12345CREATE VIEW view_test3 AS SELECT name FROM table_name ORDER BY id DESC; 封装了实现表内连接查询语句的视图具体语句如下：12345CREATE VIEW view_test4 AS SELECT s.name FROM t_student as s,t_group as g WHERE s.group_id=g.id AND g.id=2; 封装了实现表外连接（LEFT JOIN 和RIGHT JOIN）查询语句视图具体语句如下：12345CREATE VIEW view_test5 AS SELECT s.name FROM t_student as s LEFT JOIN t_group as g ON s.group_id=g.id where g.id=2; 封装了实现子查询相关查询语句的视图具体语句如下：12345CREATE VIEW view_test6 AS SELECT s.name FROM t_student AS s WHERE s.grop_id IN(SELECT id FROM t_group); 封装了实现记录联合（UNION和UNION ALL）查询语句的视图具体语句如下：12345CREATE VIEW view_test7 AS SELECT id,name FROM t_student UNION ALL SELECT id,name FROM t_group; 查看视图USE dababase_name; SHOW TABLES;查看视图名USE database_name; SHOW CREATE VIEW viewname;查看视图定义信息USE database_name; DESCRIBE | DESC viewname;查看视图设计信息SHOW TABLE STATUS [FROM db_name] [LIKE &#39;pattern&#39;];查看视图（和表）详细信息SHOW TABLE STATUS返回字段含义如下图： 删除视图USE database_name; DROP VIEW view_name [,view_name] ...;删除视图 修改视图CREATE OR REPLACE VIEW语句修改视图12345`USE database_name; CREATE OR REPLACE VIEW view_selectproduct AS SELECT name FROM t_products; ALTER 语句修改视图12345`USE database_name; ALTER VIEW view_selectproduct AS SELECT name FROM t_products; 利用视图操作基本表检索（查询）数据SELECT * FROM view_name; 利用视图操作基本表数据 对视图数据进行添加、删除和更新操作直接影响基本表。 视图来自多个基本表时，不允许添加和删除数据。 添加数据操作12INSERT INTO view_name(属性1,属性2，属性3...) VALUES(value1,value2,value3...); 删除数据操作12DELETE FROM view_name WHERE name=’属性名‘; 更新数据操作123UPDATE view_name set 属性1=value WHERE 属性2=value； 触发器的操作在具体的应用中，之所以经常使用触发器数据对象，是由与该对象能够加强数据库表中数据的完整性约束和业务规则等。 创建有一条执行语句的触发器123create trigger trigger_name BEFORE|AFTER trigger_EVENT ON TABLE_NAME FOR EACH ROW trigger_STMT; 创建包含多条执行语句的触发器123456create trigger trigger_name BEFORE|AFTER trigger_EVENT ON TABLE_NAME FOR EACH ROW BEGIN trigger_STMT END; 查看触发器SHOW TRIGGERS;语句查看触发器通过查看系统表triggers实现查看触发器，如下12USE information_schema;SELECT * FROM triggers (WHERE TRIGGER_NAME=&apos;trigger_name&apos;) \G 删除触发器DROP TRIGGER trigger_name;删除触发器 数据操作插入数据插入一部分数据12INSERT INTO table_name(field1,field2,field3,......fieldn) VALUES(value1,value2,value3......valuen); 插入完整数据12INSERT INTO table_name VALUES(value1,value2,value3......valuen); 插入多天数据123456789101112131415#插入多条部分数据INSERT INTO table_name(field1,field2,field3,...fieldn) VALUES(value11,value21,value31...valuen1), (value11,value21,value31...valuen1), (value11,value21,value31...valuen1), ...... (value1m,value2m,value3m...valuenm);#插入多条完整数据INSERT INTO table_name VALUES(value11,value21,value31...valuen1), (value11,value21,value31...valuen1), (value11,value21,value31...valuen1), ...... (value1m,value2m,value3m...valuenm); 插入查询结果1234INSERT INTO table_name1(field11,field12,field13,...field1n) SELECT (field21,field22,field23,...field2n) FROM table name2 WHERE ... 更新数据记录12345UPDATE table_name SET field1=value1, field2=value2, field3=value3, WHERE CONDITION 删除特定数据记录 12DELETE FROM table_nameWHERE CONDITION 单表数据记录查询简单数据查询一般查询SELECT field1 field2 ...fieldn FROM table_name; 查询指定字段数据SELECT * FROM table_name; 查询所有字段数据SELECT DISTINCT field1 field2 ...fieldn FROM table_name;避免数据重复查询–DISTINCT 实现数学四则运算数据查询mysql支持的关系运算符如下：12345SELECT field1 [AS] otherfield1,field2 [AS] otherfield2,...fieldn [AS] otherfieldnFROM table_name#例如：SELECT ename,sal*12 [AS] yearsalaryFROM t_employee; 设置显示格式数据查询如下显示的是以固定的格式（ename雇员的年薪为：sal）显示查询到数据12SELECT CONCAT(ename,&apos;雇员的年薪为：&apos;,sal*12) yearsalary FROM t_employee; 结果为： 条件数据记录查询条件查询的语法格式123SELECT field1、field2 ...field3 FROM table_name WNERE CONDITION; 带关系运算符和逻辑运算符的条件数据查询带（not）between value1 and value2查询（不）符合范围之内IS （NOT） NULL查询是（不是）空值 带IN关键字的集合查询注意：IN查询时，查询集合中包括NULL,则不会影响结果；NOT IN查询时，查询集合中包括NULL,则查询不到结果。1234SELECT field1 field2 ...fieldnFROM table_nameWHERE field IN(value1,value2,value3,...,valuen);//在集合中WHERE field NOT IN(value1,value2,value3,...,valuen);//不在集合中 带LIKE关键字模糊查询123SELECT field1 field2 ...fieldnFROM table_nameWHERE field [NOT] LIKE value; LIKE支持的通配符如下： “_”通配符，该通配符值能匹配单个字符 “%”通配符，该通配符可以匹配任意长度单位字符串，可以0个字符、1个或者更多 排序数据记录查询1234SELECT field1 field2 ...fieldnFROM table_nameWHERE CONDITIONORDER BY fieldm1 [ASC|DESC] [,fieldm2 [ASC|DESC],]; 限制数据记录查询数量12345SELECT field1 field2 ...fieldnFROM table_name where CONDITION LIMIT OFFSET_START,ROW_COUNT;#OFFSET_START为初始位置，可以选择不指定数据。 统计函数和分组数据记录查询 COUNT()：记录条数。 AVG()：平均值。 SUN():总和。 MAX():最大值。 MIN():最小值。 注意：如果操作表中没有数据，则COUNT()函数返回为0，其它返回为NULL. 分组数据查询分组查询的简单格式：1234SELECT function() FROM table_name WHER CONDITION GROUP BY field; 下面为分组查询不同情况： function()为*时是简单分组查询 function()为GROUP_CONCAT(field)时实现统计功能分组查询，如下： 123SELECT deptno,GROUP_CONCAT(ename),COUNT(ename) number FROM t_employee GROUP BY deptno; 多字段分组查询 1234SELECT GROUP_COUNT(field),function(field)FROM table_nameWHERE CONDITIONGROUP BY field1,field2,...fieldn; 实现HAVING字句限定分组查询 1234567891011SELECT function(field)FROM table_nameWHERE CONDITIONGROUP BY field1,field2,...fieldnHAVING CONDITION;#例如：SELECT deptno,AVG(sal) average,GROUP_CONCAT(ename) ename,COUNT(ename) numberFROM t_employeeGROUP BY deptnoHAVING AVG(sal)&gt;2000; 自定义排序1234567891011121314151617181920212223242526原表 user：id name roleId1 aaa 12 bbb 23 ccc 34 ddd 45 eee 5- MySQL可以通过field()函数自定义排序，格式：field(value,str1,str2,str3,str4)，value与str1、str2、str3、str4比较，返回1、2、3、4，如遇到null或者不在列表中的数据则返回0.例如：select * from user order by field(roleId,2,3,4,1,5);结果：id name roleId2 bbb 23 ccc 34 ddd 41 aaa 15 eee 5- locate（substr,str）函数返回子串substr在字符串str中第一次出现的位置，可以根据该函数进行排序例如：select * from user order by locate(id,&apos;2,3,1,5,4&apos;);结果：id name roleId2 bbb 23 ccc 31 aaa 15 eee 54 ddd 4 多表数据记录查询关系数据库操作并（UNION）UNION指令的目的是将两个SQL语句的结果合并起来.UNION的一个限制是两个SQL语句所产生的栏位需要是同样的资料种类。另外，当我们用UNION这个指令时，我们只会看到不同的资料值（类似于SELECT DISTINCT），而UNION ALL会将每一笔符合条件的资料都显示出来，无论资料有没有重复。123SELECT DATA FROM database1UNION ALLSELECT DATA FROM database2; 笛卡尔积SELECT *FROM table1 CROSS JOIN table2;交叉连接笛卡尔积在SQL中的实现方式既是交叉连接(Cross Join)。所有连接方式都会先生成临时笛卡尔积表，笛卡尔积是关系代数里的一个概念，表示两个表中的每一行数据任意组合. 内连接(INNER JOIN)内连接语法形式：123SELECT field1 field2...fieldnFROM join_tablename1 INNER JOIN join_tablename2 [INNER JOIN join_tablename]ON join_condition; 自然连接 在表关系的笛卡尔积中，首先根据表关系中相同名称的字段自动进行记录匹配，然后去掉重复的字段。是一种特殊的等值连接，它要求两个关系进行比较的分量必须是相同的属性组，并且在结果集中将重复属性列去掉。一个简单的例子，将下列关系R和S进行自然连接： 1234567891011121314SELECT *from R natural join S;R：A B Ca b cb a dc d ed f gS：A C Da c dd f gb d g 首先要对两个关系中相同属性组的分量进行比较，即比较R.A，R.C和S.A,S.C。 显然在R中只有第一行和第二行满足条件，因此进行连接得到结果：123A B C Da b c db a d g 等值连接表关系的笛卡尔积中，选择所匹配字段值相等（=符号）的数据记录。下面为等值连接与自然连接的区别： 等值连接中不要求相等属性值的属性名相同，而自然连接要求相等属性值的属性名必须相同，即两关系只有在同名属性才能进行自然连接。 等值连接不将重复属性去掉，而自然连接去掉重复属性，也可以说，自然连接是去掉重复列的等值连接。一个简单的例子，将下列关系R和S进行等值连接： 1234567891011121314select *from R inner join SON R.B=S.C;R：A B Ca b cb a dc d ed f gS：A C Da c dd f gb d g 比较R.B=S.C。 显然在R中只有第一行和第二行满足条件，因此进行连接得到结果：123R.A R.B R.C S.A S.C S.Dc d e b d gd f g d f g 不等查询表关系的笛卡尔积中，选择所匹配字段不相等的数据操作。内连接查询中的不等连接，就是在关键字ON后的匹配条件中通过除了等于关系运算符来实现不等条件外，可以使用的关系运算符包含”&gt;””&gt;=””&lt;””&lt;=”和”!=”等运算符号。一个简单的例子，将下列关系R和S进行不等值连接： 1234567891011121314select *from R inner join SON R.B!=S.C AND R.A!=&quot;c&quot;;R：A B Ca b cb a dc d ed f gS：A C Da c dd f gb d g 比较R.B=S.C 和 R.A!=”c”。 显然在R中只有第一行和第二行满足条件，因此进行连接得到结果：12R.A R.B R.C S.A S.C S.Dc d e b d g 外连接所谓外连接(OUTER JOIN),就是在表关系的笛卡尔积数据记录中，不仅保留关系中所有匹配的数据记录，而且还会保留部分不匹配的数据记录。按照保留不匹配的数据记录来源可以分为左外连接（LEFT OUTER JOIN）、右外连接（RIGHT OUTER JOIN)和全外连接（FULL OUTER JOIN). 一个简单的例子，为外连接的各种情况： 123456789101112131415161718192021222324252627282930313233a表 id name 1 张3 2 李四 3 王武 b表 id jod parent_id1 23 12 34 23 34 4 左连接 select a.*,b.* from a left join b on a.id=b.parent_id 结果是 1 张3 1 23 1 2 李四 2 34 2 3 王武 null 右连接 select a.*,b.* from a right join b on a.id=b.parent_id 结果是 1 张3 1 23 1 2 李四 2 34 2 null 3 34 4 完全连接 select a.*,b.* from a full join b on a.id=b.parent_id 结果是 1 张3 1 23 1 2 李四 2 34 2 null 3 34 4 3 王武 null 合并查询记录结果语法如下：123456789SELECT field1 field2 ...fieldn FROM tablename1UNION |UNION ALLSELECT field1 field2 ...fieldn FROM tablename2UNION |UNION ALLSELECT field1 field2 ...fieldn FROM tablename3UNION |UNION ALL 子查询例子如下：12345678910111213141516171819202122232425- 单行子查询 select ename,deptno,sal from emp where deptno=(select deptno from dept where loc=&apos;NEW YORK&apos;)；- 多行子查询 SELECT ename,job,sal FROM EMP WHERE deptno in ( SELECT deptno FROM dept WHERE dname LIKE &apos;A%&apos;)；- 多列子查询 SELECT deptno,ename,job,sal FROM EMP WHERE (deptno,sal) IN (SELECT deptno,MAX(sal) FROM EMP GROUP BY deptno)；- 内联视图子查询 (1)SELECT ename,job,sal,rownum FROM (SELECT ename,job,sal FROM EMP ORDER BY sal)； (2)SELECT ename,job,sal,rownum FROM ( SELECT ename,job,sal FROM EMP ORDER BY sal) WHERE rownum&lt;=5； - 在HAVING子句中使用子查询 SELECT deptno,job,AVG(sal) FROM EMP GROUP BY deptno,job HAVING AVG(sal)&gt;(SELECT sal FROM EMP WHERE ename=&apos;MARTIN&apos;)； · 使用MySQL运算符算术、比较、逻辑和位运算符 算术运算符如下图：注意：”&gt;”、”&lt;”、”&gt;=”和”=&lt;”比较运算符不能操作NULL(空值)。 比较运算符如下图：特殊功能运算符（实现正则表达式匹配的需要REGEXP）：如下图：如下图： 逻辑运算符如下图： 位运算符 MySQL常用的函数使用字符串函数 合并字符串函数CONCAT(S1,S2...SN)CONCAT_WS(SEP,S1,S2...SN) SEP为分隔符可以为一个字符串，也可以为其他参数，如果为NULL时返回NULL，其它位置的NULL则可忽略; 比较字符串大小函数STRCMP()STRCMP(str1,str2);str1&gt;str2为1，str1&lt; str2为-1，str1=str2为0 获取字符串的长度函数LENGTH()和字符数函数CHAT_LENGTH()LENGTH(str);参数str的长度CHAR_LENGTH(str);参数str的字符数 大小写转换UPPER(S)或者UCASE(S)转换为大写LOWER(S)或者LCASE(S)转换为小写 查找字符串位置FIND_IN_SET(str1,str2);返回字符串str2中与str1相匹配的字符串位置，str2包含若干个用逗号隔开的字符串。FIELD(str,str1,str2...);返回一个与字符串str匹配的位置（str1位置为1开始） 返回字符串相匹配的开始位置LOCATE(str1,str)、POSITION(str1 IN str)和INSTR(str,str1)在str中返回str1的开始位置。 从现有字符串中截取子字符串LEFT(str ,num)返回字符串中str中包含前num个字母（从左边数）的字符串。RIGHT(str ,num)返回字符串中str中包含后num个字母（从左边数）的字符串。 去除字符串的首尾空格LTRIM(str);去除字符串开始处空格RTRIM(str);去除字符串结束处空格TRIM(str);去除字符串首尾空格 替代字符串INSERT(str,pos,len,newstr);字符串中的pos位置开始长度为len的字符串用字符串newstr来替换。如果参数pos的值超过字符串的长度，这返回值为原始字符串str.如果len的长度大于原来字符串（str)中所剩字符串的长度，则从位置pos开始进行全部替换。若任何一个参数为NULL，则返回Null.REPLACE(str,substr,newstr);字符串substr用字符串newstr来替代。 使用数值函数常用的数值函数： 0~1随机数RAND();完全随机RAND(X);X相同时返回相同的值 整数随机数CEIl(X)或CEILING(X);大于或者等于数值X的最小整数FLOOR(X);小于或者等于数值X的最大整数 截取数值函数TRUNCATE(x,y);返回数值x保留到小数点后y位的值，y可以为负数。 四舍五入ROUND(x,y); 返回数值x保留到小数点后y位的值，在具体截取数值是需要进行四舍五入的操作。单没有y时默认为四舍五入到整数。 使用日期和时间函数常用的时间日期函数： 获取当前时间当前时间NOW(),CURRENT_TIMESTAMP(),LOCALTIME(),SYSDATE();2017-03-20 17:38:50CURDATE(),CURRENT_DATE();2017-05-02CURTIME(),CURRENT_TIME();16:29:59UNIX_TIMESTAMP(NOW());unix格式，可以不用参数表示当前时间，从1970年1月1号开始计算，以秒为单位。FROM_UNIXTIME(UNIX_TIMESTAMP(NOW()));把NUIX格式转换为普通格式同NOW()格式。UTC_DATE();UTC日期 2012-05-22UTC_TIME();UTC时间 13:00:01 获取时间和日期的各个部分获取时间和日期的各个部分的功能如下：关于月份：MONTH(NOW());月MONTHNAME(NOW());月关于星期：关于天的函数：DAYOFYEAR(NOW());年中第几天DAYOFMONTH(NOW());月中第几天获取指定值得EXTRACT()函数EXTRACT(tye FROM date);函数会从时间和日期参数中获取指定类型type的值。关于type参数的值可以是YEAR、MONTH、DAY、HOUR、MINUTE和SECOND。 计算日期和时间函数TO_DAYS(date);从0000年1月1日开始算起多少天。FROM_DAYS(TO_DAYS(NOW()));一段时间后日期和时间。DATEDIFF(DATE1,DATE2);日期参数之间的相隔天数。ADDTIME(DATE,n);date加上n秒后的时间。SUBTIME(DATE,n);date减上n秒后的时间。ADDDATE(DATE,n);date加上n天后的日期。SUBDATE(DATE,n);date减上n天后的日期。关于ADDDATE()和SUBDATE()函数另外用法：ADDDATE(d,INTERVAL expr type);日期d加上一段时间后的日期，expr决定时间的长度，type决定了操作对象。SUBDATE(d,INTERVAL expr type);日期d减去一段时间后的日期，expr决定时间的长度，type决定了操作对象。参数type类型：例子如下： 使用系统信息函数常用系统信息函数 其它函数流程函数如下： 特殊函数如下： 存储过程和函数的操作存储过程和函数的执行效率要比在程序中拼sql语句的执行效率要高。存储过程与函数区别：函数必须有返回值，而存储过程则没有，存储过程的参数类型远远多于函数。 创建存储过程和函数创建存储过程语法形式如下图： 创建函数语法形式 创建简单的存储过程和函数存储过程简单sql语句：12345678910USE company;DELIMITER $$CREATE PROCEDURE proce_employee_sal()COMMENT&apos;查询所有雇员的工资&apos;BEGIN SELECT sal FROM t_employee;END$$DELIMITER ; 函数简单SQL语句：123456789101112USE company;DELIMITER $$CREATE FUNCTION func_employee_sal(empno INT(11)) RETURNS DOUBLE(10,2)COMMENT&apos;查询所有雇员的工资&apos;BEGIN RETURN (SELECT sal FROM t_employee WHERE t_employee.empno=empno);END$$DELIMITER ; MySQL事务当多个用户访问同一份数据，一个用户在更改数据的过程中可能有其他客户同时发起更改请求，为了保证数据库记录的更新从一个一致性状态更改为另外一个一致性状态，使用事务处理是非常必要的，事务有以下4个特性： 原子性（Atimicity):事务中所有的操作视为一个原子单位，即对事务所进行的数据修改等操作只能完全提交或者完全回滚。 一致性（Consistency):事务在完成时，必须是所有的数据从一种一致性状态变更为另外一种一致性状态，所有的变更都必须应用于事务的修改，以确保数据的完整性。 隔离性（ISOLATION):一个事务中的操作语句所做的修改必须与其他事务所做的修改相隔离。 持久性（Durability):事务完成后，所做的修改对数据的影响是永久的，即使系统重启或者出现系统故障数据仍可以恢复。 MySQL数据库维护和性能提高MySQL数据库性能优化建议如下： MySQL软件具有特定的硬件建议，在具体安装和使用数据库软件时，该软件所依托的计算机服务器最好能够遵循这些硬件建议。一般来说MySQL软件应该运行在自己的专用计算机服务器上。 MySQL软件安装成功后，会进行一系列的默认配置，这些配置开始通常是比较适合的，但是一段时间后，就需要调整内存分配、缓存区大小。可以通过执行SHOW VARIABLES 和SHOW STATES来实现。 MySQL软件是一个多用户多线程的数据库管理系统，对于该类型的服务器，经常会同时执行多个任务。如果这些任务中的某一个执行缓慢，则其他所有任务都会执行缓慢。为了解决这个问题，可以通过执行SQL语句show processlist显示所有的活动进程，或者通过执行kill命令终结消耗太多资源的进程。 通过SELECT语句实现多表查询时，应该多次试验连接和子查询等各种方式，找出最佳的方式。在具体判断select语句执行性能时，可以通过explain查看select语句的执行情况。 使用数据储存过程比一条一条执行语句速度要快许多。 不要查找比需求还要多的数据内容，换言之，不要执行“select *”语句，除非要真正需要查询所有字段。 通过UNION关键字连接的select语句，替代包含一系列复杂OR条件的SELECT语句，可以极大的改进性能。 数据库对象索引可以改善数据检索的性能，但会损失数据CUD操作（数据插入、数据更新和删除）性能。因此不经常查询的表，最好不要创建索引。 关键字LIKE的执行效率很低，一般来说，会通过“full text”来替代关键字LIKE; 数据库中的表时不断变化的实体。一组结构优良的表，使用一段时间后，表的使用和内容就会需要进行更改，因此当初理想的优化和配置就需要改变。]]></content>
      <categories>
        <category>Database</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Markdown using]]></title>
    <url>%2F2017%2F01%2F12%2FMarkdown%2F</url>
    <content type="text"><![CDATA[Markdown 和 Haroopad 介绍文档 要想写一遍自己的博客，一个好的工具往往会带来很多的便利这里我推荐本人使用的一款工具Markdown编辑器Haroopad Markdown简介 是一种轻量级标记语言，创始人为约翰·格鲁伯（John Gruber）。它允许人们“使用易读易写的纯文本格式编写文档，然后转换成有效的XHTML(或者HTML)文档”。这种语言吸收了很多在电子邮件中已有的纯文本标记的特性。 —— 维基百科可以理解是通过类似html的语法渲染文本的工具。 正如您在阅读的这份文档，它使用简单的符号标识不同的标题，将某些文字标记为粗体或者斜体，跨平台，代码高亮，Vim 键绑定，多列模式，行号，折叠， Github Flavored Markdown 等功能~下面列举了几个高级功能，更多语法可以查看官网或者中文文档。 标题可以在标题内容前输入特定数量的井号(‘#’)来实现对应级别的HTML样式的标题(HTML提供六级标题) 特殊格式的字体在需要改变的文字片段前后 使用一对符号可以改变文字为特殊格式： 粗体 使用**文字**或者__文字__ 效果：这里请大家尤其注意！ 斜体 使用*文字*或者_文字_ 效果：会不调用父类的 析构函数 呢？ 高亮 使用 ==文字== 效果：==这里是高亮的重点==，但这里不是。 下划线 使用++文字++ 效果：如果此时的++判断结果为真++…… 删除线 使用~~文字~~ 效果：1.2的版本已经修复这个Bug？ 上角标 使用^文字^ 效果：单位圆的方程式是x^2^+y^2^=1。 下角标 使用~文字~ 效果：最常见的氧化反应是C+O~2~=CO~2~ 代码块引用代码块的时候，先空一行，按tab接着就可以编写您需要的代码了 function a(){ return(&quot;这是引用代码，亦即使代码块在浏览器显示的时候，区别对待&quot;)； } LaTeX 公式为了让haroopad支持数学公式首先需要在配置里面开启数学公式支持点击文件-&gt;偏好设置-&gt;markdown-&gt;将数学表达式全部勾选 可以创建行内公式，例如 $$\sqrt{3x-1}+{1+x}^2$$或者块级公式： $$x = \dfrac{-b \pm \sqrt{b^2 - 4ac}}{2a}$$ 表格Haroopad中绘制表格的语法如下: 效果如下: 姓名 性别 年龄 张三 男 20 李四 女 20 流程图Haroopad支持 mermaid 扩展。Mermaid是一套绘图的符号语言扩展，支持绘制各种关系图，序列图 Haroopad中mermaid绘图以 ~~~mermaid 单独一行开始，以 ~~~ 单独一行结束。 其中graph TD指定绘图方向是从上而下 改为graph LR则是从左至右 绘制流程图的语法如下： 效果如下: Mermaid扩展还支持其它绘图方式，以及调整绘图样式，具体见绘图介绍 12345678910111213141516171819graph TD; subgraph 子图; a1[矩形]; a2&gt;旗帜形]; a3(圆角方形); end; subgraph 第二个子图; b1((圆形)); b2&#123;斜方形&#125;; end; a1--&gt;|实线箭头|a2; a2--&gt;a1; a2-.-&gt;|虚线箭头|a3; a3-.-&gt;a2; a3==&gt;|加粗箭头|a1; a1==&gt;a3; b1---b2; b2---|实线无箭头|b1; a1--&gt;b1; 时序图 ~~~mermaid sequenceDiagram Alice->>Bob: Hello Bob, how are you? alt is sick Bob->>Alice: Not so good :( else is well Bob->>Alice: Feeling fresh like a daisy end opt Extra response Bob->>Alice: Thanks for asking end ~~~ 复选框（任务清单）使用 - [ ] 和 - [x] 语法可以创建复选框，实现 todo-list 等功能。Haroopad扩展支持tasklist，语法如下： [x] a [ ] b [ ] c [ ] d **目前支持尚不完全，在编辑器勾选复选框是无效、不能同步的 ###兼容HTML 一些 HTML 区块元素――比如 &lt;div&gt;、&lt;table&gt;、&lt;pre&gt;、&lt;p&gt; 等标签，需在标签前后加上空行，且标签本身不能缩进 在HTML里面的Markdown是不被解析的 在Markdown里面可以是直接空格+enter键换行，也可以是使用&lt;br/&gt;标签进行换行 使用标签换行的方法是在需要换行的地方键入两个空格，回车之后加上&lt;br/&gt;标签即可语法示例：效果显示： 我要 在第二个字换行 区块引用，直接在文本前面增加&gt;符号即可（使用不同数量的&gt;符号可以进行引用的嵌套，并且还支持Markdown语法） 段落和换行 你可以在一行中用三个以上的星号、减号、底线来建立一个分隔线，行内不能有其他东西。你也可以在星号或是减号中间插入空格。 链接（行内式和参考式） 行内式语法加效果This is [an example](http://example.com/ &quot;Title&quot;) inline link.This is an example inline link. 参考式语法加效果This is [an example] [id] reference-style link.This is [an example][id] reference-style link. 强调(在需要强调的文字两边加上*或者_字符) 反引号` 起到保护不被解析的作用 图片（行内式和参考式） ![Alt text](/path/to/img.jpg)![Alt text](/path/to/img.jpg &quot;Optional title&quot;)[id]: url/to/image &quot;Optional title attribute&quot; 自动链接Markdown 支持以比较简短的自动链接形式来处理网址和电子邮件信箱，只要是用尖括号包起来， Markdown 就会自动把它转成链接。一般网址的链接文字就和链接地址一样 总结 由于其简单易用，Markdown在社区已经越来越流行。甚至有些项目将自动化测试用例都用markdown语法来写，可以直接发布给客户当作说明文档，执行的时候靠一段解释代码将其翻译成目标语言执行，真的做到测试即文档。而Haroopad是一款非常强大的markdown编辑器，它内置的很多mardown扩展都是为了方便程序员，避免了大家到处寻找插件自行配制的繁琐。到目前为止haroopad是我找到的最好用的markdown编辑器，这篇文档就是用haroopad撰写。最后在支持如此多的特性后，haroopad依然非常轻量！ 希望Haroopad同样适合你！]]></content>
      <categories>
        <category>blog</category>
      </categories>
      <tags>
        <tag>Markdown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[了解如何搭建自己的hexo博客]]></title>
    <url>%2F2016%2F12%2F11%2F%E4%BA%86%E8%A7%A3%E5%A6%82%E4%BD%95%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84hexo%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[前段时间在朋友的帮助下，也找过很多资料来搭建自己的hexo博客，之前也就是在简述上写自己的博客文章，说真的，自己如果懂得如何搭建博客来写，更有些自豪感。废话就不多说了，下面就来了解一下hexo以及如何搭建一个属于自己的hexo博客。 了解hexohexo文档给出的hexo定义是：Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。 hexo出自台湾的tommy351之手，一个基于Node.js的静态博客程序，可以很方便的生成静态网页托管于github、gitcafe和Heroku，类似于jekyll，但Jekyll需要的git命令稍有点繁琐。 重要的是hexo是免费的，可以在各个平台上搭建，如GitHub、GitCafe、coding、七牛。可以快速渲染自己编写的markdown文件。 hexo的依赖 搭建nodejs环境 （必须） node官网 git （必须） windows 下载：git linux 下载：12$ sudo apt-get update$ sudo apt-get install git coding（ 必须 ，可以用github来搭建） 域名（个性化）域名只是让你的博客访问更有个性化，coding默认的访问博客的地址是 http://your-coding-name.coding.me/your-repo-name ，在github中的访问地址是：https://your-github-name.github.io/your-repo-name/ 编写hexo可以使用Atom，我挺喜欢这款编辑器的markdown预览功能 安装hexo安装hexo，打开git bash操作界面（cmd界面也可以）1npm install -g hexo 初始化blog项目，并安装依赖1234mkdir blogcd bloghexo initnpm install 运行hexo，在本地中预览 - 全称（hexo server）1hexo s 直接输入http://localhost:4000/就可以看到本地部署的hexo 紧接着就创建自己的coding项目，把本地的hexo放到远程的coding上运行。 本人是把hexo放在master分支，博文放到coding-pages分支中。 在coding中创建博客项目创建博客项目 这时写上项目名以及项目的描述。 绑定ssh检查本地是否存在ssh key：1$ cd ~/.ssh 生成ssh如果本地没有，那么就在本地中生成ssh证书，生成的证书中有两个文件，一个是私钥，一个是公钥。1ssh-keygen -t rsa -C &quot;邮箱地址&quot; 执行以上代码，会弹出是否需要输入密码，输不输入密码关系不大，这里选择不输入密码。 把公钥(id_rsa.pub)的内容拷贝到coding账户 -&gt; SSH公钥 -&gt; 新增公钥的内容中去，写上公钥名字，以及将公钥的有效期的永久有效勾上 测试对于coding，git@git.coding.net（在windows中是没有ssh指令，可以使用git bash命令窗口就能找到）1$ ssh -T git@git.coding.net 对于github，git@github.com不需要修改1$ ssh -T git@github.com 会出现类以下的反馈123The authenticity of host &apos;github.com (207.97.227.239)&apos; can&apos;t be established.RSA key fingerprint is 16:27:ac:a5:76:28:2d:36:63:1b:56:4d:eb:df:a6:48.Are you sure you want to continue connecting (yes/no)? 点击yes，就ok了。 在hexo中配置与coding相连打开你在本地创建的项目blog，找到_config.yml,打开配置如下，将内容推送到coding-pages分支中1234deploy: type: git repo: git@git.coding.net:your-coding-name/your-repo-name.git branch: coding-pages 在你的博客项目blog，初始化为git仓库安装完git，需要配置以下信息12$ git config --global user.name &quot;username&quot; //用户名$ git config --global user.email &quot;youremail&quot; //填写自己的邮箱 初始化项目1git init 选择要添加进仓库的文件：1git add . 如果你想分享这个文件夹里所有代码，就在add后面加“.”，如果指定某个文件，只需把“.”改为文件名即可。添加进入仓库：1git commit -m &quot;first commit&quot; -m后面的参数，表示说明，将代码提交到GitHub后，将会给出一个提交说明，表明这是我哪次提交的。所有工作已准备充分，现在开始提交，还是几条命令：123456// 添加coding源git remote add origin git@git.coding.net:your-coding-name/your-repo-name.git// 执行 git push 没有指定分支时，只有当前分支会被 push 到你使用 git pull 获取的代码。git config --global push.default simple// 上传本地项目代码到master分支git push -u origin master 开启Pages服务及配置域名域名的使用购买域名后，可以配置子域名来绑定hexo博客 将记录类型设置成CNAME 主机记录，你喜欢 记录值设置成，pages.coding.me设置成那样就可以了 Pages里添加域名访问呢进入刚才创建的项目中，点击左侧的代码，再进入Pages服务页面中，点击立即开启，部署来源选择coding-pages分支。 好像是找不到coding-pages分支的，那么就要手动创建一个coding-pages分支，然后指定分支开启服务。 在自定义域名里，可以填写自己已经注册的域名，这样就可以通过自己的域名去访问你的博客 开始使用以上配置好后，使用域名就可以访问了 新建文章1hexo n &quot;postName&quot; 相当于 hexo new &quot;postName&quot; 新建页面1hexo n page &quot;pageName&quot; 相当于hexo new page &quot;pageName&quot; 生成静态页面至public目录1hexo g 相当于hexo generate 开启预览本地博客服务，地址为http://localhost:4000/1hexo s 相当于hexo server 将.deploy目录部署到远程项目中1hexo d 相当于hexo deplog 安装hexo-deployer-git插件 - 第一次使用要安装这个插件1npm install hexo-deployer-git --save 清除缓存文件 (db.json) 和已生成的静态文件 (public)1hexo clean 查看帮助1hexo h 相当于hexo help 查看hexo的版本1hexo v 相当于hexo version 一般你写好自己的文章或配置好自己的设置，使用以下命令即可123hexo cleanhexo ghexo d 主题 - 我这个主题为Next下载Next主题12$ cd your-hexo-site`$ git clone https://github.com/iissnan/hexo-theme-next themes/next 修改配置文件找到根目录下的_config.yml文件，修改theme使支持12345# Extensions## Plugins: http://hexo.io/plugins/## Themes: http://hexo.io/themes/#theme: landscapetheme: next 选择Scheme为Mist，自己觉得这个样式会比较好看找到主题配置文件，blog/themes/next目录下的_config.yml文件1234# Schemes#scheme: Musescheme: Mist#scheme: Pisces 添加tags标签，与页面中的tag对应1hexo new page &quot;tags&quot; 修改/source/tags/index.md文件1234title: tagsdate: 2016-12-04 09:06:02type: &quot;tags&quot;--- 其他配置配置域名与hexo关联前面配置的是，域名与coding之间的关联。 找到根目录的_config.yml文件123456# URL## If your site is put in a subdirectory, set url as &apos;http://yoursite.com/child&apos; and root as &apos;/child/&apos;url: 填写你的域名地址root: /permalink: :year/:month/:day/:title/permalink_defaults: 配置头像在根目录的_config.yml，me.jpg需要放到/blog/source/images目录下12# 头像avatar: /images/me.jpg 配置多说评论在根目录下的配置文件_config.yml添加字段1duoshuo_shortname: commit commit为你注册多说域名的子域名，就如你多说的域名为：http://commit.duoshuo.com 使你的菜单栏显示中文在根目录下的配置文件_config.yml找到language字段，修改为zh-Hans12# Sitelanguage: zh-Hans 配置社交链接12345678# Social linkssocial: GitHub: git地址# Social Iconssocial_icons: enable: true # Icon Mappings GitHub: github 如果想添加其他社交链接，可以查看官方文档 配置hexo插件添加网站地图12npm install hexo-generator-sitemap --savenpm install hexo-generator-baidu-sitemap --save 在站点配置文件_config.yml中添加如下代码12345# hexo sitemapsitemap:path: sitemap.xmlbaidusitemap:path: baidusitemap.xml 配置成功后，会生成在public目录下生成sitemap.xml 和 baidusitemap.xml，前者适合提交给谷歌搜素引擎，后者适合提交百度搜索引擎。 其次，在 robots.txt 中添加下面的一段代码：12Sitemap: http://blog.tangxiaozhu.com/sitemap.xmlSitemap: http://blog.tangxiaozhu.com/baidusitemap.xml 将robots.txt 放置在\source 目录下。 参考hexo官方文档next主题文档使用 Hexo 搭建博客的深度优化与定制Hexo搭建GitHub博客（三）- NexT主题配置使用HEXO+Github,搭建属于自己的博客]]></content>
      <categories>
        <category>blog</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式--Facade(外观模式)]]></title>
    <url>%2F2016%2F04%2F07%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F--Facade(%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F)%2F</url>
    <content type="text"><![CDATA[为子系统中的一组接口提供一个一致的界面，Facade模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。 将一个系统划分成为若干个子系统有利于降低系统的复杂性。一个常见的设计目标是使子系统间的通信和相互依赖关系达到最小。 达到该目标的途径之一是就是引入一个外观（Facade）对象，它为子系统中较一般的设施提供了一个单一而简单的界面。 Facade模式概述 实际应用中，我们在对付一些老旧的code（尤其是将C的代码转成C++代码）或者即便不是老旧code，但涉及多个子系统时，除了重写全部代码 （对于老旧code而言），我们还可能采用这样一种策略：重新进行类的设计，将原来分散在源码中的类/结构及方法重新组合，形成新的、统一的接口，供上层应用使用。这在某种意义上与Adapter及Proxy有类似之处，但是，Proxy（代理）注重在为Client-Subject提供一个访问的中间层，如CORBA可为应用程序提供透明访问支持，使应用程序无需去考虑平台及网络造成的差异及其它诸多技术细节；Adapter（适配器）注重对接口的转换与调整；而Facade所面对的往往是多个类或其它程序单元，通过重新组合各类及程序单元，对外提供统一的接口/界面。 Facade模式应用在遇到以下情况使用Facade模式：1、当你要为一个复杂子系统提供一个简单接口时。子系统往往因为不断演化而变得越来越复杂。大多数模式使用时都会产生更多更小的类。这使得子系统更具可重用性，也更容易对子系统进行定制，但这也给那些不需要定制子系统的用户带来一些使用上的困难。Facade可以提供一个简单的缺省视图，这一视图对大多数用户来说已经足够，而那些需要更多的可定制性的用户可以越过Facade层。2、客户程序与抽象类的实现部分之间存在着很大的依赖性。引入Facade将这个子系统与客户以及其他的子系统分离，可以提高子系统的独立性和可移植性。3、当你需要构建一个层次结构的子系统时，使用Facade模式定义子系统中每层的入口点，如果子系统之间是相互依赖的，你可以让它们仅通过Facade进行通讯，从而简化了它们之间的依赖关系。 Facade模式优缺点Facade模式有下面一些优点：1、它对客户屏蔽子系统组件，因而减少了客户处理的对象的数目并使得子系统使用起来更加方便。2、它实现了子系统与客户之间的松耦合关系，而子系统内部的功能组件往往是紧耦合的。松耦合关系使得子系统的组件变化不会影响到它的客户。Facade模式有助于建立层次结构系统，也有助于对对象之间的依赖关系分层。Facade模式可以消除复杂的循环依赖关系。这一点在客户程序与子系统是分别实现的时候尤为重要。在大型软件系统中降低编译依赖性至关重要。在子系统类改变时，希望尽量减少重编译工作以节省时间。用Facade可以降低编译依赖性，限制重要系统中较小的变化所需的重编译工作。Facade模式同样也有利于简化系统在不同平台之间的移植过程，因为编译一个子系统一般不需要编译所有其他的子系统。3、如果应用需要，它并不限制它们使用子系统类。因此你可以在系统易用性和通用性之间加以选择。图实例： 举例代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136package design.facade; public interface ServiceA &#123; /** * ServiceA 的A方法 * */ public void methodA() ; &#125; package design.facade; public class ServiceAImpl implements ServiceA &#123; /* (non-Javadoc) * @see design.facade.ServiceA#methodA() */ @Override public void methodA() &#123; System.out.println( &quot;methodA--&gt; is runing&quot; ); &#125; &#125; package design.facade; public interface ServiceB &#123; /** * ServiceB 的B方法 * */ public void methodB() ; &#125; package design.facade; public class ServiceBImpl implements ServiceB &#123; /* (non-Javadoc) * @see design.facade.ServiceA#methodA() */ @Override public void methodB() &#123; System.out.println( &quot;methodB--&gt; is runing&quot; ); &#125; &#125; package design.facade; public interface ServiceC &#123; /** * ServiceC 的C方法 * */ public void methodC() ; &#125; package design.facade; public class ServiceCImpl implements ServiceC &#123; /* (non-Javadoc) * @see design.facade.ServiceA#methodA() */ @Override public void methodC() &#123; System.out.println( &quot;methodC--&gt; is runing&quot; ); &#125; &#125; package design.facade; public class Facade &#123; ServiceA sa; ServiceB sb; ServiceC sc; public Facade() &#123; sa = new ServiceAImpl(); sb = new ServiceBImpl(); sc = new ServiceCImpl(); &#125; public void methodA() &#123; sa.methodA(); sb.methodB(); &#125; public void methodB() &#123; sb.methodB(); sc.methodC(); &#125; public void methodC() &#123; sc.methodC(); sa.methodA(); &#125; &#125; package design.facade; public class Client &#123; /** * @param args */ public static void main(String[] args) &#123; ServiceA sa = new ServiceAImpl(); ServiceB sb = new ServiceBImpl(); sa.methodA(); sb.methodB(); System.out.println(&quot;=====================&quot;); Facade f = new Facade(); f.methodA(); f.methodB(); f.methodC() ; &#125; &#125;]]></content>
      <categories>
        <category>Patterns</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ByteBuf和相关辅助类]]></title>
    <url>%2F2016%2F03%2F07%2FByteBuf%E5%92%8C%E7%9B%B8%E5%85%B3%E8%BE%85%E5%8A%A9%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[当我们进行数据传输的时候，往往需要使用到缓冲区，常用的缓冲区就是JDK NIO类库提供的java.nio.Buffer。但是ByteBuffer的API功能有限，一些高级和实用的特性它不支持，需要使用者自己编程实现。为了弥补这些不足，Netty提供了自己的ByteBuffer实现——ByteBuf。 ByteBuf功能说明实际上，7种基础类型（Boolean除外）都有自己的缓冲区实现，对于NIO编程而言，我们主要使用的是ByteBuffer。ByteBuffer的实现类如图1所示。 图1 ByteBuffer的实现类 从功能角度而言，ByteBuffer完全可以满足NIO编程的需要，但是由于NIO编程的复杂性，ByteBuffer也有其局限性，它的主要缺点如下。 ByteBuffer长度固定，一旦分配完成，它的容量不能动态扩展和收缩，当需要编码的POJO对象大于ByteBuffer的容量时，会发生索引越界异常； ByteBuffer只有一个标识位置的指针position，读写的时候需要手工调用flip()和rewind()等，使用者必须小心谨慎地处理这些API，否则很容易导致程序处理失败； ByteBuffer的API功能有限，一些高级和实用的特性它不支持，需要使用者自己编程实现。 ByteBuf的工作原理不同ByteBuf实现类的工作原理不尽相同，我们从ByteBuf的设计原理出发，一起探寻Netty ByteBuf的设计理念。首先，ByteBuf依然是个Byte数组的缓冲区，它的基本功能与JDK的ByteBuffer一致，提供以下几种基本功能。 7种Java基础类型、byte数组、ByteBuffer(ByteBuf)等的读写 缓冲区自身的copy和slice等 设置网络字节序 构建缓冲区实例 操作位置指针等方法 由于JDK的ByteBuffer已经提供了这些基础能力的实现，因此，Netty ByteBuf的实现可以有两种策略。 参考JDK ByteBuffer的实现，增加额外的功能，解决原ByteBuffer的缺点。 聚合JDK ByteBuffer，通过Facade模式对其进行包装，可以减少自身的代码量，减低实现的成本。 ByteBuf读写操作JDK ByteBuffer由于只有一个位置指针用于处理读写操作，因此每次进行读写的时候都需要额外调用filp()和clear()等方法，否则功能将出错，他的典型用法如下。 1234567ByteBuffer buffer=ByteBuffer.allocate(88);String value =&quot;Netty 权威指南&quot;;buffer.put(value.getByte());buffer.filp();byte[] vArray=new byte[buffer.remaining];buffer.get(vArray);String decodeValue=new String(vArray); 我们看下调用filp()操作前后的对比。 图2 ByteBuffer filp()操作之前 如图2 所示，如果不做filp操作，读取到的将是position到capacity之间的错误内容。当执行filp()操作之后，他的limit被设置为position,position设置为0，capacity不变。由于读取的内容是从position到limit之间，因此，他能够正确地读到之前写入缓冲区的内容。如图3所示 图3 ByteBuffer filp()操作之后 ByteBuf通过两个位置指针来协助缓冲区的读写操作，读操作使用readerIndex，写操作使用writeIndex。 readerIndex和writeIndex的取值一开始都是0，随着数据的写入writeIndex会增加，读取数据会使readIndex增加，但是它不会超过writeIndex。在读取之后，0~readerIndex被视为discard的，调用discardReadBytes方法，可以释放这部分空间，它的作用类似ByteBuffer的compact方法。ReaderIndex与writeIndex之间的数据是可读取的，等价于ByteBuffer position 和limit之间的数据。writeIndex与capacity之间的空间是可写的，等价于ByteBuffer limit和capacity之间的可用空间**。由于写操作不修改readerIndex指针，读操作不修改writeIndex指针，因此读写之间不再需要调整位置指针，这极大低简化了缓冲区的读写操作，避免了由于遗漏或者，不熟悉filp()操作导致的功能异常。初始分配的ByteBuf如图4所示。 图4 初始分配的ByteBuf 写入N个字节之后ByteBuf如图5所示。 图5 写入N个字节后的ByteBuf 读取M(&lt; N)个字节之后的ByteBuf如图6所示。 图6 读取M个字节后的ByteBuf 调用disacardReadBytes操作之后的ByteBuf如图7所示。 图7 discardReadByte操作之后的ByteBuf 调用clear操作之后的ByteBuf如图8所示。 图8 clear操作之后的ByteBuf ByteBuf如何实现动态扩展下面我们继续分析ByteBuf是如何实现动态扩展的。通常情况下，当我们对ByteBuffer进行put操作的时候，如果缓冲区剩余可写空间不够，就会发生BufferOverflowException异常。为了避免发生这个问题，通常在进行put操作的时候会对剩余可用空间进行校验，如果剩余空间不足，需要重新创建一个新的ByteBuffer，并将之前的ByteBuffer复制到新创建的ByteBuffer中，最后释放老的ByteBuffer，代码示例如下。1234567if(this.buffer.remaining() &lt; needSize) &#123; int toBeExtSize = needSize &lt; 128 ? needSize : 128; ByteBuffer tmpBuffer =ByteBuffer.allocate(this.buffer.capacity() +toBeExtSize); this.buffer.flip(); tmpBuffer.put(this.buffer); this.buffer = tmpBuffer; &#125; 从示例代码可以看出，为了防止ByteBuffer溢出，每进行一次put操作，都需要对可用空间进行校验，这导致了代码冗余，稍有不慎，就可能引入其他问题。为了解决这个问题，ByteBuf对write操作进行了封装，由ByteBuf的write操作负责进行剩余可用空间的校验，如果可用缓冲区不足，ByteBuf会自动进行动态扩展，对于使用者而言，不需要关心底层的校验和扩展细节，只要不超过设置的最大缓冲区容量即可。当可用空间不足时，ByteBuf会帮助我们实现自动扩展。对于使用者而言，不需要关系底层的校验和扩展细节，只要不超过设置的最大缓冲区容量即可。当可用空间不足时，ByteBuf会帮我们实现自动扩展，这极大地降低了ByteBuf的学习和使用成本，提升了开发效率。校验和扩展的相关代码如图9、10所示。 图9 ByteBuf写入字节图10 ByteBuf写入字节 通过源码分析，我们发现当进行write操作时会对需要write的字节进行校验，如果可写的字节数小于需要写入的字节数，并且需要写入的字节数小于可写的最大字节数时，对缓冲区进行动态扩展。无论缓冲区是否进行了动态扩展，从功能角度看使用者并不感知，这样就简化了上层的应用。 ByteBuf与ByteBuffer转换由于NIO的Channel读写的参数都是ByteBuffer，因此，Netty的ByteBuf接口必须提供API，以方便地将ByteBuf转换成ByteBuffer，或者将ByteBuffer包装成ByteBuf。考虑到性能，应该尽量避免缓冲区的复制，内部实现的时候可以考虑聚合一个ByteBuffer的私有指针用来代表ByteBuffer。在后面的源代码分析章节我们将详细介绍它的实现原理。 ByteBuf的功能介绍对ByteBuffer的常用的API进行分类说明，讲解它的主要功能。 顺序读操作（read）ByteBuf的read操作类似于ByteBuf的get操作，主要的API功能说明如表1所示。表1 ByteBuf的读操作API列表 顺序读写操作（write）ByteBuf的write操作类似于ByteBuffer的put操作，主要的API功能说明如下表2所示。表2 ByteBuf的写操作API列表 readerIndex和writerIndexNetty提供了两个指针变量用于支持顺序读取和写入操作：]]></content>
      <categories>
        <category>Netty</category>
      </categories>
      <tags>
        <tag>network</tag>
      </tags>
  </entry>
</search>
