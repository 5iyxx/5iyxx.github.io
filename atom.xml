<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>5IYXX</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2017-10-20T02:23:46.253Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Eric Chen</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>POJO与JavaBean的区别</title>
    <link href="http://yoursite.com/2017/10/01/POJO%E4%B8%8EJavaBean%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>http://yoursite.com/2017/10/01/POJO与JavaBean的区别/</id>
    <published>2017-10-01T01:43:50.000Z</published>
    <updated>2017-10-20T02:23:46.253Z</updated>
    
    <content type="html"><![CDATA[<p>POJO往往被称为Data对象，而JavaBean更是一个组件技术。</p><a id="more"></a><p>POJO（Plain Ordinary Java Object）简单的Java对象，实际就是普通JavaBeans，是为了避免和EJB混淆所创造的简称。</p><p>使用POJO名称是为了避免和EJB混淆起来, 而且简称比较直接. 其中有一些属性及其getter、setter方法的类,没有业务逻辑，有时可以作为VO(value -object)或dto(Data Transform Object)来使用.当然,如果你有一个简单的运算属性也是可以的,但不允许有业务方法,也不能携带有connection之类的方法。</p><p>POJO对象有时也被称为Data对象，大量应用于表现现实中的对象。如果项目中使用了Hibernate框架，有一个关联的xml文件，使对象与数据库中的表对应，对象的属性与表中的字段相对应。</p><p>POJO 和JavaBean是我们常见的两个关键字，一般容易混淆，POJO全称是Plain Ordinary Java Object / Pure Old Java Object，中文可以翻译成：普通Java类，具有一部分getter/setter方法的那种类就可以称作POJO，但是JavaBean则比 POJO复杂很多， Java Bean 是可复用的组件，对 Java Bean 并没有严格的规范，理论上讲，任何一个 Java 类都可以是一个 Bean 。但通常情况下，由于 Java Bean 是被容器所创建（如 Tomcat) 的，所以 Java Bean 应具有一个无参的构造器，另外，通常 Java Bean 还要实现 Serializable 接口用于实现 Bean 的持久性。 Java Bean 是不能被跨进程访问的。</p><p>JavaBean是一种组件技术，就好像你做了一个扳子，而这个扳子会在很多地方被拿去用，这个扳子也提供多种功能(你可以拿这个扳子扳、锤、撬等等)，而这个扳子就是一个组件。一般在web应用程序中建立一个数据库的映射对象时，我们只能称它为POJO。POJO(Plain Old Java Object)这个名字用来强调它是一个普通java对象，而不是一个特殊的对象，其主要用来指代那些没有遵从特定的Java对象模型、约定或框架（如EJB）的Java对象。理想地讲，一个POJO是一个不受任何限制的Java对象（除了Java语言规范）。</p><p>POJO是一个简单的普通的Java对象，它不包含业务逻辑或持久逻辑等，但不是JavaBean、EntityBean等，不具有任何特殊角色和不继承或不实现任何其它Java框架的类或接口。</p><p>转载于：<a href="http://www.cnblogs.com/Nickzerui/p/4596956.html" target="_blank" rel="external">http://www.cnblogs.com/Nickzerui/p/4596956.html</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;POJO往往被称为Data对象，而JavaBean更是一个组件技术。&lt;/p&gt;
    
    </summary>
    
      <category term="The Basic Of Java" scheme="http://yoursite.com/categories/The-Basic-Of-Java/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Red Hat 7 安装后环境配置</title>
    <link href="http://yoursite.com/2017/06/22/Red%20Hat%207%20%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"/>
    <id>http://yoursite.com/2017/06/22/Red Hat 7 环境配置/</id>
    <published>2017-06-22T12:04:50.000Z</published>
    <updated>2017-09-29T01:49:19.192Z</updated>
    
    <content type="html"><![CDATA[<p>Red Hat 7 安装后环境配置<br><a id="more"></a></p><h3 id="配置静态的ip地址"><a href="#配置静态的ip地址" class="headerlink" title="配置静态的ip地址"></a>配置静态的ip地址</h3><ul><li>查看系统的使用的网卡<br><code>ifconfig</code> 我本地网卡为eno16777736</li><li>打开配置文件<br><code>vi /etc/sysconfig/network-scripts/ifcfg-eno16777736</code></li><li>静态ip设置，需要根据自己的网络参数修改配置文件<br><code>BOOTPROTO=static</code> 指定地址的获取方式<br><code>IPADDR=192.168.0.225</code> ip地址<br><code>NETMASK=255.255.255.0</code> 子网掩码<br><code>GATEWAY=192.168.0.1</code> 网关</li><li>重启服务<br><code>systemctl  restart network</code></li><li>ping测试<br><code>ping 8.8.8.8</code><br><code>PING 8.8.8.8 (8.8.8.8) 56(84) bytes of data.</code><br><code>64 bytes from 8.8.8.8: icmp_seq=1 ttl=45 time=241 ms</code><br>测试如上结果，成功！</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Red Hat 7 安装后环境配置&lt;br&gt;
    
    </summary>
    
      <category term="Operations" scheme="http://yoursite.com/categories/Operations/"/>
    
    
      <category term="Linux" scheme="http://yoursite.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>在Maven中Tomcat热部署</title>
    <link href="http://yoursite.com/2017/05/11/%E5%9C%A8maven%E4%B8%ADTomcat%E7%83%AD%E9%83%A8%E7%BD%B2/"/>
    <id>http://yoursite.com/2017/05/11/在maven中Tomcat热部署/</id>
    <published>2017-05-11T01:43:50.000Z</published>
    <updated>2017-10-14T02:46:07.787Z</updated>
    
    <content type="html"><![CDATA[<p> 在Maven中Tomcat热部署，下面为一个简单做法流程，一共有三步。<br><a id="more"></a><br>第一步：修改tomcat-users.xml配置文件，配置用户、密码和权限。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;role rolename=&quot;manager-gui&quot; /&gt;</div><div class="line">&lt;role rolename=&quot;manager-script&quot; /&gt;</div><div class="line">&lt;user username=&quot;tomcat&quot; password=&quot;tomcat&quot; roles=&quot;manager-gui, manager-script&quot;/&gt;</div></pre></td></tr></table></figure></p><p>启动tomcat后，可以进入后台,如图1.</p><div align="center"><br><img src="/images/Operations/t1.jpg" alt=""><br>图1 后台页面</div><p>第二步：修改ip访问权限<br>对于IP访问权限在设置在/tomcat/webapps/manager/META-INF/context.xml中。<br>早期版本Tomcat默认是没有限制的，如图2所示。</p><div align="center"><br><img src="/images/Operations/t4.jpg" alt=""><br>图2 早期IP限制默认配置</div><p>现在Tomcat对于默认是对IP进行限制的，如果不需要进行限制可以模仿早期Tomcat默认配置，去掉IP限制，<br>默认如图3所示。</p><div align="center"><br><img src="/images/Operations/t5.jpg" alt=""><br>图3 现在IP限制默认配置</div><p>第三步：在pom文件中配置tomcat插件。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">&lt;!-- 配置Tomcat插件 --&gt;</div><div class="line">&lt;plugin&gt;</div><div class="line">&lt;groupId&gt;org.apache.tomcat.maven&lt;/groupId&gt;</div><div class="line">&lt;artifactId&gt;tomcat7-maven-plugin&lt;/artifactId&gt;</div><div class="line">&lt;version&gt;2.2&lt;/version&gt;</div><div class="line">&lt;configuration&gt;</div><div class="line">&lt;port&gt;8080&lt;/port&gt;</div><div class="line">&lt;path&gt;/&lt;/path&gt;</div><div class="line">&lt;url&gt;http://119.29.160.64/manager/text&lt;/url&gt;</div><div class="line">&lt;username&gt;tomcat&lt;/username&gt;</div><div class="line">&lt;password&gt;tomcat20170928&lt;/password&gt;</div><div class="line">&lt;/configuration&gt;</div><div class="line">&lt;/plugin&gt;</div></pre></td></tr></table></figure></p><p>第四步：部署<br>初次部署可以使用 “tomcat7:deploy” 命令<br>如果已经部署过使用 “tomcat7:redeploy” 命令<br>（如果第一次部署到根目录，可以直接用“tomcat7:redeploy”）<br>启动过程如图4、图5.</p><div align="center"><br><img src="/images/Operations/t2.jpg" alt=""><br>图4 Maven build…<br><img src="/images/Operations/t3.jpg" alt=""><br>图5 运行插件</div>]]></content>
    
    <summary type="html">
    
      &lt;p&gt; 在Maven中Tomcat热部署，下面为一个简单做法流程，一共有三步。&lt;br&gt;
    
    </summary>
    
      <category term="Operations" scheme="http://yoursite.com/categories/Operations/"/>
    
    
      <category term="Tomcat" scheme="http://yoursite.com/tags/Tomcat/"/>
    
      <category term="Maven" scheme="http://yoursite.com/tags/Maven/"/>
    
  </entry>
  
  <entry>
    <title>为什么要使用SocketAddress来管理网络地址</title>
    <link href="http://yoursite.com/2017/05/10/%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E4%BD%BF%E7%94%A8SocketAddress%E6%9D%A5%E7%AE%A1%E7%90%86%E7%BD%91%E7%BB%9C%E5%9C%B0%E5%9D%80/"/>
    <id>http://yoursite.com/2017/05/10/为什么要使用SocketAddress来管理网络地址/</id>
    <published>2017-05-10T01:43:50.000Z</published>
    <updated>2017-10-09T08:38:32.078Z</updated>
    
    <content type="html"><![CDATA[<p>在使用Socket来连接服务器时最简单的方式就是直接使用IP和端口，但Socket类中的connect方法并未提供这种方式，而是使用SocketAddress类来向connect方法传递服务器的IP和端口。虽然这种方式从表面上看要麻烦一些，但它会给我们带来另外一个好处，那就是网络地址的重用。<br><a id="more"></a></p><p><strong>所谓网络地址的重用表现在两个方面：</strong></p><ul><li>通过建立一个SocketAddress对象，可以在多次连接同一个服务器时使用这个SocketAddress对象。</li><li>在Socket类中提供了两个方法：getRemoteSocketAddress和getLocalSocketAddress，通过这两个方法可以得到服务器和本机的网络地址。而且所得到的网络地址在相应的Socket对象关闭后任然可以使用。下面是这两个方法的声明：</li><li><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">public SocketAddress getRemoteSocketAddress()</div><div class="line">public SocketAddress getLocalSocketAddress()</div></pre></td></tr></table></figure><p> 不管在使用Socket类连接服务器时是直接使用IP和端口，还是使用SocketAddress，这两个方法都返回SocketAddress形式的网络地址。当Socket对象未连接时这两个方法返回null，但要注意的是只有在Socket对象未连接时这两个方法才返回null，而当已经连接成功的Socket对象关闭后仍可使用这两个方法得到相应的网络地址。<br> 虽然上面曾多次提到SocketAddress，但SocketAddress只是个抽象类，它除了有一个默认的构造方法外，其它的方法都是abstract的，因此，我们必须使用SocketAddress的子类来建立SocketAddress对象。在JDK1.4中J只为我们提供了IP网络地址的实现类：java.net.InetSocketAddress。这个类是从SocketAddress继承的，我们可以通过如下的方法来建立SocketAddress对象。</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">SocketAddress socketAddress = new InetSocketAddress(host, ip);</div></pre></td></tr></table></figure><p>下面的代码演示了如何通过SocketAddress来共享网络地址：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line">package mynet;</div><div class="line"></div><div class="line">import java.net.*;</div><div class="line"></div><div class="line">public class MySocketAddress</div><div class="line">&#123;</div><div class="line">    public static void main(String[] args)</div><div class="line">    &#123;</div><div class="line">        try</div><div class="line">        &#123;</div><div class="line">            Socket socket1 = new Socket(&quot;www.ptpress.com.cn&quot;, 80);</div><div class="line">            SocketAddress socketAddress = socket1.getRemoteSocketAddress();</div><div class="line">            socket1.close();</div><div class="line">            Socket socket2 = new Socket();</div><div class="line">            // socket2.bind(new InetSocketAddress(&quot;192.168.18.252&quot;, 0));</div><div class="line">            socket2.connect(socketAddress);</div><div class="line">            socket2.close();</div><div class="line">            InetSocketAddress inetSocketAddress1 = (InetSocketAddress) socketAddress;</div><div class="line">            System.out.println(&quot;服务器域名:&quot;</div><div class="line">                            + inetSocketAddress1.getAddress().getHostName());</div><div class="line">            System.out.println(&quot;服务器IP:&quot;</div><div class="line">                            + inetSocketAddress1.getAddress().getHostAddress());</div><div class="line">            System.out.println(&quot;服务器端口:&quot; + inetSocketAddress1.getPort());</div><div class="line">            InetSocketAddress inetSocketAddress2 = (InetSocketAddress) socket2</div><div class="line">                            .getLocalSocketAddress();</div><div class="line">            System.out.println(&quot;本地IP:&quot;</div><div class="line">                            + inetSocketAddress2.getAddress().getLocalHost()</div><div class="line">                                            .getHostAddress());</div><div class="line">            System.out.println(&quot;本地端口:&quot; + inetSocketAddress2.getPort());</div><div class="line">        &#125;</div><div class="line">        catch (Exception e)</div><div class="line">        &#123;</div><div class="line">            System.out.println(e.getMessage());</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>输出结果：</p><p>服务器域名:www.ptpress.com.cn<br>服务器IP:219.238.168.74<br>服务器端口:80<br>本地IP:192.168.18.253<br>本地端口:4250</p><p>如果多次运行后，本地端口的值可能在每次都不一样。这是因为在socket2在连接时并未使用bind来绑定本地的端口，而这个本地端口是由系统在1024至65，535中随机选取的，因此，在每次运行程序时这个本地端口不一定相同。</p><p>本文出自 “<a href="http://androidguy.blog.51cto.com/974126/214448" target="_blank" rel="external">李宁的极客世界</a>”博客， <a href="http://androidguy.blog.51cto.com/974126/214448" target="_blank" rel="external">http://androidguy.blog.51cto.com/974126/214448</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在使用Socket来连接服务器时最简单的方式就是直接使用IP和端口，但Socket类中的connect方法并未提供这种方式，而是使用SocketAddress类来向connect方法传递服务器的IP和端口。虽然这种方式从表面上看要麻烦一些，但它会给我们带来另外一个好处，那就是网络地址的重用。&lt;br&gt;
    
    </summary>
    
      <category term="Netty:The Definitive Guide" scheme="http://yoursite.com/categories/Netty-The-Definitive-Guide/"/>
    
    
      <category term="NIO" scheme="http://yoursite.com/tags/NIO/"/>
    
      <category term="Socket" scheme="http://yoursite.com/tags/Socket/"/>
    
  </entry>
  
  <entry>
    <title>JavaBean总结</title>
    <link href="http://yoursite.com/2017/04/01/JavaBean%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2017/04/01/JavaBean总结/</id>
    <published>2017-04-01T01:43:50.000Z</published>
    <updated>2017-10-20T02:05:16.813Z</updated>
    
    <content type="html"><![CDATA[<p>符合一定规范编写的Java类，不是一种技术，而是一种规范。大家针对这种规范，总结了很多开发技巧、工具函数。符合这种规范的类，可以被其它的程序员或者框架使用。</p><a id="more"></a><h4 id="javabean-是什么？"><a href="#javabean-是什么？" class="headerlink" title="javabean 是什么？"></a>javabean 是什么？</h4><p>Bean的中文含义是“豆子”，顾名思义，JavaBean是指一段特殊的Java类，<br>就是有默然构造方法,只有get,set的方法的java类的对象.</p><p>专业点解释是：</p><p>JavaBean定义了一组规则<br>JavaBean就是遵循此规则的平常的Java对象 </p><p>满足这三个条件:<br>1.实现序列化接口<br>2.提供无参数的构造器<br>3.提供getter 和 setter方法访问它的属性.</p><p>简单地说，JavaBean是用Java语言描述的软件组件模型，其实际上是一个类。这些类遵循一个接口格式，以便于使函数命名、底层行为以及继承或实现的行为，可以把类看作标准的JavaBean组件进行构造和应用。<br>JavaBean一般分为可视化组件和非可视化组件两种。可视化组件可以是简单的GUI元素，如按钮或文本框，也可以是复杂的，如报表组件；非可视化组件没有GUI表现形式，用于封装业务逻辑、数据库操作等。其最大的优点在于可以实现代码的可重用性。JavaBean又同时具有以下特性。</p><ul><li>易于维护、使用、编写。</li><li>可实现代码的重用性。</li><li>可移植性强，但仅限于Java工作平台。</li><li>便于传输，不限于本地还是网络。</li><li>可以以其他部件的模式进行工作。</li></ul><p>对于有过其他语言编程经验的读者，可以将其看作类似微软的ActiveX的编程组件。但是区别在于JavaBean是跨平台的，而ActiveX组件则仅局限于Windows系统。总之，JavaBean比较适合于那些需要跨平台的、并具有可视化操作和定制特性的软件组件。</p><p>JavaBean组件与EJB（Enterprise JavaBean，企业级JavaBean）组件完全不同。EJB 是J2EE的核心，是一个用来创建分布式应用、服务器端以及基于Java应用的功能强大的组件模型。JavaBean组件主要用于存储状态信息，而EJB组件可以存储业务逻辑。</p><h4 id="使用JavaBean的原因"><a href="#使用JavaBean的原因" class="headerlink" title="使用JavaBean的原因"></a>使用JavaBean的原因</h4><p>程序中往往有重复使用的段落，JavaBean就是为了能够重复使用而设计的程序段落，而且这些段落并不只服务于某一个程序，而且每个JavaBean都具有特定功能，当需要这个功能的时候就可以调用相应的JavaBean。从这个意义上来讲，JavaBean大大简化了程序的设计过程，也方便了其他程序的重复使用。<br>JavaBean传统应用于可视化领域，如AWT（窗口工具集）下的应用。而现在，JavaBean更多地应用于非可视化领域，同时，JavaBean在服务器端的应用也表现出强大的优势。非可视化的JavaBean可以很好地实现业务逻辑、控制逻辑和显示页面的分离，现在多用于后台处理，使得系统具有更好的健壮性和灵活性。JSP + JavaBean和JSP + JavaBean + Servlet成为当前开发Web应用的主流模式。</p><h4 id="JavaBean的开发"><a href="#JavaBean的开发" class="headerlink" title="JavaBean的开发"></a>JavaBean的开发</h4><p>在程序设计的过程中，JavaBean不是独立的。为了能够更好地封装事务逻辑、数据库操作而便于实现业务逻辑和前台程序的分离，操作的过程往往是先开发需要的JavaBean，再在适当的时候进行调用。但一个完整有效的JavaBean必然会包含一个属性，伴随若干个get/set（只读/只写）函数的变量来设计和运行的。JavaBean作为一个特殊的类，具有自己独有的特性。应该注意以下3个方面。</p><ul><li>JavaBean类必须有一个没有参数的构造函数。</li><li>JavaBean类所有的属性最好定义为私有的。</li><li>JavaBean类中定义函数setXxx() 和getXxx()来对属性进行操作。其中Xxx是首字母大写的私有变量名称。</li></ul><p>转载于：<a href="http://blog.csdn.net/zdwzzu2006/article/details/5151788/" target="_blank" rel="external">http://blog.csdn.net/zdwzzu2006/article/details/5151788/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;符合一定规范编写的Java类，不是一种技术，而是一种规范。大家针对这种规范，总结了很多开发技巧、工具函数。符合这种规范的类，可以被其它的程序员或者框架使用。&lt;/p&gt;
    
    </summary>
    
      <category term="The Basic Of Java" scheme="http://yoursite.com/categories/The-Basic-Of-Java/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Spring中每个jar包的作用</title>
    <link href="http://yoursite.com/2017/03/10/Spring%E4%B8%AD%E6%AF%8F%E4%B8%AAjar%E5%8C%85%E7%9A%84%E4%BD%9C%E7%94%A8/"/>
    <id>http://yoursite.com/2017/03/10/Spring中每个jar包的作用/</id>
    <published>2017-03-10T01:43:50.000Z</published>
    <updated>2017-09-28T07:58:54.882Z</updated>
    
    <content type="html"><![CDATA[<p>一个工程需要很多个关于spring的jar包，下面详细说明每个jar的作用。</p><a id="more"></a><p><strong>spring.jar</strong><br>包含有完整发布模块的单个jar 包。但是不包括mock.jar, aspects.jar, spring-portlet.jar, and spring-hibernate2.jar。</p><p><strong>spring-src.zip就是所有的源代码压缩包。</strong></p><p>除了spring.jar 文件，Spring 还包括有其它21 个独立的jar 包，各自包含着对应的Spring组件，用户可以根据自己的需要来选择组合自己的jar 包，而不必引入整个spring.jar 的所有类文件。</p><h4 id="spring-core-jar"><a href="#spring-core-jar" class="headerlink" title="spring-core.jar"></a>spring-core.jar</h4><p>这个jar 文件包含Spring 框架基本的核心工具类。Spring 其它组件要都要使用到这个包里的类，是其它组件的基本核心，当然你也可以在自己的应用系统中使用这些工具类。<br>外部依赖Commons Logging， (Log4J)。</p><h4 id="spring-beans-jar"><a href="#spring-beans-jar" class="headerlink" title="spring-beans.jar"></a>spring-beans.jar</h4><p>这个jar 文件是所有应用都要用到的，它包含访问配置文件、创建和管理bean 以及进行Inversion of Control / Dependency Injection（IoC/DI）操作相关的所有类。如果应用只需基本的IoC/DI 支持，引入spring-core.jar 及spring-beans.jar 文件就可以了。<br>外部依赖spring-core，(CGLIB)。</p><h4 id="spring-aop-jar"><a href="#spring-aop-jar" class="headerlink" title="spring-aop.jar"></a>spring-aop.jar</h4><p>这个jar 文件包含在应用中使用Spring 的AOP 特性时所需的类和源码级元数据支持。使用基于AOP 的Spring特性，如声明型事务管理（Declarative Transaction Management），也要在应用里包含这个jar包。<br>外部依赖spring-core， (spring-beans，AOP Alliance， CGLIB，Commons Attributes)。</p><h4 id="spring-context-jar"><a href="#spring-context-jar" class="headerlink" title="spring-context.jar"></a>spring-context.jar</h4><p>这个jar 文件为Spring 核心提供了大量扩展。可以找到使用Spring ApplicationContext特性时所需的全部类，JDNI 所需的全部类，instrumentation组件以及校验Validation 方面的相关类。<br>外部依赖spring-beans, (spring-aop)。</p><h4 id="spring-dao-jar"><a href="#spring-dao-jar" class="headerlink" title="spring-dao.jar"></a>spring-dao.jar</h4><p>这个jar 文件包含Spring DAO、Spring Transaction 进行数据访问的所有类。为了使用声明型事务支持，还需在自己的应用里包含spring-aop.jar。<br>外部依赖spring-core，(spring-aop， spring-context， JTA API)。</p><h4 id="spring-jdbc-jar"><a href="#spring-jdbc-jar" class="headerlink" title="spring-jdbc.jar"></a>spring-jdbc.jar</h4><p>这个jar 文件包含对Spring 对JDBC 数据访问进行封装的所有类。<br>外部依赖spring-beans，spring-dao。</p><h4 id="spring-support-jar"><a href="#spring-support-jar" class="headerlink" title="spring-support.jar"></a>spring-support.jar</h4><p>这个jar 文件包含支持UI模版（Velocity，FreeMarker，JasperReports），邮件服务，脚本服务(JRuby)，缓存Cache（EHCache），任务计划Scheduling（uartz）方面的类。<br>外部依赖spring-context, (spring-jdbc, Velocity, FreeMarker, JasperReports, BSH, Groovy, JRuby, Quartz, EHCache)</p><h4 id="spring-web-jar"><a href="#spring-web-jar" class="headerlink" title="spring-web.jar"></a>spring-web.jar</h4><p>这个jar 文件包含Web 应用开发时，用到Spring 框架时所需的核心类，包括自动载入Web Application Context 特性的类、Struts 与JSF 集成类、文件上传的支持类、Filter 类和大量工具辅助类。<br>外部依赖spring-context, Servlet API, (JSP API, JSTL, Commons FileUpload, COS)。</p><h4 id="spring-webmvc-jar"><a href="#spring-webmvc-jar" class="headerlink" title="spring-webmvc.jar"></a>spring-webmvc.jar</h4><p>这个jar 文件包含Spring MVC 框架相关的所有类。包括框架的Servlets，Web MVC框架，控制器和视图支持。当然，如果你的应用使用了独立的MVC 框架，则无需这个JAR 文件里的任何类。<br>外部依赖spring-web, (spring-support，Tiles，iText，POI)。</p><h4 id="spring-portlet-jar"><a href="#spring-portlet-jar" class="headerlink" title="spring-portlet.jar"></a>spring-portlet.jar</h4><p>spring自己实现的一个类似Spring MVC的框架。包括一个MVC框架和控制器。<br>外部依赖spring-web， Portlet API，(spring-webmvc)。</p><h4 id="spring-struts-jar"><a href="#spring-struts-jar" class="headerlink" title="spring-struts.jar"></a>spring-struts.jar</h4><p>Struts框架支持，可以更方便更容易的集成Struts框架。<br>外部依赖spring-web，Struts。</p><h4 id="spring-remoting-jar"><a href="#spring-remoting-jar" class="headerlink" title="spring-remoting.jar"></a>spring-remoting.jar</h4><p>这个jar 文件包含支持EJB、远程调用Remoting（RMI、Hessian、Burlap、Http Invoker、JAX-RPC）方面的类。<br>外部依赖spring-aop， (spring-context，spring-web，Hessian，Burlap，JAX-RPC，EJB API)。</p><h4 id="spring-jmx-jar"><a href="#spring-jmx-jar" class="headerlink" title="spring-jmx.jar"></a>spring-jmx.jar</h4><p>这个jar包提供了对JMX 1.0/1.2的支持类。<br>外部依赖spring-beans，spring-aop， JMX API。</p><h4 id="spring-jms-jar"><a href="#spring-jms-jar" class="headerlink" title="spring-jms.jar"></a>spring-jms.jar</h4><p>这个jar包提供了对JMS 1.0.2/1.1的支持类。<br>外部依赖spring-beans，spring-dao，JMS API。</p><h4 id="spring-jca-jar"><a href="#spring-jca-jar" class="headerlink" title="spring-jca.jar"></a>spring-jca.jar</h4><p>对JCA 1.0的支持。<br>外部依赖spring-beans，spring-dao， JCA API。</p><h4 id="spring-jdo-jar"><a href="#spring-jdo-jar" class="headerlink" title="spring-jdo.jar"></a>spring-jdo.jar</h4><p>对JDO 1.0/2.0的支持。<br>外部依赖spring-jdbc， JDO API， (spring-web)。</p><h4 id="spring-jpa-jar"><a href="#spring-jpa-jar" class="headerlink" title="spring-jpa.jar"></a>spring-jpa.jar</h4><p>对JPA 1.0的支持。<br>外部依赖spring-jdbc， JPA API， (spring-web)。</p><h4 id="spring-hibernate2-jar"><a href="#spring-hibernate2-jar" class="headerlink" title="spring-hibernate2.jar"></a>spring-hibernate2.jar</h4><p>对Hibernate 2.1的支持，已经不建议使用。<br>外部依赖spring-jdbc，Hibernate2，(spring-web)。</p><h4 id="spring-hibernate3-jar"><a href="#spring-hibernate3-jar" class="headerlink" title="spring-hibernate3.jar"></a>spring-hibernate3.jar</h4><p>对Hibernate 3.0/3.1/3.2的支持。<br>外部依赖spring-jdbc，Hibernate3，(spring-web)。</p><h4 id="spring-toplink-jar"><a href="#spring-toplink-jar" class="headerlink" title="spring-toplink.jar"></a>spring-toplink.jar</h4><p>对TopLink框架的支持。<br>外部依赖spring-jdbc，TopLink。</p><h4 id="spring-ibatis-jar"><a href="#spring-ibatis-jar" class="headerlink" title="spring-ibatis.jar"></a>spring-ibatis.jar</h4><p>对iBATIS SQL Maps的支持。<br>外部依赖spring-jdbc，iBATIS SQL Maps。</p><p>另外的两个包。</p><h4 id="spring-mock-jar"><a href="#spring-mock-jar" class="headerlink" title="spring-mock.jar"></a>spring-mock.jar</h4><p>这个jar 文件包含Spring 一整套mock 类来辅助应用的测试。Spring 测试套件使用了其中大量mock 类，这样测试就更加简单。模拟HttpServletRequest 和HttpServletResponse 类在Web 应用单元测试是很方便的。并且提供了对JUnit的支持。<br>外部依赖spring-core。</p><h4 id="spring-aspects-jar"><a href="#spring-aspects-jar" class="headerlink" title="spring-aspects.jar"></a>spring-aspects.jar</h4><p>提供对AspectJ的支持，以便可以方便的将面向方面的功能集成进IDE中，比如Eclipse AJDT。<br>外部依赖。</p><p>WEAVER JARS (dist/weavers)说明。</p><h4 id="spring-agent-jar"><a href="#spring-agent-jar" class="headerlink" title="spring-agent.jar"></a>spring-agent.jar</h4><p>Spring的InstrumentationSavingAgent (为InstrumentationLoadTimeWeaver)，一个设备代理包，可以参考JDK1.5的Instrumentation功能获得更多信息。<br>外部依赖none (for use at JVM startup: “-javaagent:spring-agent.jar”)。</p><h4 id="spring-tomcat-weaver-jar"><a href="#spring-tomcat-weaver-jar" class="headerlink" title="spring-tomcat-weaver.jar"></a>spring-tomcat-weaver.jar</h4><p>扩展Tomcat的ClassLoader，使其可以使用instrumentation（设备）类。<br>外部依赖none (for deployment into Tomcat’s “server/lib” directory)。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一个工程需要很多个关于spring的jar包，下面详细说明每个jar的作用。&lt;/p&gt;
    
    </summary>
    
      <category term="Spring" scheme="http://yoursite.com/categories/Spring/"/>
    
    
      <category term="Spring" scheme="http://yoursite.com/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>Maven中pom标签详解</title>
    <link href="http://yoursite.com/2017/03/08/Maven%E4%B8%ADpom%E6%A0%87%E7%AD%BE%E8%AF%A6%E8%A7%A3/"/>
    <id>http://yoursite.com/2017/03/08/Maven中pom标签详解/</id>
    <published>2017-03-08T15:02:25.000Z</published>
    <updated>2017-09-28T06:46:28.515Z</updated>
    
    <content type="html"><![CDATA[<p> pom作为项目对象模型。通过xml表示maven项目，使用pom.xml来实现。主要描述了项目：包括配置文件；开发者需要遵循的规则，缺陷管理系统，组织和licenses，项目的url，项目的依赖性，以及其他所有的项目相关因素。<br><a id="more"></a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div><div class="line">178</div><div class="line">179</div><div class="line">180</div><div class="line">181</div><div class="line">182</div><div class="line">183</div><div class="line">184</div><div class="line">185</div><div class="line">186</div><div class="line">187</div><div class="line">188</div><div class="line">189</div><div class="line">190</div><div class="line">191</div><div class="line">192</div><div class="line">193</div><div class="line">194</div><div class="line">195</div><div class="line">196</div><div class="line">197</div><div class="line">198</div><div class="line">199</div><div class="line">200</div><div class="line">201</div><div class="line">202</div><div class="line">203</div><div class="line">204</div><div class="line">205</div><div class="line">206</div><div class="line">207</div><div class="line">208</div><div class="line">209</div><div class="line">210</div><div class="line">211</div><div class="line">212</div><div class="line">213</div><div class="line">214</div><div class="line">215</div><div class="line">216</div><div class="line">217</div><div class="line">218</div><div class="line">219</div><div class="line">220</div><div class="line">221</div><div class="line">222</div><div class="line">223</div><div class="line">224</div><div class="line">225</div><div class="line">226</div><div class="line">227</div><div class="line">228</div><div class="line">229</div><div class="line">230</div><div class="line">231</div><div class="line">232</div><div class="line">233</div><div class="line">234</div><div class="line">235</div><div class="line">236</div><div class="line">237</div><div class="line">238</div><div class="line">239</div><div class="line">240</div><div class="line">241</div><div class="line">242</div><div class="line">243</div><div class="line">244</div><div class="line">245</div><div class="line">246</div><div class="line">247</div><div class="line">248</div><div class="line">249</div><div class="line">250</div><div class="line">251</div><div class="line">252</div><div class="line">253</div><div class="line">254</div><div class="line">255</div><div class="line">256</div><div class="line">257</div><div class="line">258</div><div class="line">259</div><div class="line">260</div><div class="line">261</div><div class="line">262</div><div class="line">263</div><div class="line">264</div><div class="line">265</div><div class="line">266</div><div class="line">267</div><div class="line">268</div><div class="line">269</div><div class="line">270</div><div class="line">271</div><div class="line">272</div><div class="line">273</div><div class="line">274</div><div class="line">275</div><div class="line">276</div><div class="line">277</div><div class="line">278</div><div class="line">279</div><div class="line">280</div><div class="line">281</div><div class="line">282</div><div class="line">283</div><div class="line">284</div><div class="line">285</div><div class="line">286</div><div class="line">287</div><div class="line">288</div><div class="line">289</div><div class="line">290</div><div class="line">291</div><div class="line">292</div><div class="line">293</div><div class="line">294</div><div class="line">295</div><div class="line">296</div><div class="line">297</div><div class="line">298</div><div class="line">299</div><div class="line">300</div><div class="line">301</div><div class="line">302</div><div class="line">303</div><div class="line">304</div><div class="line">305</div><div class="line">306</div><div class="line">307</div><div class="line">308</div><div class="line">309</div><div class="line">310</div><div class="line">311</div><div class="line">312</div><div class="line">313</div><div class="line">314</div><div class="line">315</div><div class="line">316</div><div class="line">317</div><div class="line">318</div><div class="line">319</div><div class="line">320</div><div class="line">321</div><div class="line">322</div><div class="line">323</div><div class="line">324</div><div class="line">325</div><div class="line">326</div><div class="line">327</div><div class="line">328</div><div class="line">329</div><div class="line">330</div><div class="line">331</div><div class="line">332</div><div class="line">333</div><div class="line">334</div><div class="line">335</div><div class="line">336</div><div class="line">337</div><div class="line">338</div><div class="line">339</div><div class="line">340</div><div class="line">341</div><div class="line">342</div><div class="line">343</div><div class="line">344</div><div class="line">345</div><div class="line">346</div><div class="line">347</div><div class="line">348</div><div class="line">349</div><div class="line">350</div><div class="line">351</div><div class="line">352</div><div class="line">353</div><div class="line">354</div><div class="line">355</div><div class="line">356</div><div class="line">357</div><div class="line">358</div><div class="line">359</div><div class="line">360</div><div class="line">361</div><div class="line">362</div><div class="line">363</div><div class="line">364</div><div class="line">365</div><div class="line">366</div><div class="line">367</div><div class="line">368</div><div class="line">369</div><div class="line">370</div><div class="line">371</div><div class="line">372</div><div class="line">373</div><div class="line">374</div><div class="line">375</div><div class="line">376</div><div class="line">377</div><div class="line">378</div><div class="line">379</div><div class="line">380</div><div class="line">381</div><div class="line">382</div><div class="line">383</div><div class="line">384</div><div class="line">385</div><div class="line">386</div><div class="line">387</div><div class="line">388</div><div class="line">389</div><div class="line">390</div><div class="line">391</div><div class="line">392</div><div class="line">393</div><div class="line">394</div><div class="line">395</div><div class="line">396</div><div class="line">397</div><div class="line">398</div><div class="line">399</div><div class="line">400</div><div class="line">401</div><div class="line">402</div><div class="line">403</div><div class="line">404</div><div class="line">405</div><div class="line">406</div><div class="line">407</div><div class="line">408</div><div class="line">409</div><div class="line">410</div><div class="line">411</div><div class="line">412</div><div class="line">413</div><div class="line">414</div><div class="line">415</div><div class="line">416</div><div class="line">417</div><div class="line">418</div><div class="line">419</div><div class="line">420</div><div class="line">421</div><div class="line">422</div><div class="line">423</div><div class="line">424</div><div class="line">425</div><div class="line">426</div><div class="line">427</div><div class="line">428</div><div class="line">429</div><div class="line">430</div><div class="line">431</div><div class="line">432</div><div class="line">433</div><div class="line">434</div><div class="line">435</div><div class="line">436</div><div class="line">437</div><div class="line">438</div><div class="line">439</div><div class="line">440</div><div class="line">441</div><div class="line">442</div><div class="line">443</div><div class="line">444</div><div class="line">445</div><div class="line">446</div><div class="line">447</div><div class="line">448</div><div class="line">449</div><div class="line">450</div><div class="line">451</div><div class="line">452</div><div class="line">453</div><div class="line">454</div><div class="line">455</div><div class="line">456</div><div class="line">457</div><div class="line">458</div><div class="line">459</div><div class="line">460</div><div class="line">461</div><div class="line">462</div><div class="line">463</div><div class="line">464</div><div class="line">465</div><div class="line">466</div><div class="line">467</div><div class="line">468</div><div class="line">469</div><div class="line">470</div><div class="line">471</div><div class="line">472</div><div class="line">473</div><div class="line">474</div><div class="line">475</div><div class="line">476</div><div class="line">477</div><div class="line">478</div><div class="line">479</div><div class="line">480</div><div class="line">481</div><div class="line">482</div><div class="line">483</div><div class="line">484</div><div class="line">485</div><div class="line">486</div><div class="line">487</div><div class="line">488</div><div class="line">489</div><div class="line">490</div><div class="line">491</div><div class="line">492</div><div class="line">493</div><div class="line">494</div><div class="line">495</div><div class="line">496</div><div class="line">497</div><div class="line">498</div><div class="line">499</div><div class="line">500</div><div class="line">501</div><div class="line">502</div><div class="line">503</div><div class="line">504</div><div class="line">505</div><div class="line">506</div><div class="line">507</div><div class="line">508</div><div class="line">509</div><div class="line">510</div><div class="line">511</div><div class="line">512</div><div class="line">513</div><div class="line">514</div><div class="line">515</div><div class="line">516</div><div class="line">517</div><div class="line">518</div><div class="line">519</div><div class="line">520</div><div class="line">521</div><div class="line">522</div><div class="line">523</div><div class="line">524</div><div class="line">525</div><div class="line">526</div><div class="line">527</div><div class="line">528</div><div class="line">529</div><div class="line">530</div><div class="line">531</div><div class="line">532</div><div class="line">533</div><div class="line">534</div><div class="line">535</div><div class="line">536</div><div class="line">537</div><div class="line">538</div><div class="line">539</div><div class="line">540</div><div class="line">541</div><div class="line">542</div><div class="line">543</div><div class="line">544</div><div class="line">545</div><div class="line">546</div><div class="line">547</div><div class="line">548</div><div class="line">549</div><div class="line">550</div><div class="line">551</div><div class="line">552</div><div class="line">553</div><div class="line">554</div><div class="line">555</div><div class="line">556</div><div class="line">557</div><div class="line">558</div><div class="line">559</div><div class="line">560</div><div class="line">561</div><div class="line">562</div><div class="line">563</div><div class="line">564</div><div class="line">565</div><div class="line">566</div><div class="line">567</div><div class="line">568</div><div class="line">569</div><div class="line">570</div><div class="line">571</div><div class="line">572</div><div class="line">573</div><div class="line">574</div><div class="line">575</div><div class="line">576</div><div class="line">577</div><div class="line">578</div><div class="line">579</div><div class="line">580</div><div class="line">581</div><div class="line">582</div><div class="line">583</div><div class="line">584</div><div class="line">585</div><div class="line">586</div><div class="line">587</div><div class="line">588</div><div class="line">589</div><div class="line">590</div><div class="line">591</div><div class="line">592</div><div class="line">593</div><div class="line">594</div><div class="line">595</div><div class="line">596</div><div class="line">597</div><div class="line">598</div><div class="line">599</div><div class="line">600</div><div class="line">601</div></pre></td><td class="code"><pre><div class="line">&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;     </div><div class="line">    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;     </div><div class="line">xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0http://maven.apache.org/maven-v4_0_0.xsd&quot;&gt;     </div><div class="line">    &lt;!--父项目的坐标。如果项目中没有规定某个元素的值，那么父项目中的对应值即为项目的默认值。 坐标包括group ID，artifact ID和 version。--&gt;    </div><div class="line">    &lt;parent&gt;    </div><div class="line">     &lt;!--被继承的父项目的构件标识符--&gt;    </div><div class="line">     &lt;artifactId/&gt;    </div><div class="line">     &lt;!--被继承的父项目的全球唯一标识符--&gt;    </div><div class="line">     &lt;groupId/&gt;    </div><div class="line">     &lt;!--被继承的父项目的版本--&gt;    </div><div class="line">     &lt;version/&gt;    </div><div class="line">     &lt;!-- 父项目的pom.xml文件的相对路径。相对路径允许你选择一个不同的路径。默认值是../pom.xml。Maven首先在构建当前项目的地方寻找父项 目的pom，其次在文件系统的这个位置（relativePath位置），然后在本地仓库，最后在远程仓库寻找父项目的pom。--&gt;    </div><div class="line">     &lt;relativePath/&gt;    </div><div class="line"> &lt;/parent&gt;    </div><div class="line"> &lt;!--声明项目描述符遵循哪一个POM模型版本。模型本身的版本很少改变，虽然如此，但它仍然是必不可少的，这是为了当Maven引入了新的特性或者其他模型变更的时候，确保稳定性。--&gt;       </div><div class="line">    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;     </div><div class="line">    &lt;!--项目的全球唯一标识符，通常使用全限定的包名区分该项目和其他项目。并且构建时生成的路径也是由此生成， 如com.mycompany.app生成的相对路径为：/com/mycompany/app--&gt;     </div><div class="line">    &lt;groupId&gt;asia.banseon&lt;/groupId&gt;     </div><div class="line">    &lt;!-- 构件的标识符，它和group ID一起唯一标识一个构件。换句话说，你不能有两个不同的项目拥有同样的artifact ID和groupID；在某个 特定的group ID下，artifact ID也必须是唯一的。构件是项目产生的或使用的一个东西，Maven为项目产生的构件包括：JARs，源 码，二进制发布和WARs等。--&gt;     </div><div class="line">    &lt;artifactId&gt;banseon-maven2&lt;/artifactId&gt;     </div><div class="line">    &lt;!--项目产生的构件类型，例如jar、war、ear、pom。插件可以创建他们自己的构件类型，所以前面列的不是全部构件类型--&gt;     </div><div class="line">    &lt;packaging&gt;jar&lt;/packaging&gt;     </div><div class="line">    &lt;!--项目当前版本，格式为:主版本.次版本.增量版本-限定版本号--&gt;     </div><div class="line">    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;     </div><div class="line">    &lt;!--项目的名称, Maven产生的文档用--&gt;     </div><div class="line">    &lt;name&gt;banseon-maven&lt;/name&gt;     </div><div class="line">    &lt;!--项目主页的URL, Maven产生的文档用--&gt;     </div><div class="line">    &lt;url&gt;http://www.baidu.com/banseon&lt;/url&gt;     </div><div class="line">    &lt;!-- 项目的详细描述, Maven 产生的文档用。  当这个元素能够用HTML格式描述时（例如，CDATA中的文本会被解析器忽略，就可以包含HTML标 签）， 不鼓励使用纯文本描述。如果你需要修改产生的web站点的索引页面，你应该修改你自己的索引页文件，而不是调整这里的文档。--&gt;     </div><div class="line">    &lt;description&gt;A maven project to study maven.&lt;/description&gt;     </div><div class="line">    &lt;!--描述了这个项目构建环境中的前提条件。--&gt;    </div><div class="line"> &lt;prerequisites&gt;    </div><div class="line">  &lt;!--构建该项目或使用该插件所需要的Maven的最低版本--&gt;    </div><div class="line">    &lt;maven/&gt;    </div><div class="line"> &lt;/prerequisites&gt;    </div><div class="line"> &lt;!--项目的问题管理系统(Bugzilla, Jira, Scarab,或任何你喜欢的问题管理系统)的名称和URL，本例为 jira--&gt;     </div><div class="line">    &lt;issueManagement&gt;    </div><div class="line">     &lt;!--问题管理系统（例如jira）的名字，--&gt;     </div><div class="line">        &lt;system&gt;jira&lt;/system&gt;     </div><div class="line">        &lt;!--该项目使用的问题管理系统的URL--&gt;    </div><div class="line">        &lt;url&gt;http://jira.baidu.com/banseon&lt;/url&gt;     </div><div class="line">    &lt;/issueManagement&gt;     </div><div class="line">    &lt;!--项目持续集成信息--&gt;    </div><div class="line"> &lt;ciManagement&gt;    </div><div class="line">  &lt;!--持续集成系统的名字，例如continuum--&gt;    </div><div class="line">  &lt;system/&gt;    </div><div class="line">  &lt;!--该项目使用的持续集成系统的URL（如果持续集成系统有web接口的话）。--&gt;    </div><div class="line">  &lt;url/&gt;    </div><div class="line">  &lt;!--构建完成时，需要通知的开发者/用户的配置项。包括被通知者信息和通知条件（错误，失败，成功，警告）--&gt;    </div><div class="line">  &lt;notifiers&gt;    </div><div class="line">   &lt;!--配置一种方式，当构建中断时，以该方式通知用户/开发者--&gt;    </div><div class="line">   &lt;notifier&gt;    </div><div class="line">    &lt;!--传送通知的途径--&gt;    </div><div class="line">    &lt;type/&gt;    </div><div class="line">    &lt;!--发生错误时是否通知--&gt;    </div><div class="line">    &lt;sendOnError/&gt;    </div><div class="line">    &lt;!--构建失败时是否通知--&gt;    </div><div class="line">    &lt;sendOnFailure/&gt;    </div><div class="line">    &lt;!--构建成功时是否通知--&gt;    </div><div class="line">    &lt;sendOnSuccess/&gt;    </div><div class="line">    &lt;!--发生警告时是否通知--&gt;    </div><div class="line">    &lt;sendOnWarning/&gt;    </div><div class="line">    &lt;!--不赞成使用。通知发送到哪里--&gt;    </div><div class="line">    &lt;address/&gt;    </div><div class="line">    &lt;!--扩展配置项--&gt;    </div><div class="line">    &lt;configuration/&gt;    </div><div class="line">   &lt;/notifier&gt;    </div><div class="line">  &lt;/notifiers&gt;    </div><div class="line"> &lt;/ciManagement&gt;    </div><div class="line"> &lt;!--项目创建年份，4位数字。当产生版权信息时需要使用这个值。--&gt;    </div><div class="line">    &lt;inceptionYear/&gt;    </div><div class="line">    &lt;!--项目相关邮件列表信息--&gt;     </div><div class="line">    &lt;mailingLists&gt;    </div><div class="line">     &lt;!--该元素描述了项目相关的所有邮件列表。自动产生的网站引用这些信息。--&gt;     </div><div class="line">        &lt;mailingList&gt;     </div><div class="line">         &lt;!--邮件的名称--&gt;    </div><div class="line">            &lt;name&gt;Demo&lt;/name&gt;     </div><div class="line">            &lt;!--发送邮件的地址或链接，如果是邮件地址，创建文档时，mailto: 链接会被自动创建--&gt;     </div><div class="line">            &lt;post&gt;banseon@126.com&lt;/post&gt;     </div><div class="line">            &lt;!--订阅邮件的地址或链接，如果是邮件地址，创建文档时，mailto: 链接会被自动创建--&gt;     </div><div class="line">            &lt;subscribe&gt;banseon@126.com&lt;/subscribe&gt;     </div><div class="line">            &lt;!--取消订阅邮件的地址或链接，如果是邮件地址，创建文档时，mailto: 链接会被自动创建--&gt;     </div><div class="line">            &lt;unsubscribe&gt;banseon@126.com&lt;/unsubscribe&gt;     </div><div class="line">            &lt;!--你可以浏览邮件信息的URL--&gt;    </div><div class="line">            &lt;archive&gt;http:/hi.baidu.com/banseon/demo/dev/&lt;/archive&gt;     </div><div class="line">        &lt;/mailingList&gt;     </div><div class="line">    &lt;/mailingLists&gt;     </div><div class="line">    &lt;!--项目开发者列表--&gt;     </div><div class="line">    &lt;developers&gt;     </div><div class="line">     &lt;!--某个项目开发者的信息--&gt;    </div><div class="line">        &lt;developer&gt;     </div><div class="line">         &lt;!--SCM里项目开发者的唯一标识符--&gt;    </div><div class="line">            &lt;id&gt;HELLO WORLD&lt;/id&gt;     </div><div class="line">            &lt;!--项目开发者的全名--&gt;    </div><div class="line">            &lt;name&gt;banseon&lt;/name&gt;     </div><div class="line">            &lt;!--项目开发者的email--&gt;    </div><div class="line">            &lt;email&gt;banseon@126.com&lt;/email&gt;     </div><div class="line">            &lt;!--项目开发者的主页的URL--&gt;    </div><div class="line">            &lt;url/&gt;    </div><div class="line">            &lt;!--项目开发者在项目中扮演的角色，角色元素描述了各种角色--&gt;    </div><div class="line">            &lt;roles&gt;     </div><div class="line">                &lt;role&gt;Project Manager&lt;/role&gt;     </div><div class="line">                &lt;role&gt;Architect&lt;/role&gt;     </div><div class="line">            &lt;/roles&gt;    </div><div class="line">            &lt;!--项目开发者所属组织--&gt;    </div><div class="line">            &lt;organization&gt;demo&lt;/organization&gt;     </div><div class="line">            &lt;!--项目开发者所属组织的URL--&gt;    </div><div class="line">            &lt;organizationUrl&gt;http://hi.baidu.com/banseon&lt;/organizationUrl&gt;     </div><div class="line">            &lt;!--项目开发者属性，如即时消息如何处理等--&gt;    </div><div class="line">            &lt;properties&gt;     </div><div class="line">                &lt;dept&gt;No&lt;/dept&gt;     </div><div class="line">            &lt;/properties&gt;    </div><div class="line">            &lt;!--项目开发者所在时区， -11到12范围内的整数。--&gt;    </div><div class="line">            &lt;timezone&gt;-5&lt;/timezone&gt;     </div><div class="line">        &lt;/developer&gt;     </div><div class="line">    &lt;/developers&gt;     </div><div class="line">    &lt;!--项目的其他贡献者列表--&gt;     </div><div class="line">    &lt;contributors&gt;    </div><div class="line">     &lt;!--项目的其他贡献者。参见developers/developer元素--&gt;    </div><div class="line">     &lt;contributor&gt;    </div><div class="line">   &lt;name/&gt;&lt;email/&gt;&lt;url/&gt;&lt;organization/&gt;&lt;organizationUrl/&gt;&lt;roles/&gt;&lt;timezone/&gt;&lt;properties/&gt;    </div><div class="line">     &lt;/contributor&gt;         </div><div class="line">    &lt;/contributors&gt;       </div><div class="line">    &lt;!--该元素描述了项目所有License列表。 应该只列出该项目的license列表，不要列出依赖项目的 license列表。如果列出多个license，用户可以选择它们中的一个而不是接受所有license。--&gt;     </div><div class="line">    &lt;licenses&gt;    </div><div class="line">     &lt;!--描述了项目的license，用于生成项目的web站点的license页面，其他一些报表和validation也会用到该元素。--&gt;     </div><div class="line">        &lt;license&gt;    </div><div class="line">         &lt;!--license用于法律上的名称--&gt;    </div><div class="line">            &lt;name&gt;Apache 2&lt;/name&gt;     </div><div class="line">            &lt;!--官方的license正文页面的URL--&gt;    </div><div class="line">            &lt;url&gt;http://www.baidu.com/banseon/LICENSE-2.0.txt&lt;/url&gt;     </div><div class="line">            &lt;!--项目分发的主要方式：    </div><div class="line">              repo，可以从Maven库下载    </div><div class="line">              manual， 用户必须手动下载和安装依赖--&gt;    </div><div class="line">            &lt;distribution&gt;repo&lt;/distribution&gt;     </div><div class="line">            &lt;!--关于license的补充信息--&gt;    </div><div class="line">            &lt;comments&gt;A business-friendly OSS license&lt;/comments&gt;</div><div class="line">        &lt;/license&gt;     </div><div class="line">    &lt;/licenses&gt;     </div><div class="line">    &lt;!--SCM(Source Control Management)标签允许你配置你的代码库，供Maven web站点和其它插件使用。--&gt;     </div><div class="line">    &lt;scm&gt;     </div><div class="line">        &lt;!--SCM的URL,该URL描述了版本库和如何连接到版本库。欲知详情，请看SCMs提供的URL格式和列表。该连接只读。--&gt;     </div><div class="line">        &lt;connection&gt;     </div><div class="line">            scm:svn:http://svn.baidu.com/banseon/maven/banseon/banseon-maven2-trunk(dao-trunk)      </div><div class="line">        &lt;/connection&gt;     </div><div class="line">        &lt;!--给开发者使用的，类似connection元素。即该连接不仅仅只读--&gt;    </div><div class="line">        &lt;developerConnection&gt;     </div><div class="line">            scm:svn:http://svn.baidu.com/banseon/maven/banseon/dao-trunk      </div><div class="line">        &lt;/developerConnection&gt;    </div><div class="line">        &lt;!--当前代码的标签，在开发阶段默认为HEAD--&gt;    </div><div class="line">        &lt;tag/&gt;           </div><div class="line">        &lt;!--指向项目的可浏览SCM库（例如ViewVC或者Fisheye）的URL。--&gt;     </div><div class="line">        &lt;url&gt;http://svn.baidu.com/banseon&lt;/url&gt;     </div><div class="line">    &lt;/scm&gt;     </div><div class="line">    &lt;!--描述项目所属组织的各种属性。Maven产生的文档用--&gt;     </div><div class="line">    &lt;organization&gt;     </div><div class="line">     &lt;!--组织的全名--&gt;    </div><div class="line">        &lt;name&gt;demo&lt;/name&gt;     </div><div class="line">        &lt;!--组织主页的URL--&gt;    </div><div class="line">        &lt;url&gt;http://www.baidu.com/banseon&lt;/url&gt;     </div><div class="line">    &lt;/organization&gt;    </div><div class="line">    &lt;!--构建项目需要的信息--&gt;    </div><div class="line">    &lt;build&gt;    </div><div class="line">     &lt;!--该元素设置了项目源码目录，当构建项目的时候，构建系统会编译目录里的源码。该路径是相对于pom.xml的相对路径。--&gt;    </div><div class="line">  &lt;sourceDirectory/&gt;    </div><div class="line">  &lt;!--该元素设置了项目脚本源码目录，该目录和源码目录不同：绝大多数情况下，该目录下的内容 会被拷贝到输出目录(因为脚本是被解释的，而不是被编译的)。--&gt;    </div><div class="line">  &lt;scriptSourceDirectory/&gt;    </div><div class="line">  &lt;!--该元素设置了项目单元测试使用的源码目录，当测试项目的时候，构建系统会编译目录里的源码。该路径是相对于pom.xml的相对路径。--&gt;    </div><div class="line">  &lt;testSourceDirectory/&gt;    </div><div class="line">  &lt;!--被编译过的应用程序class文件存放的目录。--&gt;    </div><div class="line">  &lt;outputDirectory/&gt;    </div><div class="line">  &lt;!--被编译过的测试class文件存放的目录。--&gt;    </div><div class="line">  &lt;testOutputDirectory/&gt;    </div><div class="line">  &lt;!--使用来自该项目的一系列构建扩展--&gt;    </div><div class="line">  &lt;extensions&gt;    </div><div class="line">   &lt;!--描述使用到的构建扩展。--&gt;    </div><div class="line">   &lt;extension&gt;    </div><div class="line">    &lt;!--构建扩展的groupId--&gt;    </div><div class="line">    &lt;groupId/&gt;    </div><div class="line">    &lt;!--构建扩展的artifactId--&gt;    </div><div class="line">    &lt;artifactId/&gt;    </div><div class="line">    &lt;!--构建扩展的版本--&gt;    </div><div class="line">    &lt;version/&gt;    </div><div class="line">   &lt;/extension&gt;    </div><div class="line">  &lt;/extensions&gt;    </div><div class="line">  &lt;!--当项目没有规定目标（Maven2 叫做阶段）时的默认值--&gt;    </div><div class="line">  &lt;defaultGoal/&gt;    </div><div class="line">  &lt;!--这个元素描述了项目相关的所有资源路径列表，例如和项目相关的属性文件，这些资源被包含在最终的打包文件里。--&gt;    </div><div class="line">  &lt;resources&gt;    </div><div class="line">   &lt;!--这个元素描述了项目相关或测试相关的所有资源路径--&gt;    </div><div class="line">   &lt;resource&gt;    </div><div class="line">    &lt;!-- 描述了资源的目标路径。该路径相对target/classes目录（例如$&#123;project.build.outputDirectory&#125;）。举个例 子，如果你想资源在特定的包里(org.apache.maven.messages)，你就必须该元素设置为org/apache/maven /messages。然而，如果你只是想把资源放到源码目录结构里，就不需要该配置。--&gt;    </div><div class="line">    &lt;targetPath/&gt;    </div><div class="line">    &lt;!--是否使用参数值代替参数名。参数值取自properties元素或者文件里配置的属性，文件在filters元素里列出。--&gt;    </div><div class="line">    &lt;filtering/&gt;    </div><div class="line">    &lt;!--描述存放资源的目录，该路径相对POM路径--&gt;    </div><div class="line">    &lt;directory/&gt;    </div><div class="line">    &lt;!--包含的模式列表，例如**/*.xml.--&gt;    </div><div class="line">    &lt;includes/&gt;    </div><div class="line">    &lt;!--排除的模式列表，例如**/*.xml--&gt;    </div><div class="line">    &lt;excludes/&gt;    </div><div class="line">   &lt;/resource&gt;    </div><div class="line">  &lt;/resources&gt;    </div><div class="line">  &lt;!--这个元素描述了单元测试相关的所有资源路径，例如和单元测试相关的属性文件。--&gt;    </div><div class="line">  &lt;testResources&gt;    </div><div class="line">   &lt;!--这个元素描述了测试相关的所有资源路径，参见build/resources/resource元素的说明--&gt;    </div><div class="line">   &lt;testResource&gt;    </div><div class="line">    &lt;targetPath/&gt;&lt;filtering/&gt;&lt;directory/&gt;&lt;includes/&gt;&lt;excludes/&gt;    </div><div class="line">   &lt;/testResource&gt;    </div><div class="line">  &lt;/testResources&gt;    </div><div class="line">  &lt;!--构建产生的所有文件存放的目录--&gt;    </div><div class="line">  &lt;directory/&gt;    </div><div class="line">  &lt;!--产生的构件的文件名，默认值是$&#123;artifactId&#125;-$&#123;version&#125;。--&gt;    </div><div class="line">  &lt;finalName/&gt;    </div><div class="line">  &lt;!--当filtering开关打开时，使用到的过滤器属性文件列表--&gt;    </div><div class="line">  &lt;filters/&gt;    </div><div class="line">  &lt;!--子项目可以引用的默认插件信息。该插件配置项直到被引用时才会被解析或绑定到生命周期。给定插件的任何本地配置都会覆盖这里的配置--&gt;    </div><div class="line">  &lt;pluginManagement&gt;    </div><div class="line">   &lt;!--使用的插件列表 。--&gt;    </div><div class="line">   &lt;plugins&gt;    </div><div class="line">    &lt;!--plugin元素包含描述插件所需要的信息。--&gt;    </div><div class="line">    &lt;plugin&gt;    </div><div class="line">     &lt;!--插件在仓库里的group ID--&gt;    </div><div class="line">     &lt;groupId/&gt;    </div><div class="line">     &lt;!--插件在仓库里的artifact ID--&gt;    </div><div class="line">     &lt;artifactId/&gt;    </div><div class="line">     &lt;!--被使用的插件的版本（或版本范围）--&gt;    </div><div class="line">     &lt;version/&gt;    </div><div class="line">     &lt;!--是否从该插件下载Maven扩展（例如打包和类型处理器），由于性能原因，只有在真需要下载时，该元素才被设置成enabled。--&gt;    </div><div class="line">     &lt;extensions/&gt;    </div><div class="line">     &lt;!--在构建生命周期中执行一组目标的配置。每个目标可能有不同的配置。--&gt;    </div><div class="line">     &lt;executions&gt;    </div><div class="line">      &lt;!--execution元素包含了插件执行需要的信息--&gt;    </div><div class="line">      &lt;execution&gt;    </div><div class="line">       &lt;!--执行目标的标识符，用于标识构建过程中的目标，或者匹配继承过程中需要合并的执行目标--&gt;    </div><div class="line">       &lt;id/&gt;    </div><div class="line">       &lt;!--绑定了目标的构建生命周期阶段，如果省略，目标会被绑定到源数据里配置的默认阶段--&gt;    </div><div class="line">       &lt;phase/&gt;    </div><div class="line">       &lt;!--配置的执行目标--&gt;    </div><div class="line">       &lt;goals/&gt;    </div><div class="line">       &lt;!--配置是否被传播到子POM--&gt;    </div><div class="line">       &lt;inherited/&gt;    </div><div class="line">       &lt;!--作为DOM对象的配置--&gt;    </div><div class="line">       &lt;configuration/&gt;    </div><div class="line">      &lt;/execution&gt;    </div><div class="line">     &lt;/executions&gt;    </div><div class="line">     &lt;!--项目引入插件所需要的额外依赖--&gt;    </div><div class="line">     &lt;dependencies&gt;    </div><div class="line">      &lt;!--参见dependencies/dependency元素--&gt;    </div><div class="line">      &lt;dependency&gt;    </div><div class="line">       ......    </div><div class="line">      &lt;/dependency&gt;    </div><div class="line">     &lt;/dependencies&gt;         </div><div class="line">     &lt;!--任何配置是否被传播到子项目--&gt;    </div><div class="line">     &lt;inherited/&gt;    </div><div class="line">     &lt;!--作为DOM对象的配置--&gt;    </div><div class="line">     &lt;configuration/&gt;    </div><div class="line">    &lt;/plugin&gt;    </div><div class="line">   &lt;/plugins&gt;    </div><div class="line">  &lt;/pluginManagement&gt;    </div><div class="line">  &lt;!--使用的插件列表--&gt;    </div><div class="line">  &lt;plugins&gt;    </div><div class="line">   &lt;!--参见build/pluginManagement/plugins/plugin元素--&gt;    </div><div class="line">   &lt;plugin&gt;    </div><div class="line">    &lt;groupId/&gt;&lt;artifactId/&gt;&lt;version/&gt;&lt;extensions/&gt;    </div><div class="line">    &lt;executions&gt;    </div><div class="line">     &lt;execution&gt;    </div><div class="line">      &lt;id/&gt;&lt;phase/&gt;&lt;goals/&gt;&lt;inherited/&gt;&lt;configuration/&gt;    </div><div class="line">     &lt;/execution&gt;    </div><div class="line">    &lt;/executions&gt;    </div><div class="line">    &lt;dependencies&gt;    </div><div class="line">     &lt;!--参见dependencies/dependency元素--&gt;    </div><div class="line">     &lt;dependency&gt;    </div><div class="line">      ......    </div><div class="line">     &lt;/dependency&gt;    </div><div class="line">    &lt;/dependencies&gt;    </div><div class="line">    &lt;goals/&gt;&lt;inherited/&gt;&lt;configuration/&gt;    </div><div class="line">   &lt;/plugin&gt;    </div><div class="line">  &lt;/plugins&gt;    </div><div class="line"> &lt;/build&gt;    </div><div class="line"> &lt;!--在列的项目构建profile，如果被激活，会修改构建处理--&gt;    </div><div class="line"> &lt;profiles&gt;    </div><div class="line">  &lt;!--根据环境参数或命令行参数激活某个构建处理--&gt;    </div><div class="line">  &lt;profile&gt;    </div><div class="line">   &lt;!--构建配置的唯一标识符。即用于命令行激活，也用于在继承时合并具有相同标识符的profile。--&gt;    </div><div class="line">   &lt;id/&gt;    </div><div class="line">   &lt;!--自动触发profile的条件逻辑。Activation是profile的开启钥匙。profile的力量来自于它    </div><div class="line">   能够在某些特定的环境中自动使用某些特定的值；这些环境通过activation元素指定。activation元素并不是激活profile的唯一方式。--&gt;    </div><div class="line">   &lt;activation&gt;    </div><div class="line">    &lt;!--profile默认是否激活的标志--&gt;    </div><div class="line">    &lt;activeByDefault/&gt;    </div><div class="line">    &lt;!--当匹配的jdk被检测到，profile被激活。例如，1.4激活JDK1.4，1.4.0_2，而!1.4激活所有版本不是以1.4开头的JDK。--&gt;    </div><div class="line">    &lt;jdk/&gt;    </div><div class="line">    &lt;!--当匹配的操作系统属性被检测到，profile被激活。os元素可以定义一些操作系统相关的属性。--&gt;    </div><div class="line">    &lt;os&gt;    </div><div class="line">     &lt;!--激活profile的操作系统的名字--&gt;    </div><div class="line">     &lt;name&gt;Windows XP&lt;/name&gt;    </div><div class="line">     &lt;!--激活profile的操作系统所属家族(如 &apos;windows&apos;)--&gt;    </div><div class="line">     &lt;family&gt;Windows&lt;/family&gt;    </div><div class="line">     &lt;!--激活profile的操作系统体系结构 --&gt;    </div><div class="line">     &lt;arch&gt;x86&lt;/arch&gt;    </div><div class="line">     &lt;!--激活profile的操作系统版本--&gt;    </div><div class="line">     &lt;version&gt;5.1.2600&lt;/version&gt;    </div><div class="line">    &lt;/os&gt;    </div><div class="line">    &lt;!--如果Maven检测到某一个属性（其值可以在POM中通过$&#123;名称&#125;引用），其拥有对应的名称和值，Profile就会被激活。如果值    </div><div class="line">    字段是空的，那么存在属性名称字段就会激活profile，否则按区分大小写方式匹配属性值字段--&gt;    </div><div class="line">    &lt;property&gt;    </div><div class="line">     &lt;!--激活profile的属性的名称--&gt;    </div><div class="line">     &lt;name&gt;mavenVersion&lt;/name&gt;    </div><div class="line">     &lt;!--激活profile的属性的值--&gt;    </div><div class="line">     &lt;value&gt;2.0.3&lt;/value&gt;    </div><div class="line">    &lt;/property&gt;    </div><div class="line">    &lt;!--提供一个文件名，通过检测该文件的存在或不存在来激活profile。missing检查文件是否存在，如果不存在则激活    </div><div class="line">    profile。另一方面，exists则会检查文件是否存在，如果存在则激活profile。--&gt;    </div><div class="line">    &lt;file&gt;    </div><div class="line">     &lt;!--如果指定的文件存在，则激活profile。--&gt;    </div><div class="line">     &lt;exists&gt;/usr/local/hudson/hudson-home/jobs/maven-guide-zh-to-production/workspace/&lt;/exists&gt;    </div><div class="line">     &lt;!--如果指定的文件不存在，则激活profile。--&gt;    </div><div class="line">     &lt;missing&gt;/usr/local/hudson/hudson-home/jobs/maven-guide-zh-to-production/workspace/&lt;/missing&gt;    </div><div class="line">    &lt;/file&gt;    </div><div class="line">   &lt;/activation&gt;    </div><div class="line">   &lt;!--构建项目所需要的信息。参见build元素--&gt;    </div><div class="line">   &lt;build&gt;    </div><div class="line">    &lt;defaultGoal/&gt;    </div><div class="line">    &lt;resources&gt;    </div><div class="line">     &lt;resource&gt;    </div><div class="line">      &lt;targetPath/&gt;&lt;filtering/&gt;&lt;directory/&gt;&lt;includes/&gt;&lt;excludes/&gt;    </div><div class="line">     &lt;/resource&gt;    </div><div class="line">    &lt;/resources&gt;    </div><div class="line">    &lt;testResources&gt;    </div><div class="line">     &lt;testResource&gt;    </div><div class="line">      &lt;targetPath/&gt;&lt;filtering/&gt;&lt;directory/&gt;&lt;includes/&gt;&lt;excludes/&gt;    </div><div class="line">     &lt;/testResource&gt;    </div><div class="line">    &lt;/testResources&gt;    </div><div class="line">    &lt;directory/&gt;&lt;finalName/&gt;&lt;filters/&gt;    </div><div class="line">    &lt;pluginManagement&gt;    </div><div class="line">     &lt;plugins&gt;    </div><div class="line">      &lt;!--参见build/pluginManagement/plugins/plugin元素--&gt;    </div><div class="line">      &lt;plugin&gt;    </div><div class="line">       &lt;groupId/&gt;&lt;artifactId/&gt;&lt;version/&gt;&lt;extensions/&gt;    </div><div class="line">       &lt;executions&gt;    </div><div class="line">        &lt;execution&gt;    </div><div class="line">         &lt;id/&gt;&lt;phase/&gt;&lt;goals/&gt;&lt;inherited/&gt;&lt;configuration/&gt;    </div><div class="line">        &lt;/execution&gt;    </div><div class="line">       &lt;/executions&gt;    </div><div class="line">       &lt;dependencies&gt;    </div><div class="line">        &lt;!--参见dependencies/dependency元素--&gt;    </div><div class="line">        &lt;dependency&gt;    </div><div class="line">         ......    </div><div class="line">        &lt;/dependency&gt;    </div><div class="line">       &lt;/dependencies&gt;    </div><div class="line">       &lt;goals/&gt;&lt;inherited/&gt;&lt;configuration/&gt;    </div><div class="line">      &lt;/plugin&gt;    </div><div class="line">     &lt;/plugins&gt;    </div><div class="line">    &lt;/pluginManagement&gt;    </div><div class="line">    &lt;plugins&gt;    </div><div class="line">     &lt;!--参见build/pluginManagement/plugins/plugin元素--&gt;    </div><div class="line">     &lt;plugin&gt;    </div><div class="line">      &lt;groupId/&gt;&lt;artifactId/&gt;&lt;version/&gt;&lt;extensions/&gt;    </div><div class="line">      &lt;executions&gt;    </div><div class="line">       &lt;execution&gt;    </div><div class="line">        &lt;id/&gt;&lt;phase/&gt;&lt;goals/&gt;&lt;inherited/&gt;&lt;configuration/&gt;    </div><div class="line">       &lt;/execution&gt;    </div><div class="line">      &lt;/executions&gt;    </div><div class="line">      &lt;dependencies&gt;    </div><div class="line">       &lt;!--参见dependencies/dependency元素--&gt;    </div><div class="line">       &lt;dependency&gt;    </div><div class="line">        ......    </div><div class="line">       &lt;/dependency&gt;    </div><div class="line">      &lt;/dependencies&gt;    </div><div class="line">      &lt;goals/&gt;&lt;inherited/&gt;&lt;configuration/&gt;    </div><div class="line">     &lt;/plugin&gt;    </div><div class="line">    &lt;/plugins&gt;    </div><div class="line">   &lt;/build&gt;    </div><div class="line">   &lt;!--模块（有时称作子项目） 被构建成项目的一部分。列出的每个模块元素是指向该模块的目录的相对路径--&gt;    </div><div class="line">   &lt;modules/&gt;    </div><div class="line">   &lt;!--发现依赖和扩展的远程仓库列表。--&gt;    </div><div class="line">   &lt;repositories&gt;    </div><div class="line">    &lt;!--参见repositories/repository元素--&gt;    </div><div class="line">    &lt;repository&gt;    </div><div class="line">     &lt;releases&gt;    </div><div class="line">      &lt;enabled/&gt;&lt;updatePolicy/&gt;&lt;checksumPolicy/&gt;    </div><div class="line">     &lt;/releases&gt;    </div><div class="line">     &lt;snapshots&gt;    </div><div class="line">      &lt;enabled/&gt;&lt;updatePolicy/&gt;&lt;checksumPolicy/&gt;    </div><div class="line">     &lt;/snapshots&gt;    </div><div class="line">     &lt;id/&gt;&lt;name/&gt;&lt;url/&gt;&lt;layout/&gt;    </div><div class="line">    &lt;/repository&gt;    </div><div class="line">   &lt;/repositories&gt;    </div><div class="line">   &lt;!--发现插件的远程仓库列表，这些插件用于构建和报表--&gt;    </div><div class="line">   &lt;pluginRepositories&gt;    </div><div class="line">    &lt;!--包含需要连接到远程插件仓库的信息.参见repositories/repository元素--&gt;        </div><div class="line">    &lt;pluginRepository&gt;    </div><div class="line">     &lt;releases&gt;    </div><div class="line">      &lt;enabled/&gt;&lt;updatePolicy/&gt;&lt;checksumPolicy/&gt;    </div><div class="line">     &lt;/releases&gt;    </div><div class="line">     &lt;snapshots&gt;    </div><div class="line">      &lt;enabled/&gt;&lt;updatePolicy/&gt;&lt;checksumPolicy/&gt;    </div><div class="line">     &lt;/snapshots&gt;    </div><div class="line">     &lt;id/&gt;&lt;name/&gt;&lt;url/&gt;&lt;layout/&gt;    </div><div class="line">    &lt;/pluginRepository&gt;    </div><div class="line">   &lt;/pluginRepositories&gt;    </div><div class="line">   &lt;!--该元素描述了项目相关的所有依赖。 这些依赖组成了项目构建过程中的一个个环节。它们自动从项目定义的仓库中下载。要获取更多信息，请看项目依赖机制。--&gt;    </div><div class="line">   &lt;dependencies&gt;    </div><div class="line">    &lt;!--参见dependencies/dependency元素--&gt;    </div><div class="line">    &lt;dependency&gt;    </div><div class="line">     ......    </div><div class="line">    &lt;/dependency&gt;    </div><div class="line">   &lt;/dependencies&gt;    </div><div class="line">   &lt;!--不赞成使用. 现在Maven忽略该元素.--&gt;    </div><div class="line">   &lt;reports/&gt;       </div><div class="line">   &lt;!--该元素包括使用报表插件产生报表的规范。当用户执行“mvn site”，这些报表就会运行。 在页面导航栏能看到所有报表的链接。参见reporting元素--&gt;    </div><div class="line">   &lt;reporting&gt;    </div><div class="line">    ......    </div><div class="line">   &lt;/reporting&gt;    </div><div class="line">   &lt;!--参见dependencyManagement元素--&gt;    </div><div class="line">   &lt;dependencyManagement&gt;    </div><div class="line">    &lt;dependencies&gt;    </div><div class="line">     &lt;!--参见dependencies/dependency元素--&gt;    </div><div class="line">     &lt;dependency&gt;    </div><div class="line">      ......    </div><div class="line">     &lt;/dependency&gt;    </div><div class="line">    &lt;/dependencies&gt;    </div><div class="line">   &lt;/dependencyManagement&gt;    </div><div class="line">   &lt;!--参见distributionManagement元素--&gt;    </div><div class="line">   &lt;distributionManagement&gt;    </div><div class="line">    ......    </div><div class="line">   &lt;/distributionManagement&gt;    </div><div class="line">   &lt;!--参见properties元素--&gt;    </div><div class="line">   &lt;properties/&gt;    </div><div class="line">  &lt;/profile&gt;    </div><div class="line"> &lt;/profiles&gt;    </div><div class="line"> &lt;!--模块（有时称作子项目） 被构建成项目的一部分。列出的每个模块元素是指向该模块的目录的相对路径--&gt;    </div><div class="line"> &lt;modules/&gt;    </div><div class="line">    &lt;!--发现依赖和扩展的远程仓库列表。--&gt;     </div><div class="line">    &lt;repositories&gt;     </div><div class="line">     &lt;!--包含需要连接到远程仓库的信息--&gt;    </div><div class="line">        &lt;repository&gt;    </div><div class="line">         &lt;!--如何处理远程仓库里发布版本的下载--&gt;    </div><div class="line">         &lt;releases&gt;    </div><div class="line">          &lt;!--true或者false表示该仓库是否为下载某种类型构件（发布版，快照版）开启。 --&gt;    </div><div class="line">    &lt;enabled/&gt;    </div><div class="line">    &lt;!--该元素指定更新发生的频率。Maven会比较本地POM和远程POM的时间戳。这里的选项是：always（一直），daily（默认，每日），interval：X（这里X是以分钟为单位的时间间隔），或者never（从不）。--&gt;    </div><div class="line">    &lt;updatePolicy/&gt;    </div><div class="line">    &lt;!--当Maven验证构件校验文件失败时该怎么做：ignore（忽略），fail（失败），或者warn（警告）。--&gt;    </div><div class="line">    &lt;checksumPolicy/&gt;    </div><div class="line">   &lt;/releases&gt;    </div><div class="line">   &lt;!-- 如何处理远程仓库里快照版本的下载。有了releases和snapshots这两组配置，POM就可以在每个单独的仓库中，为每种类型的构件采取不同的 策略。例如，可能有人会决定只为开发目的开启对快照版本下载的支持。参见repositories/repository/releases元素 --&gt;    </div><div class="line">   &lt;snapshots&gt;    </div><div class="line">    &lt;enabled/&gt;&lt;updatePolicy/&gt;&lt;checksumPolicy/&gt;    </div><div class="line">   &lt;/snapshots&gt;    </div><div class="line">   &lt;!--远程仓库唯一标识符。可以用来匹配在settings.xml文件里配置的远程仓库--&gt;    </div><div class="line">   &lt;id&gt;banseon-repository-proxy&lt;/id&gt;     </div><div class="line">   &lt;!--远程仓库名称--&gt;    </div><div class="line">            &lt;name&gt;banseon-repository-proxy&lt;/name&gt;     </div><div class="line">            &lt;!--远程仓库URL，按protocol://hostname/path形式--&gt;    </div><div class="line">            &lt;url&gt;http://192.168.1.169:9999/repository/&lt;/url&gt;     </div><div class="line">            &lt;!-- 用于定位和排序构件的仓库布局类型-可以是default（默认）或者legacy（遗留）。Maven 2为其仓库提供了一个默认的布局；然 而，Maven 1.x有一种不同的布局。我们可以使用该元素指定布局是default（默认）还是legacy（遗留）。--&gt;    </div><div class="line">            &lt;layout&gt;default&lt;/layout&gt;               </div><div class="line">        &lt;/repository&gt;     </div><div class="line">    &lt;/repositories&gt;    </div><div class="line">    &lt;!--发现插件的远程仓库列表，这些插件用于构建和报表--&gt;    </div><div class="line">    &lt;pluginRepositories&gt;    </div><div class="line">     &lt;!--包含需要连接到远程插件仓库的信息.参见repositories/repository元素--&gt;    </div><div class="line">  &lt;pluginRepository&gt;    </div><div class="line">   ......    </div><div class="line">  &lt;/pluginRepository&gt;    </div><div class="line"> &lt;/pluginRepositories&gt;    </div><div class="line">       </div><div class="line">    &lt;!--该元素描述了项目相关的所有依赖。 这些依赖组成了项目构建过程中的一个个环节。它们自动从项目定义的仓库中下载。要获取更多信息，请看项目依赖机制。--&gt;     </div><div class="line">    &lt;dependencies&gt;     </div><div class="line">        &lt;dependency&gt;    </div><div class="line">   &lt;!--依赖的group ID--&gt;    </div><div class="line">            &lt;groupId&gt;org.apache.maven&lt;/groupId&gt;     </div><div class="line">            &lt;!--依赖的artifact ID--&gt;    </div><div class="line">            &lt;artifactId&gt;maven-artifact&lt;/artifactId&gt;     </div><div class="line">            &lt;!--依赖的版本号。 在Maven 2里, 也可以配置成版本号的范围。--&gt;    </div><div class="line">            &lt;version&gt;3.8.1&lt;/version&gt;     </div><div class="line">            &lt;!-- 依赖类型，默认类型是jar。它通常表示依赖的文件的扩展名，但也有例外。一个类型可以被映射成另外一个扩展名或分类器。类型经常和使用的打包方式对应， 尽管这也有例外。一些类型的例子：jar，war，ejb-client和test-jar。如果设置extensions为 true，就可以在 plugin里定义新的类型。所以前面的类型的例子不完整。--&gt;    </div><div class="line">            &lt;type&gt;jar&lt;/type&gt;    </div><div class="line">            &lt;!-- 依赖的分类器。分类器可以区分属于同一个POM，但不同构建方式的构件。分类器名被附加到文件名的版本号后面。例如，如果你想要构建两个单独的构件成 JAR，一个使用Java 1.4编译器，另一个使用Java 6编译器，你就可以使用分类器来生成两个单独的JAR构件。--&gt;    </div><div class="line">            &lt;classifier&gt;&lt;/classifier&gt;    </div><div class="line">            &lt;!--依赖范围。在项目发布过程中，帮助决定哪些构件被包括进来。欲知详情请参考依赖机制。    </div><div class="line">                - compile ：默认范围，用于编译      </div><div class="line">                - provided：类似于编译，但支持你期待jdk或者容器提供，类似于classpath      </div><div class="line">                - runtime: 在执行时需要使用      </div><div class="line">                - test:    用于test任务时使用      </div><div class="line">                - system: 需要外在提供相应的元素。通过systemPath来取得      </div><div class="line">                - systemPath: 仅用于范围为system。提供相应的路径      </div><div class="line">                - optional:   当项目自身被依赖时，标注依赖是否传递。用于连续依赖时使用--&gt;     </div><div class="line">            &lt;scope&gt;test&lt;/scope&gt;       </div><div class="line">            &lt;!--仅供system范围使用。注意，不鼓励使用这个元素，并且在新的版本中该元素可能被覆盖掉。该元素为依赖规定了文件系统上的路径。需要绝对路径而不是相对路径。推荐使用属性匹配绝对路径，例如$&#123;java.home&#125;。--&gt;    </div><div class="line">            &lt;systemPath&gt;&lt;/systemPath&gt;     </div><div class="line">            &lt;!--当计算传递依赖时， 从依赖构件列表里，列出被排除的依赖构件集。即告诉maven你只依赖指定的项目，不依赖项目的依赖。此元素主要用于解决版本冲突问题--&gt;    </div><div class="line">            &lt;exclusions&gt;    </div><div class="line">             &lt;exclusion&gt;     </div><div class="line">                    &lt;artifactId&gt;spring-core&lt;/artifactId&gt;     </div><div class="line">                    &lt;groupId&gt;org.springframework&lt;/groupId&gt;     </div><div class="line">                &lt;/exclusion&gt;     </div><div class="line">            &lt;/exclusions&gt;       </div><div class="line">            &lt;!--可选依赖，如果你在项目B中把C依赖声明为可选，你就需要在依赖于B的项目（例如项目A）中显式的引用对C的依赖。可选依赖阻断依赖的传递性。--&gt;     </div><div class="line">            &lt;optional&gt;true&lt;/optional&gt;    </div><div class="line">        &lt;/dependency&gt;    </div><div class="line">    &lt;/dependencies&gt;    </div><div class="line">    &lt;!--不赞成使用. 现在Maven忽略该元素.--&gt;    </div><div class="line">    &lt;reports&gt;&lt;/reports&gt;    </div><div class="line">    &lt;!--该元素描述使用报表插件产生报表的规范。当用户执行“mvn site”，这些报表就会运行。 在页面导航栏能看到所有报表的链接。--&gt;    </div><div class="line"> &lt;reporting&gt;    </div><div class="line">  &lt;!--true，则，网站不包括默认的报表。这包括“项目信息”菜单中的报表。--&gt;    </div><div class="line">  &lt;excludeDefaults/&gt;    </div><div class="line">  &lt;!--所有产生的报表存放到哪里。默认值是$&#123;project.build.directory&#125;/site。--&gt;    </div><div class="line">  &lt;outputDirectory/&gt;    </div><div class="line">  &lt;!--使用的报表插件和他们的配置。--&gt;    </div><div class="line">  &lt;plugins&gt;    </div><div class="line">   &lt;!--plugin元素包含描述报表插件需要的信息--&gt;    </div><div class="line">   &lt;plugin&gt;    </div><div class="line">    &lt;!--报表插件在仓库里的group ID--&gt;    </div><div class="line">    &lt;groupId/&gt;    </div><div class="line">    &lt;!--报表插件在仓库里的artifact ID--&gt;    </div><div class="line">    &lt;artifactId/&gt;    </div><div class="line">    &lt;!--被使用的报表插件的版本（或版本范围）--&gt;    </div><div class="line">    &lt;version/&gt;    </div><div class="line">    &lt;!--任何配置是否被传播到子项目--&gt;    </div><div class="line">    &lt;inherited/&gt;    </div><div class="line">    &lt;!--报表插件的配置--&gt;    </div><div class="line">    &lt;configuration/&gt;    </div><div class="line">    &lt;!--一组报表的多重规范，每个规范可能有不同的配置。一个规范（报表集）对应一个执行目标 。例如，有1，2，3，4，5，6，7，8，9个报表。1，2，5构成A报表集，对应一个执行目标。2，5，8构成B报表集，对应另一个执行目标--&gt;    </div><div class="line">    &lt;reportSets&gt;    </div><div class="line">     &lt;!--表示报表的一个集合，以及产生该集合的配置--&gt;    </div><div class="line">     &lt;reportSet&gt;    </div><div class="line">      &lt;!--报表集合的唯一标识符，POM继承时用到--&gt;    </div><div class="line">      &lt;id/&gt;    </div><div class="line">      &lt;!--产生报表集合时，被使用的报表的配置--&gt;    </div><div class="line">      &lt;configuration/&gt;    </div><div class="line">      &lt;!--配置是否被继承到子POMs--&gt;    </div><div class="line">      &lt;inherited/&gt;    </div><div class="line">      &lt;!--这个集合里使用到哪些报表--&gt;    </div><div class="line">      &lt;reports/&gt;    </div><div class="line">     &lt;/reportSet&gt;    </div><div class="line">    &lt;/reportSets&gt;    </div><div class="line">   &lt;/plugin&gt;    </div><div class="line">  &lt;/plugins&gt;    </div><div class="line"> &lt;/reporting&gt;    </div><div class="line"> &lt;!-- 继承自该项目的所有子项目的默认依赖信息。这部分的依赖信息不会被立即解析,而是当子项目声明一个依赖（必须描述group ID和 artifact ID信息），如果group ID和artifact ID以外的一些信息没有描述，则通过group ID和artifact ID 匹配到这里的依赖，并使用这里的依赖信息。--&gt;    </div><div class="line"> &lt;dependencyManagement&gt;    </div><div class="line">  &lt;dependencies&gt;    </div><div class="line">   &lt;!--参见dependencies/dependency元素--&gt;    </div><div class="line">   &lt;dependency&gt;    </div><div class="line">    ......    </div><div class="line">   &lt;/dependency&gt;    </div><div class="line">  &lt;/dependencies&gt;    </div><div class="line"> &lt;/dependencyManagement&gt;       </div><div class="line">    &lt;!--项目分发信息，在执行mvn deploy后表示要发布的位置。有了这些信息就可以把网站部署到远程服务器或者把构件部署到远程仓库。--&gt;     </div><div class="line">    &lt;distributionManagement&gt;    </div><div class="line">        &lt;!--部署项目产生的构件到远程仓库需要的信息--&gt;    </div><div class="line">        &lt;repository&gt;    </div><div class="line">         &lt;!--是分配给快照一个唯一的版本号（由时间戳和构建流水号）？还是每次都使用相同的版本号？参见repositories/repository元素--&gt;    </div><div class="line">   &lt;uniqueVersion/&gt;    </div><div class="line">   &lt;id&gt;banseon-maven2&lt;/id&gt;     </div><div class="line">   &lt;name&gt;banseon maven2&lt;/name&gt;     </div><div class="line">            &lt;url&gt;file://$&#123;basedir&#125;/target/deploy&lt;/url&gt;     </div><div class="line">            &lt;layout/&gt;    </div><div class="line">  &lt;/repository&gt;    </div><div class="line">  &lt;!--构件的快照部署到哪里？如果没有配置该元素，默认部署到repository元素配置的仓库，参见distributionManagement/repository元素--&gt;     </div><div class="line">  &lt;snapshotRepository&gt;    </div><div class="line">   &lt;uniqueVersion/&gt;    </div><div class="line">   &lt;id&gt;banseon-maven2&lt;/id&gt;    </div><div class="line">            &lt;name&gt;Banseon-maven2 Snapshot Repository&lt;/name&gt;    </div><div class="line">            &lt;url&gt;scp://svn.baidu.com/banseon:/usr/local/maven-snapshot&lt;/url&gt;     </div><div class="line">   &lt;layout/&gt;    </div><div class="line">  &lt;/snapshotRepository&gt;    </div><div class="line">  &lt;!--部署项目的网站需要的信息--&gt;     </div><div class="line">        &lt;site&gt;    </div><div class="line">         &lt;!--部署位置的唯一标识符，用来匹配站点和settings.xml文件里的配置--&gt;     </div><div class="line">            &lt;id&gt;banseon-site&lt;/id&gt;     </div><div class="line">            &lt;!--部署位置的名称--&gt;    </div><div class="line">            &lt;name&gt;business api website&lt;/name&gt;     </div><div class="line">            &lt;!--部署位置的URL，按protocol://hostname/path形式--&gt;    </div><div class="line">            &lt;url&gt;     </div><div class="line">                scp://svn.baidu.com/banseon:/var/www/localhost/banseon-web      </div><div class="line">            &lt;/url&gt;     </div><div class="line">        &lt;/site&gt;    </div><div class="line">  &lt;!--项目下载页面的URL。如果没有该元素，用户应该参考主页。使用该元素的原因是：帮助定位那些不在仓库里的构件（由于license限制）。--&gt;    </div><div class="line">  &lt;downloadUrl/&gt;    </div><div class="line">  &lt;!--如果构件有了新的group ID和artifact ID（构件移到了新的位置），这里列出构件的重定位信息。--&gt;    </div><div class="line">  &lt;relocation&gt;    </div><div class="line">   &lt;!--构件新的group ID--&gt;    </div><div class="line">   &lt;groupId/&gt;    </div><div class="line">   &lt;!--构件新的artifact ID--&gt;    </div><div class="line">   &lt;artifactId/&gt;    </div><div class="line">   &lt;!--构件新的版本号--&gt;    </div><div class="line">   &lt;version/&gt;    </div><div class="line">   &lt;!--显示给用户的，关于移动的额外信息，例如原因。--&gt;    </div><div class="line">   &lt;message/&gt;    </div><div class="line">  &lt;/relocation&gt;    </div><div class="line">  &lt;!-- 给出该构件在远程仓库的状态。不得在本地项目中设置该元素，因为这是工具自动更新的。有效的值有：none（默认），converted（仓库管理员从 Maven 1 POM转换过来），partner（直接从伙伴Maven 2仓库同步过来），deployed（从Maven 2实例部 署），verified（被核实时正确的和最终的）。--&gt;    </div><div class="line">  &lt;status/&gt;           </div><div class="line">    &lt;/distributionManagement&gt;    </div><div class="line">    &lt;!--以值替代名称，Properties可以在整个POM中使用，也可以作为触发条件（见settings.xml配置文件里activation元素的说明）。格式是&lt;name&gt;value&lt;/name&gt;。--&gt;    </div><div class="line">    &lt;properties/&gt;    </div><div class="line">&lt;/project&gt;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt; pom作为项目对象模型。通过xml表示maven项目，使用pom.xml来实现。主要描述了项目：包括配置文件；开发者需要遵循的规则，缺陷管理系统，组织和licenses，项目的url，项目的依赖性，以及其他所有的项目相关因素。&lt;br&gt;
    
    </summary>
    
      <category term="Maven" scheme="http://yoursite.com/categories/Maven/"/>
    
    
      <category term="Maven" scheme="http://yoursite.com/tags/Maven/"/>
    
  </entry>
  
  <entry>
    <title>Jar包添加到maven本地仓库</title>
    <link href="http://yoursite.com/2017/03/07/Jar%E5%8C%85%E6%B7%BB%E5%8A%A0%E5%88%B0maven%E6%9C%AC%E5%9C%B0%E4%BB%93%E5%BA%93/"/>
    <id>http://yoursite.com/2017/03/07/Jar包添加到maven本地仓库/</id>
    <published>2017-03-07T13:02:25.000Z</published>
    <updated>2017-09-28T08:10:04.299Z</updated>
    
    <content type="html"><![CDATA[<p> maven在应用的过程中，有 maven在应用的过程中，有些jar包在仓库上面是没法找到的，这需要我们自己手动导入到仓库中，些jar包在仓库上面是没法找到的，这需要我们自己手动导入到仓库中。</p><a id="more"></a><h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><p>zxing-3.21.jar是根据github上面项目<a href="https://github.com/zxing" target="_blank" rel="external">ZXing Project</a>自己生成的jar包，该包主要应用于二维码生成，下面讲述怎么把怎么把zxing-3.21.jar添加到本地的maven仓库中。</p><h3 id="环境要求"><a href="#环境要求" class="headerlink" title="环境要求"></a>环境要求</h3><p>需要配置JDK和maven环境，完成后以管理员身份打开命令提示符窗口(cmd),再输入下面相关的语法。</p><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">mvn install:install-file -Dfile=jar包的位置(参数一) -DgroupId=groupId(参数二) -DartifactId=artifactId(参数三) -Dversion=version(参数四) -Dpackaging=jar</div><div class="line"></div><div class="line">eg:</div><div class="line">mvn install:install-file -Dfile=&quot;C:\Users\eric\Desktop\zxing\3.21\zxing-3.21.jar&quot; -DgroupId=com.eric -DartifactId=zxing -Dversion=3.21 -Dpackaging=jar</div><div class="line"></div><div class="line">result：</div><div class="line">[INFO] Scanning for projects...</div><div class="line">[INFO]</div><div class="line">[INFO] ------------------------------------------------------------------------</div><div class="line">[INFO] Building Maven Stub Project (No POM) 1</div><div class="line">[INFO] ------------------------------------------------------------------------</div><div class="line">[INFO]</div><div class="line">[INFO] --- maven-install-plugin:2.4:install-file (default-cli) @ standalone-pom ---</div><div class="line">[INFO] Installing C:\Users\eric\Desktop\zxing\3.21\zxing-3.21.jar to C:\Users\eric\.m2\repository\com\eric\zxing\3.21\zxing-3.21.jar</div><div class="line">[INFO] Installing C:\Users\eric\AppData\Local\Temp\mvninstall6543969167446403883.pom to C:\Users\eric\.m2\repository\com\eric\zxing\3.21\zxing-3.21.pom</div><div class="line">[INFO] ------------------------------------------------------------------------</div><div class="line">[INFO] BUILD SUCCESS</div><div class="line">[INFO] ------------------------------------------------------------------------</div><div class="line">[INFO] Total time: 0.836 s</div><div class="line">[INFO] Finished at: 2017-03-08T00:24:12+08:00</div><div class="line">[INFO] Final Memory: 7M/117M</div><div class="line">[INFO] ------------------------------------------------------------------------</div><div class="line">(添加成功！)</div></pre></td></tr></table></figure><p><strong>注意：地址+jar包名,即C:\Users\eric\Desktop\zxing\3.21\zxing-3.21.jar要加引号””,”参数二\参数三\参数四”这也是jar包在仓库中的地址。</strong></p><h3 id="查看生成的依赖"><a href="#查看生成的依赖" class="headerlink" title="查看生成的依赖"></a>查看生成的依赖</h3><p>查看添加的zxing-3.21.jar的dependency</p><ul><li>通过设置的对应参数获取.即</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">-DgroupId=groupId(参数二) -DartifactId=artifactId(参数三) -Dversion=version(参数四)</div></pre></td></tr></table></figure><ul><li>参看本地仓库中pom文件C:\Users\eric.m2\repository\com\eric\zxing\3.21\zxing-3.21.pom，可以看到:</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;groupId&gt;com.eric&lt;/groupId&gt;</div><div class="line">&lt;artifactId&gt;zxing&lt;/artifactId&gt;</div><div class="line">&lt;version&gt;3.21&lt;/version&gt;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt; maven在应用的过程中，有 maven在应用的过程中，有些jar包在仓库上面是没法找到的，这需要我们自己手动导入到仓库中，些jar包在仓库上面是没法找到的，这需要我们自己手动导入到仓库中。&lt;/p&gt;
    
    </summary>
    
      <category term="Maven" scheme="http://yoursite.com/categories/Maven/"/>
    
    
      <category term="Maven" scheme="http://yoursite.com/tags/Maven/"/>
    
  </entry>
  
  <entry>
    <title>Redis数据类型--Set（集合）</title>
    <link href="http://yoursite.com/2017/03/06/Redis%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B--Set%EF%BC%88%E9%9B%86%E5%90%88%EF%BC%89/"/>
    <id>http://yoursite.com/2017/03/06/Redis数据类型--Set（集合）/</id>
    <published>2017-03-06T13:02:25.000Z</published>
    <updated>2017-09-28T09:36:40.316Z</updated>
    
    <content type="html"><![CDATA[<p>Redis的集合和列表都可以存储多个字符串，它们之间的不同在于，列表可以存储多个不同的字符串，而集合则通过使用散列来保证自己存储的每个字符串都是各不相同的。包含字符串的无序收集器（unordered collection）,并且被包含的每个字符串都是独一无二、各不相同的。<br>结构的读写：<br> 添加、读取、移除单个元素<br> 检查一个元素是否存在于集合中<br> 计算交集、并集、差集<br> 从集合中随机获取元素<br><a id="more"></a></p><h3 id="SADD"><a href="#SADD" class="headerlink" title="SADD"></a><strong>SADD</strong></h3><p><strong>SADD key member [member …]</strong><br> 将一个或多个 member 元素加入到集合 key 当中，已经存在于集合的 member 元素将被忽略。<br> 假如 key 不存在，则创建一个只包含 member 元素作成员的集合。<br> 当 key 不是集合类型时，返回一个错误。<br> 在Redis2.4版本以前， SADD 只接受单个 member 值。</p><h4 id="可用版本"><a href="#可用版本" class="headerlink" title="可用版本"></a>可用版本</h4><p>版本&gt;= 1.0.0</p><h4 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><p>O(N)， N 是被添加的元素的数量。</p><h4 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h4><p>被添加到集合中的新元素的数量，不包括被忽略的元素。</p><h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"># 添加单个元素</div><div class="line">redis&gt; SADD bbs &quot;discuz.net&quot;</div><div class="line">(integer) 1</div><div class="line"># 添加重复元素</div><div class="line">redis&gt; SADD bbs &quot;discuz.net&quot;</div><div class="line">(integer) 0</div><div class="line"># 添加多个元素</div><div class="line">redis&gt; SADD bbs &quot;tianya.cn&quot; &quot;groups.google.com&quot;</div><div class="line">(integer) 2</div><div class="line">redis&gt; SMEMBERS bbs</div><div class="line">1) &quot;discuz.net&quot;</div><div class="line">2) &quot;groups.google.com&quot;</div><div class="line">3) &quot;tianya.cn&quot;</div></pre></td></tr></table></figure><h3 id="SCARD"><a href="#SCARD" class="headerlink" title="SCARD"></a><strong>SCARD</strong></h3><p><strong>SCARD key</strong><br> 返回集合 key 的基数(集合中元素的数量)。</p><h4 id="可用版本-1"><a href="#可用版本-1" class="headerlink" title="可用版本"></a>可用版本</h4><p>版本&gt;= 1.0.0</p><h4 id="时间复杂度-1"><a href="#时间复杂度-1" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><p>O(1)</p><h4 id="返回值-1"><a href="#返回值-1" class="headerlink" title="返回值"></a>返回值</h4><p>集合的基数。<br>当 key 不存在时，返回 0 。</p><h4 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">redis&gt; SADD tool pc printer phone</div><div class="line">(integer) 3</div><div class="line">redis&gt; SCARD tool   # 非空集合</div><div class="line">(integer) 3</div><div class="line">redis&gt; DEL tool</div><div class="line">(i</div><div class="line">redis&gt; SCARD tool   # 空集合</div><div class="line">(integer) 0</div></pre></td></tr></table></figure><h3 id="SDIFF"><a href="#SDIFF" class="headerlink" title="SDIFF"></a><strong>SDIFF</strong></h3><p><strong>SDIFF key [key …]</strong><br> 返回一个集合的全部成员，该集合是所有给定集合之间的差集。<br> 不存在的 key 被视为空集。</p><h4 id="可用版本-2"><a href="#可用版本-2" class="headerlink" title="可用版本"></a>可用版本</h4><p>版本&gt;= 1.0.0</p><h4 id="时间复杂度-2"><a href="#时间复杂度-2" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><p>O(N)， N 是所有给定集合的成员数量之和。</p><h4 id="返回值-2"><a href="#返回值-2" class="headerlink" title="返回值"></a>返回值</h4><p>交集成员的列表。</p><h4 id="示例-2"><a href="#示例-2" class="headerlink" title="示例"></a>示例</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">redis&gt; SMEMBERS peter&apos;s_movies</div><div class="line">1) &quot;bet man&quot;</div><div class="line">2) &quot;start war&quot;</div><div class="line">3) &quot;2012&quot;</div><div class="line">redis&gt; SMEMBERS joe&apos;s_movies</div><div class="line">1) &quot;hi, lady&quot;</div><div class="line">2) &quot;Fast Five&quot;</div><div class="line">3) &quot;2012&quot;</div><div class="line">redis&gt; SDIFF peter&apos;s_movies joe&apos;s_movies</div><div class="line">1) &quot;bet man&quot;</div><div class="line">2) &quot;start war&quot;</div></pre></td></tr></table></figure><h3 id="SDIFFSTORE"><a href="#SDIFFSTORE" class="headerlink" title="SDIFFSTORE"></a><strong>SDIFFSTORE</strong></h3><p><strong>SDIFFSTORE destination key [key …]</strong><br> 这个命令的作用和 SDIFF 类似，但它将结果保存到 destination 集合，而不是简单地返回结果集。<br> 如果 destination 集合已经存在，则将其覆盖。<br> destination 可以是 key 本身。</p><h4 id="可用版本-3"><a href="#可用版本-3" class="headerlink" title="可用版本"></a>可用版本</h4><p>版本&gt;= 1.0.0</p><h4 id="时间复杂度-3"><a href="#时间复杂度-3" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><p>O(N)， N 是所有给定集合的成员数量之和。</p><h4 id="返回值-3"><a href="#返回值-3" class="headerlink" title="返回值"></a>返回值</h4><p>结果集中的元素数量。</p><h4 id="示例-3"><a href="#示例-3" class="headerlink" title="示例"></a>示例</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">redis&gt; SMEMBERS joe&apos;s_movies</div><div class="line">1) &quot;hi, lady&quot;</div><div class="line">2) &quot;Fast Five&quot;</div><div class="line">3) &quot;2012&quot;</div><div class="line">redis&gt; SMEMBERS peter&apos;s_movies</div><div class="line">1) &quot;bet man&quot;</div><div class="line">2) &quot;start war&quot;</div><div class="line">3) &quot;2012&quot;</div><div class="line">redis&gt; SDIFFSTORE joe_diff_peter joe&apos;s_movies peter&apos;s_movies</div><div class="line">(integer) 2</div><div class="line">redis&gt; SMEMBERS joe_diff_peter</div><div class="line">1) &quot;hi, lady&quot;</div><div class="line">2) &quot;Fast Five&quot;</div></pre></td></tr></table></figure><h3 id="SINTER"><a href="#SINTER" class="headerlink" title="SINTER"></a><strong>SINTER</strong></h3><p><strong>SINTER key [key …]</strong><br> 返回一个集合的全部成员，该集合是所有给定集合的交集。<br> 不存在的 key 被视为空集。<br> 当给定集合当中有一个空集时，结果也为空集(根据集合运算定律)。</p><h4 id="可用版本-4"><a href="#可用版本-4" class="headerlink" title="可用版本"></a>可用版本</h4><p>版本&gt;= 1.0.0</p><h4 id="时间复杂度-4"><a href="#时间复杂度-4" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><p>O(N * M)， N 为给定集合当中基数最小的集合， M 为给定集合的个数。</p><h4 id="返回值-4"><a href="#返回值-4" class="headerlink" title="返回值"></a>返回值</h4><p>交集成员的列表。</p><h4 id="示例-4"><a href="#示例-4" class="headerlink" title="示例"></a>示例</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">redis&gt; SMEMBERS group_1</div><div class="line">1) &quot;LI LEI&quot;</div><div class="line">2) &quot;TOM&quot;</div><div class="line">3) &quot;JACK&quot;</div><div class="line">redis&gt; SMEMBERS group_2</div><div class="line">1) &quot;HAN MEIMEI&quot;</div><div class="line">2) &quot;JACK&quot;</div><div class="line">redis&gt; SINTER group_1 group_2</div><div class="line">1) &quot;JACK&quot;</div></pre></td></tr></table></figure><h3 id="SINTERSTORE"><a href="#SINTERSTORE" class="headerlink" title="SINTERSTORE"></a><strong>SINTERSTORE</strong></h3><p><strong>SINTERSTORE destination key [key …]</strong></p><p> 这个命令类似于 SINTER 命令，但它将结果保存到 destination 集合，而不是简单地返回结果集。<br> 如果 destination 集合已经存在，则将其覆盖。<br> destination 可以是 key 本身。</p><h4 id="可用版本-5"><a href="#可用版本-5" class="headerlink" title="可用版本"></a>可用版本</h4><p>版本&gt;= 1.0.0</p><h4 id="时间复杂度-5"><a href="#时间复杂度-5" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><p>O(N * M)， N 为给定集合当中基数最小的集合， M 为给定集合的个数。</p><h4 id="返回值-5"><a href="#返回值-5" class="headerlink" title="返回值"></a>返回值</h4><p>结果集中的成员数量。</p><h4 id="示例-5"><a href="#示例-5" class="headerlink" title="示例"></a>示例</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">redis&gt; SMEMBERS songs</div><div class="line">1) &quot;good bye joe&quot;</div><div class="line">2) &quot;hello,peter&quot;</div><div class="line">redis&gt; SMEMBERS my_songs</div><div class="line">1) &quot;good bye joe&quot;</div><div class="line">2) &quot;falling&quot;</div><div class="line">redis&gt; SINTERSTORE song_interset songs my_songs</div><div class="line">(integer) 1</div><div class="line">redis&gt; SMEMBERS song_interset</div><div class="line">1) &quot;good bye joe&quot;</div></pre></td></tr></table></figure><h3 id="SISMEMBER"><a href="#SISMEMBER" class="headerlink" title="SISMEMBER"></a><strong>SISMEMBER</strong></h3><p><strong>SISMEMBER key member</strong><br> 判断 member 元素是否集合 key 的成员。</p><h4 id="可用版本-6"><a href="#可用版本-6" class="headerlink" title="可用版本"></a>可用版本</h4><p>版本&gt;= 1.0.0</p><h4 id="时间复杂度-6"><a href="#时间复杂度-6" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><p>O(1)</p><h4 id="返回值-6"><a href="#返回值-6" class="headerlink" title="返回值"></a>返回值</h4><p>如果 member 元素是集合的成员，返回 1 。<br>如果 member 元素不是集合的成员，或 key 不存在，返回 0 。</p><h4 id="示例-6"><a href="#示例-6" class="headerlink" title="示例"></a>示例</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">redis&gt; SMEMBERS joe&apos;s_movies</div><div class="line">1) &quot;hi, lady&quot;</div><div class="line">2) &quot;Fast Five&quot;</div><div class="line">3) &quot;2012&quot;</div><div class="line">redis&gt; SISMEMBER joe&apos;s_movies &quot;bet man&quot;</div><div class="line">(integer) 0</div><div class="line">redis&gt; SISMEMBER joe&apos;s_movies &quot;Fast Five&quot;</div><div class="line">(integer) 1</div></pre></td></tr></table></figure><h3 id="SMEMBERS"><a href="#SMEMBERS" class="headerlink" title="SMEMBERS"></a><strong>SMEMBERS</strong></h3><p><strong>SMEMBERS key</strong><br> 返回集合 key 中的所有成员。<br> 不存在的 key 被视为空集合。</p><h4 id="可用版本-7"><a href="#可用版本-7" class="headerlink" title="可用版本"></a>可用版本</h4><p>版本&gt;= 1.0.0</p><h4 id="时间复杂度-7"><a href="#时间复杂度-7" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><p>O(N)， N 为集合的基数。</p><h4 id="返回值-7"><a href="#返回值-7" class="headerlink" title="返回值"></a>返回值</h4><p>集合中的所有成员。</p><h4 id="示例-7"><a href="#示例-7" class="headerlink" title="示例"></a>示例</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"># key 不存在或集合为空</div><div class="line">redis&gt; EXISTS not_exists_key</div><div class="line">(integer) 0</div><div class="line">redis&gt; SMEMBERS not_exists_key</div><div class="line">(empty list or set)</div><div class="line"># 非空集合</div><div class="line">redis&gt; SADD language Ruby Python Clojure</div><div class="line">(integer) 3</div><div class="line">redis&gt; SMEMBERS language</div><div class="line">1) &quot;Python&quot;</div><div class="line">2) &quot;Ruby&quot;</div><div class="line">3) &quot;Clojure&quot;</div></pre></td></tr></table></figure><h3 id="SMOVE"><a href="#SMOVE" class="headerlink" title="SMOVE"></a><strong>SMOVE</strong></h3><p><strong>SMOVE source destination member</strong><br> 将 member 元素从 source 集合移动到 destination 集合。<br> SMOVE 是原子性操作。<br> 如果 source 集合不存在或不包含指定的 member 元素，则 SMOVE 命令不执行任何操作，仅返回 0 。否则， member 元素从 source 集合中被移除，并添加到 destination 集合中去。<br> 当 destination 集合已经包含 member 元素时， SMOVE 命令只是简单地将 source 集合中的 member 元素删除。<br> 当 source 或 destination 不是集合类型时，返回一个错误。</p><h4 id="可用版本-8"><a href="#可用版本-8" class="headerlink" title="可用版本"></a>可用版本</h4><p>版本&gt;= 1.0.0</p><h4 id="时间复杂度-8"><a href="#时间复杂度-8" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><p>O(1)</p><h4 id="返回值-8"><a href="#返回值-8" class="headerlink" title="返回值"></a>返回值</h4><p>如果 member 元素被成功移除，返回 1 。<br>如果 member 元素不是 source 集合的成员，并且没有任何操作对 destination 集合执行，那么返回 0 。</p><h4 id="示例-8"><a href="#示例-8" class="headerlink" title="示例"></a>示例</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">redis&gt; SMEMBERS songs</div><div class="line">1) &quot;Billie Jean&quot;</div><div class="line">2) &quot;Believe Me&quot;</div><div class="line">redis&gt; SMEMBERS my_songs</div><div class="line">(empty list or set)</div><div class="line">redis&gt; SMOVE songs my_songs &quot;Believe Me&quot;</div><div class="line">(integer) 1</div><div class="line">redis&gt; SMEMBERS songs</div><div class="line">1) &quot;Billie Jean&quot;</div><div class="line">redis&gt; SMEMBERS my_songs</div><div class="line">1) &quot;Believe Me&quot;</div></pre></td></tr></table></figure><h3 id="SPOP"><a href="#SPOP" class="headerlink" title="SPOP"></a><strong>SPOP</strong></h3><p><strong>SPOP key</strong><br> 移除并返回集合中的一个随机元素。<br> 如果只想获取一个随机元素，但不想该元素从集合中被移除的话，可以使用 SRANDMEMBER 命令。</p><h4 id="可用版本-9"><a href="#可用版本-9" class="headerlink" title="可用版本"></a>可用版本</h4><p>版本&gt;= 1.0.0</p><h4 id="时间复杂度-9"><a href="#时间复杂度-9" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><p>O(1)</p><h4 id="返回值-9"><a href="#返回值-9" class="headerlink" title="返回值"></a>返回值</h4><p>被移除的随机元素。<br>当 key 不存在或 key 是空集时，返回 nil 。</p><h4 id="示例-9"><a href="#示例-9" class="headerlink" title="示例"></a>示例</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">redis&gt; SMEMBERS db</div><div class="line">1) &quot;MySQL&quot;</div><div class="line">2) &quot;MongoDB&quot;</div><div class="line">3) &quot;Redis&quot;</div><div class="line">redis&gt; SPOP db</div><div class="line">&quot;Redis&quot;</div><div class="line">redis&gt; SMEMBERS db</div><div class="line">1) &quot;MySQL&quot;</div><div class="line">2) &quot;MongoDB&quot;</div><div class="line">redis&gt; SPOP db</div><div class="line">&quot;MySQL&quot;</div><div class="line">redis&gt; SMEMBERS db</div><div class="line">1) &quot;MongoDB&quot;</div></pre></td></tr></table></figure><h3 id="SRANDMEMBER"><a href="#SRANDMEMBER" class="headerlink" title="SRANDMEMBER"></a><strong>SRANDMEMBER</strong></h3><p><strong>SRANDMEMBER key [count]</strong></p><p> 如果命令执行时，只提供了 key 参数，那么返回集合中的一个随机元素。</p><p> 从 Redis 2.6 版本开始， SRANDMEMBER 命令接受可选的 count 参数：</p><ul><li>如果 count 为正数，且小于集合基数，那么命令返回一个包含 count 个元素的数组，数组中的元素各不相同。如果 count大于等于集合基数，那么返回整个集合。</li><li>如果 count 为负数，那么命令返回一个数组，数组中的元素可能会重复出现多次，而数组的长度为 count 的绝对值。</li></ul><p> 该操作和 SPOP 相似，但 SPOP 将随机元素从集合中移除并返回，而 SRANDMEMBER 则仅仅返回随机元素，而不对集合进行任何改动。</p><h4 id="可用版本-10"><a href="#可用版本-10" class="headerlink" title="可用版本"></a>可用版本</h4><p>版本&gt;= 1.0.0</p><h4 id="时间复杂度-10"><a href="#时间复杂度-10" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><p>只提供 key 参数时为 O(1) 。<br>如果提供了 count 参数，那么为 O(N) ，N 为返回数组的元素个数。</p><h4 id="返回值-10"><a href="#返回值-10" class="headerlink" title="返回值"></a>返回值</h4><p>只提供 key 参数时，返回一个元素；如果集合为空，返回 nil 。<br>如果提供了 count 参数，那么返回一个数组；如果集合为空，返回空数组。</p><h4 id="示例-10"><a href="#示例-10" class="headerlink" title="示例"></a>示例</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div></pre></td><td class="code"><pre><div class="line"># 添加元素</div><div class="line">redis&gt; SADD fruit apple banana cherry</div><div class="line">(integer) 3</div><div class="line"># 只给定 key 参数，返回一个随机元素</div><div class="line">redis&gt; SRANDMEMBER fruit</div><div class="line">&quot;cherry&quot;</div><div class="line">redis&gt; SRANDMEMBER fruit</div><div class="line">&quot;apple&quot;</div><div class="line"># 给定 3 为 count 参数，返回 3 个随机元素</div><div class="line"># 每个随机元素都不相同</div><div class="line">redis&gt; SRANDMEMBER fruit 3</div><div class="line">1) &quot;apple&quot;</div><div class="line">2) &quot;banana&quot;</div><div class="line">3) &quot;cherry&quot;</div><div class="line"># 给定 -3 为 count 参数，返回 3 个随机元素</div><div class="line"># 元素可能会重复出现多次</div><div class="line">redis&gt; SRANDMEMBER fruit -3</div><div class="line">1) &quot;banana&quot;</div><div class="line">2) &quot;cherry&quot;</div><div class="line">3) &quot;apple&quot;</div><div class="line">redis&gt; SRANDMEMBER fruit -3</div><div class="line">1) &quot;apple&quot;</div><div class="line">2) &quot;apple&quot;</div><div class="line">3) &quot;cherry&quot;</div><div class="line"># 如果 count 是整数，且大于等于集合基数，那么返回整个集合</div><div class="line">redis&gt; SRANDMEMBER fruit 10</div><div class="line">1) &quot;apple&quot;</div><div class="line">2) &quot;banana&quot;</div><div class="line">3) &quot;cherry&quot;</div><div class="line"># 如果 count 是负数，且 count 的绝对值大于集合的基数</div><div class="line"># 那么返回的数组的长度为 count 的绝对值</div><div class="line">redis&gt; SRANDMEMBER fruit -10</div><div class="line">1) &quot;banana&quot;</div><div class="line">2) &quot;apple&quot;</div><div class="line">3) &quot;banana&quot;</div><div class="line">4) &quot;cherry&quot;</div><div class="line">5) &quot;apple&quot;</div><div class="line">6) &quot;apple&quot;</div><div class="line">7) &quot;cherry&quot;</div><div class="line">8) &quot;apple&quot;</div><div class="line">9) &quot;apple&quot;</div><div class="line">10) &quot;banana&quot;</div><div class="line"># SRANDMEMBER 并不会修改集合内容</div><div class="line">redis&gt; SMEMBERS fruit</div><div class="line">1) &quot;apple&quot;</div><div class="line">2) &quot;cherry&quot;</div><div class="line">3) &quot;banana&quot;</div><div class="line"># 集合为空时返回 nil 或者空数组</div><div class="line">redis&gt; SRANDMEMBER not-exists</div><div class="line">(nil)</div><div class="line">redis&gt; SRANDMEMBER not-eixsts 10</div><div class="line">(empty list or set)</div></pre></td></tr></table></figure><h3 id="SREM"><a href="#SREM" class="headerlink" title="SREM"></a><strong>SREM</strong></h3><p><strong>SREM key member [member …]</strong><br> 移除集合 key 中的一个或多个 member 元素，不存在的 member 元素会被忽略。<br> 当 key 不是集合类型，返回一个错误。<br> 在 Redis 2.4 版本以前， SREM 只接受单个 member 值。</p><h4 id="可用版本-11"><a href="#可用版本-11" class="headerlink" title="可用版本"></a>可用版本</h4><p>版本&gt;= 1.0.0</p><h4 id="时间复杂度-11"><a href="#时间复杂度-11" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><p>O(N)， N 为给定 member 元素的数量。</p><h4 id="返回值-11"><a href="#返回值-11" class="headerlink" title="返回值"></a>返回值</h4><p>被成功移除的元素的数量，不包括被忽略的元素。</p><h4 id="示例-11"><a href="#示例-11" class="headerlink" title="示例"></a>示例</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"># 测试数据</div><div class="line">redis&gt; SMEMBERS languages</div><div class="line">1) &quot;c&quot;</div><div class="line">2) &quot;lisp&quot;</div><div class="line">3) &quot;python&quot;</div><div class="line">4) &quot;ruby&quot;</div><div class="line"># 移除单个元素</div><div class="line">redis&gt; SREM languages ruby</div><div class="line">(integer) 1</div><div class="line"># 移除不存在元素</div><div class="line">redis&gt; SREM languages non-exists-language</div><div class="line">(integer) 0</div><div class="line"># 移除多个元素</div><div class="line">redis&gt; SREM languages lisp python c</div><div class="line">(integer) 3</div><div class="line">redis&gt; SMEMBERS languages</div><div class="line">(empty list or set)</div></pre></td></tr></table></figure><h3 id="SUNION"><a href="#SUNION" class="headerlink" title="SUNION"></a><strong>SUNION</strong></h3><p><strong>SUNION key [key …]</strong><br> 返回一个集合的全部成员，该集合是所有给定集合的并集。<br> 不存在的 key 被视为空集。</p><h4 id="可用版本-12"><a href="#可用版本-12" class="headerlink" title="可用版本"></a>可用版本</h4><p>版本&gt;= 1.0.0</p><h4 id="时间复杂度-12"><a href="#时间复杂度-12" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><p>O(N)， N 是所有给定集合的成员数量之和。</p><h4 id="返回值-12"><a href="#返回值-12" class="headerlink" title="返回值"></a>返回值</h4><p>并集成员的列表。</p><h4 id="示例-12"><a href="#示例-12" class="headerlink" title="示例"></a>示例</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">redis&gt; SMEMBERS songs</div><div class="line">1) &quot;Billie Jean&quot;</div><div class="line">redis&gt; SMEMBERS my_songs</div><div class="line">1) &quot;Believe Me&quot;</div><div class="line">redis&gt; SUNION songs my_songs</div><div class="line">1) &quot;Billie Jean&quot;</div><div class="line">2) &quot;Believe Me&quot;</div></pre></td></tr></table></figure><h3 id="SUNIONSTORE"><a href="#SUNIONSTORE" class="headerlink" title="SUNIONSTORE"></a><strong>SUNIONSTORE</strong></h3><p><strong>SUNIONSTORE destination key [key …]</strong><br> 这个命令类似于 SUNION 命令，但它将结果保存到 destination 集合，而不是简单地返回结果集。<br> 如果 destination 已经存在，则将其覆盖。<br> destination 可以是 key 本身。</p><h4 id="可用版本-13"><a href="#可用版本-13" class="headerlink" title="可用版本"></a>可用版本</h4><p>版本&gt;= 1.0.0</p><h4 id="时间复杂度-13"><a href="#时间复杂度-13" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><p>O(N)， N 是所有给定集合的成员数量之和。</p><h4 id="返回值-13"><a href="#返回值-13" class="headerlink" title="返回值"></a>返回值</h4><p>结果集中的元素数量。</p><h4 id="示例-13"><a href="#示例-13" class="headerlink" title="示例"></a>示例</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">redis&gt; SMEMBERS NoSQL</div><div class="line">1) &quot;MongoDB&quot;</div><div class="line">2) &quot;Redis&quot;</div><div class="line">redis&gt; SMEMBERS SQL</div><div class="line">1) &quot;sqlite&quot;</div><div class="line">2) &quot;MySQL&quot;</div><div class="line">redis&gt; SUNIONSTORE db NoSQL SQL</div><div class="line">(integer) 4</div><div class="line">redis&gt; SMEMBERS db</div><div class="line">1) &quot;MySQL&quot;</div><div class="line">2) &quot;sqlite&quot;</div><div class="line">3) &quot;MongoDB&quot;</div><div class="line">4) &quot;Redis&quot;</div></pre></td></tr></table></figure><h3 id="SSCAN"><a href="#SSCAN" class="headerlink" title="SSCAN"></a><strong>SSCAN</strong></h3><p><strong>SSCAN key cursor [MATCH pattern] [COUNT count]</strong><br> 详细信息请参考 SCAN 命令。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Redis的集合和列表都可以存储多个字符串，它们之间的不同在于，列表可以存储多个不同的字符串，而集合则通过使用散列来保证自己存储的每个字符串都是各不相同的。包含字符串的无序收集器（unordered collection）,并且被包含的每个字符串都是独一无二、各不相同的。&lt;br&gt;结构的读写：&lt;br&gt; 添加、读取、移除单个元素&lt;br&gt; 检查一个元素是否存在于集合中&lt;br&gt; 计算交集、并集、差集&lt;br&gt; 从集合中随机获取元素&lt;br&gt;
    
    </summary>
    
      <category term="Redis" scheme="http://yoursite.com/categories/Redis/"/>
    
    
      <category term="Redis" scheme="http://yoursite.com/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Redis数据类型--SortedSet（有序集合）</title>
    <link href="http://yoursite.com/2017/03/06/Redis%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B--SortedSet%EF%BC%88%E6%9C%89%E5%BA%8F%E9%9B%86%E5%90%88%EF%BC%89/"/>
    <id>http://yoursite.com/2017/03/06/Redis数据类型--SortedSet（有序集合）/</id>
    <published>2017-03-06T13:02:25.000Z</published>
    <updated>2017-09-28T09:35:43.367Z</updated>
    
    <content type="html"><![CDATA[<p>有序集合和散列一样，都用于存储键值对：有序集合的键被称为成员（member），每个成员都是各不相同；而有序集合的值则被称为分值（score），分值必须为浮点数。有序集合是Redis里面唯一一个既可以根据成员访问元素（这一点和散列一样），又可以根据分值以及分值的排列顺序来访问元素的结构。字符串成员（member）与浮点数分值（score）之间的有序映射，元素的排列顺序由分值的大小决定。<br>结构的读写：<br> 添加、获取、删除单个元素<br> 根据分值范围（range）或者成员来获取元素<br><a id="more"></a></p><h3 id="ZADD"><a href="#ZADD" class="headerlink" title="ZADD"></a><strong>ZADD</strong></h3><p><strong>ZADD key score member [[score member] [score member] …]</strong></p><p> 将一个或多个 member 元素及其 score 值加入到有序集 key 当中。<br> 如果某个 member 已经是有序集的成员，那么更新这个 member 的 score 值，并通过重新插入这个 member 元素，来保证该 member 在正确的位置上。<br> score 值可以是整数值或双精度浮点数。<br> 如果 key 不存在，则创建一个空的有序集并执行 ZADD 操作。<br> 当 key 存在但不是有序集类型时，返回一个错误。<br> 在 Redis 2.4 版本以前， ZADD 每次只能添加一个元素。</p><h4 id="可用版本"><a href="#可用版本" class="headerlink" title="可用版本"></a>可用版本</h4><p>版本&gt;= 1.2.0</p><h4 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><p>O(M*log(N))， N 是有序集的基数， M 为成功添加的新成员的数量。</p><h4 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h4><p>被成功添加的新成员的数量，不包括那些被更新的、已经存在的成员。</p><h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"># 添加单个元素</div><div class="line">redis&gt; ZADD page_rank 10 google.com</div><div class="line">(integer) 1</div><div class="line"># 添加多个元素</div><div class="line">redis&gt; ZADD page_rank 9 baidu.com 8 bing.com</div><div class="line">(integer) 2</div><div class="line">redis&gt; ZRANGE page_rank 0 -1 WITHSCORES</div><div class="line">1) &quot;bing.com&quot;</div><div class="line">2) &quot;8&quot;</div><div class="line">3) &quot;baidu.com&quot;</div><div class="line">4) &quot;9&quot;</div><div class="line">5) &quot;google.com&quot;</div><div class="line">6) &quot;10&quot;</div><div class="line"># 添加已存在元素，且 score 值不变</div><div class="line">redis&gt; ZADD page_rank 10 google.com</div><div class="line">(integer) 0</div><div class="line">redis&gt; ZRANGE page_rank 0 -1 WITHSCORES  # 没有改变</div><div class="line">1) &quot;bing.com&quot;</div><div class="line">2) &quot;8&quot;</div><div class="line">3) &quot;baidu.com&quot;</div><div class="line">4) &quot;9&quot;</div><div class="line">5) &quot;google.com&quot;</div><div class="line">6) &quot;10&quot;</div><div class="line"># 添加已存在元素，但是改变 score 值</div><div class="line">redis&gt; ZADD page_rank 6 bing.com</div><div class="line">(integer) 0</div><div class="line">redis&gt; ZRANGE page_rank 0 -1 WITHSCORES  # bing.com 元素的 score 值被改变</div><div class="line">1) &quot;bing.com&quot;</div><div class="line">2) &quot;6&quot;</div><div class="line">3) &quot;baidu.com&quot;</div><div class="line">4) &quot;9&quot;</div><div class="line">5) &quot;google.com&quot;</div><div class="line">6) &quot;10&quot;</div></pre></td></tr></table></figure><h3 id="ZCARD"><a href="#ZCARD" class="headerlink" title="ZCARD"></a><strong>ZCARD</strong></h3><p><strong>ZCARD key</strong></p><p> 返回有序集 key 的基数。</p><h4 id="可用版本-1"><a href="#可用版本-1" class="headerlink" title="可用版本"></a>可用版本</h4><p>版本&gt;= 1.2.0</p><h4 id="时间复杂度-1"><a href="#时间复杂度-1" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><p>O(1)</p><h4 id="返回值-1"><a href="#返回值-1" class="headerlink" title="返回值"></a>返回值</h4><p>当 key 存在且是有序集类型时，返回有序集的基数。<br>当 key 不存在时，返回 0 。</p><h4 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">redis &gt; ZADD salary 2000 tom    # 添加一个成员</div><div class="line">(integer) 1</div><div class="line">redis &gt; ZCARD salary</div><div class="line">(integer) 1</div><div class="line">redis &gt; ZADD salary 5000 jack   # 再添加一个成员</div><div class="line">(integer) 1</div><div class="line">redis &gt; ZCARD salary</div><div class="line">(integer) 2</div><div class="line">redis &gt; EXISTS non_exists_key   # 对不存在的 key 进行 ZCARD 操作</div><div class="line">(integer) 0</div><div class="line">redis &gt; ZCARD non_exists_key</div><div class="line">(integer) 0</div></pre></td></tr></table></figure><h3 id="ZCOUNT"><a href="#ZCOUNT" class="headerlink" title="ZCOUNT"></a><strong>ZCOUNT</strong></h3><p><strong>ZCOUNT key min max</strong></p><p> 返回有序集 key 中， score 值在 min 和 max 之间(默认包括 score 值等于 min 或 max )的成员的数量。</p><h4 id="可用版本-2"><a href="#可用版本-2" class="headerlink" title="可用版本"></a>可用版本</h4><p>版本&gt;= 2.0.0</p><h4 id="时间复杂度-2"><a href="#时间复杂度-2" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><p>O(log(N)+M)， N 为有序集的基数， M 为值在 min 和 max 之间的元素的数量。</p><h4 id="返回值-2"><a href="#返回值-2" class="headerlink" title="返回值"></a>返回值</h4><p>score 值在 min 和 max 之间的成员的数量。</p><h4 id="示例-2"><a href="#示例-2" class="headerlink" title="示例"></a>示例</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">redis&gt; ZRANGE salary 0 -1 WITHSCORES    # 测试数据</div><div class="line">1) &quot;jack&quot;</div><div class="line">2) &quot;2000&quot;</div><div class="line">3) &quot;peter&quot;</div><div class="line">4) &quot;3500&quot;</div><div class="line">5) &quot;tom&quot;</div><div class="line">6) &quot;5000&quot;</div><div class="line">redis&gt; ZCOUNT salary 2000 5000          # 计算薪水在 2000-5000 之间的人数</div><div class="line">(integer) 3</div><div class="line">redis&gt; ZCOUNT salary 3000 5000          # 计算薪水在 3000-5000 之间的人数</div><div class="line">(integer) 2</div></pre></td></tr></table></figure><h3 id="ZINCRBY"><a href="#ZINCRBY" class="headerlink" title="ZINCRBY"></a><strong>ZINCRBY</strong></h3><p><strong>ZINCRBY key increment member</strong></p><p> 为有序集 key 的成员 member 的 score 值加上增量 increment 。<br> 可以通过传递一个负数值 increment ，让 score 减去相应的值，比如 ZINCRBY key -5 member ，就是让 member 的 score 值减去 5 。<br> 当 key 不存在，或 member 不是 key 的成员时， ZINCRBY key increment member 等同于 ZADD key increment member 。<br> 当 key 不是有序集类型时，返回一个错误。<br> score 值可以是整数值或双精度浮点数。</p><h4 id="可用版本-3"><a href="#可用版本-3" class="headerlink" title="可用版本"></a>可用版本</h4><p>版本&gt;= 1.2.0</p><h4 id="时间复杂度-3"><a href="#时间复杂度-3" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><p>O(log(N))</p><h4 id="返回值-3"><a href="#返回值-3" class="headerlink" title="返回值"></a>返回值</h4><p>member 成员的新 score 值，以字符串形式表示。</p><h4 id="示例-3"><a href="#示例-3" class="headerlink" title="示例"></a>示例</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">redis&gt; ZSCORE salary tom</div><div class="line">&quot;2000&quot;</div><div class="line">redis&gt; ZINCRBY salary 2000 tom   # tom 加薪啦！</div><div class="line">&quot;4000&quot;</div></pre></td></tr></table></figure><h3 id="ZRANGE"><a href="#ZRANGE" class="headerlink" title="ZRANGE"></a><strong>ZRANGE</strong></h3><p><strong>ZRANGE key start stop [WITHSCORES]</strong></p><p> 返回有序集 key 中，指定区间内的成员。<br> 其中成员的位置按 score 值递增(从小到大)来排序。<br> 具有相同 score 值的成员按字典序(lexicographical order )来排列。<br> 如果你需要成员按 score 值递减(从大到小)来排列，请使用 ZREVRANGE 命令。<br> 下标参数 start 和 stop 都以 0 为底，也就是说，以 0 表示有序集第一个成员，以 1 表示有序集第二个成员，以此类推。<br>你也可以使用负数下标，以 -1 表示最后一个成员， -2 表示倒数第二个成员，以此类推。<br> 超出范围的下标并不会引起错误。</p><ul><li>比如说，当 start 的值比有序集的最大下标还要大，或是 start &gt; stop 时， ZRANGE 命令只是简单地返回一个空列表。</li><li>另一方面，假如 stop 参数的值比有序集的最大下标还要大，那么 Redis 将 stop 当作最大下标来处理。</li></ul><p> 可以通过使用 WITHSCORES 选项，来让成员和它的 score 值一并返回，返回列表以 value1,score1, …, valueN,scoreN 的格式表示。<br> 客户端库可能会返回一些更复杂的数据类型，比如数组、元组等。</p><h4 id="可用版本-4"><a href="#可用版本-4" class="headerlink" title="可用版本"></a>可用版本</h4><p>版本&gt;= 1.2.0</p><h4 id="时间复杂度-4"><a href="#时间复杂度-4" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><p>O(log(N)+M)， N 为有序集的基数，而 M 为结果集的基数。</p><h4 id="返回值-4"><a href="#返回值-4" class="headerlink" title="返回值"></a>返回值</h4><p>指定区间内，带有 score 值(可选)的有序集成员的列表。</p><h4 id="示例-4"><a href="#示例-4" class="headerlink" title="示例"></a>示例</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">redis &gt; ZRANGE salary 0 -1 WITHSCORES             # 显示整个有序集成员</div><div class="line">1) &quot;jack&quot;</div><div class="line">2) &quot;3500&quot;</div><div class="line">3) &quot;tom&quot;</div><div class="line">4) &quot;5000&quot;</div><div class="line">5) &quot;boss&quot;</div><div class="line">6) &quot;10086&quot;</div><div class="line">redis &gt; ZRANGE salary 1 2 WITHSCORES              # 显示有序集下标区间 1 至 2 的成员</div><div class="line">1) &quot;tom&quot;</div><div class="line">2) &quot;5000&quot;</div><div class="line">3) &quot;boss&quot;</div><div class="line">4) &quot;10086&quot;</div><div class="line">redis &gt; ZRANGE salary 0 200000 WITHSCORES         # 测试 end 下标超出最大下标时的情况</div><div class="line">1) &quot;jack&quot;</div><div class="line">2) &quot;3500&quot;</div><div class="line">3) &quot;tom&quot;</div><div class="line">4) &quot;5000&quot;</div><div class="line">5) &quot;boss&quot;</div><div class="line">6) &quot;10086&quot;</div><div class="line">redis &gt; ZRANGE salary 200000 3000000 WITHSCORES   # 测试当给定区间不存在于有序集时的情况</div><div class="line">(empty list or set)</div></pre></td></tr></table></figure><h3 id="ZRANGEBYSCORE"><a href="#ZRANGEBYSCORE" class="headerlink" title="ZRANGEBYSCORE"></a><strong>ZRANGEBYSCORE</strong></h3><p><strong>ZRANGEBYSCORE key min max [WITHSCORES] [LIMIT offset count]</strong></p><p> 返回有序集 key 中，所有 score 值介于 min 和 max 之间(包括等于 min 或 max )的成员。有序集成员按 score 值递增(从小到大)次序排列。<br> 具有相同 score 值的成员按字典序(lexicographical order)来排列(该属性是有序集提供的，不需要额外的计算)。<br> 可选的 LIMIT 参数指定返回结果的数量及区间(就像SQL中的 SELECT LIMIT offset, count )，注意当 offset 很大时，定位 offset 的操作可能需要遍历整个有序集，此过程最坏复杂度为 O(N) 时间。<br> 可选的 WITHSCORES 参数决定结果集是单单返回有序集的成员，还是将有序集成员及其 score 值一起返回。<br> 该选项自 Redis 2.0 版本起可用。</p><p><strong>区间及无限</strong></p><p> min 和 max 可以是 -inf 和 +inf ，这样一来，你就可以在不知道有序集的最低和最高 score 值的情况下，使用 ZRANGEBYSCORE 这类命令。<br> 默认情况下，区间的取值使用闭区间 (小于等于或大于等于)，你也可以通过给参数前增加 ( 符号来使用可选的开区间 (小于或大于)。</p><p><strong>举个例子</strong></p><p> ZRANGEBYSCORE zset (1 5  返回所有符合条件 1 &lt; score &lt;= 5 的成员，而<br> ZRANGEBYSCORE zset (5 (10 则返回所有符合条件 5 &lt; score &lt; 10 的成员。</p><h4 id="可用版本-5"><a href="#可用版本-5" class="headerlink" title="可用版本"></a>可用版本</h4><p>版本&gt;= 1.0.5</p><h4 id="时间复杂度-5"><a href="#时间复杂度-5" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><p>O(log(N)+M)， N 为有序集的基数， M 为被结果集的基数。</p><h4 id="返回值-5"><a href="#返回值-5" class="headerlink" title="返回值"></a>返回值</h4><p>指定区间内，带有 score 值(可选)的有序集成员的列表。</p><h4 id="示例-5"><a href="#示例-5" class="headerlink" title="示例"></a>示例</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">redis&gt; ZADD salary 2500 jack                        # 测试数据</div><div class="line">(integer) 0</div><div class="line">redis&gt; ZADD salary 5000 tom</div><div class="line">(integer) 0</div><div class="line">redis&gt; ZADD salary 12000 peter</div><div class="line">(integer) 0</div><div class="line">redis&gt; ZRANGEBYSCORE salary -inf +inf               # 显示整个有序集</div><div class="line">1) &quot;jack&quot;</div><div class="line">2) &quot;tom&quot;</div><div class="line">3) &quot;peter&quot;</div><div class="line">redis&gt; ZRANGEBYSCORE salary -inf +inf WITHSCORES    # 显示整个有序集及成员的 score 值</div><div class="line">1) &quot;jack&quot;</div><div class="line">2) &quot;2500&quot;</div><div class="line">3) &quot;tom&quot;</div><div class="line">4) &quot;5000&quot;</div><div class="line">5) &quot;peter&quot;</div><div class="line">6) &quot;12000&quot;</div><div class="line">redis&gt; ZRANGEBYSCORE salary -inf 5000 WITHSCORES    # 显示工资 &lt;=5000 的所有成员</div><div class="line">1) &quot;jack&quot;</div><div class="line">2) &quot;2500&quot;</div><div class="line">3) &quot;tom&quot;</div><div class="line">4) &quot;5000&quot;</div><div class="line">redis&gt; ZRANGEBYSCORE salary (5000 400000            # 显示工资大于 5000 小于等于 400000 的成员</div><div class="line">1) &quot;peter&quot;</div></pre></td></tr></table></figure><h3 id="ZRANK"><a href="#ZRANK" class="headerlink" title="ZRANK"></a><strong>ZRANK</strong></h3><p><strong>ZRANK key member</strong></p><p> 返回有序集 key 中成员 member 的排名。其中有序集成员按 score 值递增(从小到大)顺序排列。<br> 排名以 0 为底，也就是说， score 值最小的成员排名为 0 。<br> 使用 ZREVRANK 命令可以获得成员按 score 值递减(从大到小)排列的排名。</p><h4 id="可用版本-6"><a href="#可用版本-6" class="headerlink" title="可用版本"></a>可用版本</h4><p>版本&gt;= 2.0.0</p><h4 id="时间复杂度-6"><a href="#时间复杂度-6" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><p>O(log(N))</p><h4 id="返回值-6"><a href="#返回值-6" class="headerlink" title="返回值"></a>返回值</h4><p>如果 member 是有序集 key 的成员，返回 member 的排名。<br>如果 member 不是有序集 key 的成员，返回 nil 。</p><h4 id="示例-6"><a href="#示例-6" class="headerlink" title="示例"></a>示例</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">redis&gt; ZRANGE salary 0 -1 WITHSCORES        # 显示所有成员及其 score 值</div><div class="line">1) &quot;peter&quot;</div><div class="line">2) &quot;3500&quot;</div><div class="line">3) &quot;tom&quot;</div><div class="line">4) &quot;4000&quot;</div><div class="line">5) &quot;jack&quot;</div><div class="line">6) &quot;5000&quot;</div><div class="line">redis&gt; ZRANK salary tom                     # 显示 tom 的薪水排名，第二</div><div class="line">(integer) 1</div></pre></td></tr></table></figure><h3 id="ZREM"><a href="#ZREM" class="headerlink" title="ZREM"></a><strong>ZREM</strong></h3><p><strong>ZREM key member [member …]</strong></p><p> 移除有序集 key 中的一个或多个成员，不存在的成员将被忽略。<br> 当 key 存在但不是有序集类型时，返回一个错误。<br> 在 Redis 2.4 版本以前， ZREM 每次只能删除一个元素。</p><h4 id="可用版本-7"><a href="#可用版本-7" class="headerlink" title="可用版本"></a>可用版本</h4><blockquote><p>= 1.2.0</p><h4 id="时间复杂度-7"><a href="#时间复杂度-7" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><p>O(M*log(N))， N 为有序集的基数， M 为被成功移除的成员的数量。</p><h4 id="返回值-7"><a href="#返回值-7" class="headerlink" title="返回值"></a>返回值</h4><p>被成功移除的成员的数量，不包括被忽略的成员。</p><h4 id="示例-7"><a href="#示例-7" class="headerlink" title="示例"></a>示例</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"># 测试数据</div><div class="line">redis&gt; ZRANGE page_rank 0 -1 WITHSCORES</div><div class="line">1) &quot;bing.com&quot;</div><div class="line">2) &quot;8&quot;</div><div class="line">3) &quot;baidu.com&quot;</div><div class="line">4) &quot;9&quot;</div><div class="line">5) &quot;google.com&quot;</div><div class="line">6) &quot;10&quot;</div><div class="line"># 移除单个元素</div><div class="line">redis&gt; ZREM page_rank google.com</div><div class="line">(integer) 1</div><div class="line">redis&gt; ZRANGE page_rank 0 -1 WITHSCORES</div><div class="line">1) &quot;bing.com&quot;</div><div class="line">2) &quot;8&quot;</div><div class="line">3) &quot;baidu.com&quot;</div><div class="line">4) &quot;9&quot;</div><div class="line"># 移除多个元素</div><div class="line">redis&gt; ZREM page_rank baidu.com bing.com</div><div class="line">(integer) 2</div><div class="line">redis&gt; ZRANGE page_rank 0 -1 WITHSCORES</div><div class="line">(empty list or set)</div><div class="line"># 移除不存在元素</div><div class="line">redis&gt; ZREM page_rank non-exists-element</div><div class="line">(integer) 0</div></pre></td></tr></table></figure></blockquote><h3 id="ZREMRANGEBYRANK"><a href="#ZREMRANGEBYRANK" class="headerlink" title="ZREMRANGEBYRANK"></a><strong>ZREMRANGEBYRANK</strong></h3><p><strong>ZREMRANGEBYRANK key start stop</strong></p><p> 移除有序集 key 中，指定排名(rank)区间内的所有成员。<br> 区间分别以下标参数 start 和 stop 指出，包含 start 和 stop 在内。<br> 下标参数 start 和 stop 都以 0 为底，也就是说，以 0 表示有序集第一个成员，以 1 表示有序集第二个成员，以此类推。<br> 你也可以使用负数下标，以 -1 表示最后一个成员， -2 表示倒数第二个成员，以此类推。</p><h4 id="可用版本-8"><a href="#可用版本-8" class="headerlink" title="可用版本"></a>可用版本</h4><p>版本&gt;= 2.0.0</p><h4 id="时间复杂度-8"><a href="#时间复杂度-8" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><p>O(log(N)+M)， N 为有序集的基数，而 M 为被移除成员的数量。</p><h4 id="返回值-8"><a href="#返回值-8" class="headerlink" title="返回值"></a>返回值</h4><p>被移除成员的数量。</p><h4 id="示例-8"><a href="#示例-8" class="headerlink" title="示例"></a>示例</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">redis&gt; ZADD salary 2000 jack</div><div class="line">(integer) 1</div><div class="line">redis&gt; ZADD salary 5000 tom</div><div class="line">(integer) 1</div><div class="line">redis&gt; ZADD salary 3500 peter</div><div class="line">(integer) 1</div><div class="line">redis&gt; ZREMRANGEBYRANK salary 0 1       # 移除下标 0 至 1 区间内的成员</div><div class="line">(integer) 2</div><div class="line">redis&gt; ZRANGE salary 0 -1 WITHSCORES    # 有序集只剩下一个成员</div><div class="line">1) &quot;tom&quot;</div><div class="line">2) &quot;5000&quot;</div></pre></td></tr></table></figure><h3 id="ZREMRANGEBYSCORE"><a href="#ZREMRANGEBYSCORE" class="headerlink" title="ZREMRANGEBYSCORE"></a><strong>ZREMRANGEBYSCORE</strong></h3><p><strong>ZREMRANGEBYSCORE key min max</strong></p><p> 移除有序集 key 中，所有 score 值介于 min 和 max 之间(包括等于 min 或 max )的成员。<br> 自版本2.1.6开始， score 值等于 min 或 max 的成员也可以不包括在内，详情请参见 ZRANGEBYSCORE 命令。</p><h4 id="可用版本-9"><a href="#可用版本-9" class="headerlink" title="可用版本"></a>可用版本</h4><p>版本&gt;= 1.2.0</p><h4 id="时间复杂度-9"><a href="#时间复杂度-9" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><p>O(log(N)+M)， N 为有序集的基数，而 M 为被移除成员的数量。</p><h4 id="返回值-9"><a href="#返回值-9" class="headerlink" title="返回值"></a>返回值</h4><p>被移除成员的数量。</p><h4 id="示例-9"><a href="#示例-9" class="headerlink" title="示例"></a>示例</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">redis&gt; ZRANGE salary 0 -1 WITHSCORES          # 显示有序集内所有成员及其 score 值</div><div class="line">1) &quot;tom&quot;</div><div class="line">2) &quot;2000&quot;</div><div class="line">3) &quot;peter&quot;</div><div class="line">4) &quot;3500&quot;</div><div class="line">5) &quot;jack&quot;</div><div class="line">6) &quot;5000&quot;</div><div class="line">redis&gt; ZREMRANGEBYSCORE salary 1500 3500      # 移除所有薪水在 1500 到 3500 内的员工</div><div class="line">(integer) 2</div><div class="line">redis&gt; ZRANGE salary 0 -1 WITHSCORES          # 剩下的有序集成员</div><div class="line">1) &quot;jack&quot;</div><div class="line">2) &quot;5000&quot;</div></pre></td></tr></table></figure><h3 id="ZREVRANGE"><a href="#ZREVRANGE" class="headerlink" title="ZREVRANGE"></a><strong>ZREVRANGE</strong></h3><p><strong>ZREVRANGE key start stop [WITHSCORES]</strong></p><p> 返回有序集 key 中，指定区间内的成员。<br> 其中成员的位置按 score 值递减(从大到小)来排列。<br> 具有相同 score 值的成员按字典序的逆序(reverse lexicographical order)排列。<br> 除了成员按 score 值递减的次序排列这一点外， ZREVRANGE 命令的其他方面和 ZRANGE 命令一样。</p><h4 id="可用版本-10"><a href="#可用版本-10" class="headerlink" title="可用版本"></a>可用版本</h4><p>版本&gt;= 1.2.0</p><h4 id="时间复杂度-10"><a href="#时间复杂度-10" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><p>O(log(N)+M)， N 为有序集的基数，而 M 为结果集的基数。</p><h4 id="返回值-10"><a href="#返回值-10" class="headerlink" title="返回值"></a>返回值</h4><p>指定区间内，带有 score 值(可选)的有序集成员的列表。</p><h4 id="示例-10"><a href="#示例-10" class="headerlink" title="示例"></a>示例</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">redis&gt; ZRANGE salary 0 -1 WITHSCORES        # 递增排列</div><div class="line">1) &quot;peter&quot;</div><div class="line">2) &quot;3500&quot;</div><div class="line">3) &quot;tom&quot;</div><div class="line">4) &quot;4000&quot;</div><div class="line">5) &quot;jack&quot;</div><div class="line">6) &quot;5000&quot;</div><div class="line">redis&gt; ZREVRANGE salary 0 -1 WITHSCORES     # 递减排列</div><div class="line">1) &quot;jack&quot;</div><div class="line">2) &quot;5000&quot;</div><div class="line">3) &quot;tom&quot;</div><div class="line">4) &quot;4000&quot;</div><div class="line">5) &quot;peter&quot;</div><div class="line">6) &quot;3500&quot;</div></pre></td></tr></table></figure><h3 id="ZREVRANGEBYSCORE"><a href="#ZREVRANGEBYSCORE" class="headerlink" title="ZREVRANGEBYSCORE"></a><strong>ZREVRANGEBYSCORE</strong></h3><p><strong>ZREVRANGEBYSCORE key max min [WITHSCORES] [LIMIT offset count]</strong></p><p> 返回有序集 key 中， score 值介于 max 和 min 之间(默认包括等于 max 或 min )的所有的成员。有序集成员按 score 值递减(从大到小)的次序排列。<br> 具有相同 score 值的成员按字典序的逆序(reverse lexicographical order )排列。<br> 除了成员按 score 值递减的次序排列这一点外， ZREVRANGEBYSCORE 命令的其他方面和 ZRANGEBYSCORE 命令一样。</p><h4 id="可用版本-11"><a href="#可用版本-11" class="headerlink" title="可用版本"></a>可用版本</h4><p>版本&gt;= 2.2.0</p><h4 id="时间复杂度-11"><a href="#时间复杂度-11" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><p>O(log(N)+M)， N 为有序集的基数， M 为结果集的基数。</p><h4 id="返回值-11"><a href="#返回值-11" class="headerlink" title="返回值"></a>返回值</h4><p>指定区间内，带有 score 值(可选)的有序集成员的列表。</p><h4 id="示例-11"><a href="#示例-11" class="headerlink" title="示例"></a>示例</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">redis &gt; ZADD salary 10086 jack</div><div class="line">(integer) 1</div><div class="line">redis &gt; ZADD salary 5000 tom</div><div class="line">(integer) 1</div><div class="line">redis &gt; ZADD salary 7500 peter</div><div class="line">(integer) 1</div><div class="line">redis &gt; ZADD salary 3500 joe</div><div class="line">(integer) 1</div><div class="line">redis &gt; ZREVRANGEBYSCORE salary +inf -inf   # 逆序排列所有成员</div><div class="line">1) &quot;jack&quot;</div><div class="line">2) &quot;peter&quot;</div><div class="line">3) &quot;tom&quot;</div><div class="line">4) &quot;joe&quot;</div><div class="line">redis &gt; ZREVRANGEBYSCORE salary 10000 2000  # 逆序排列薪水介于 10000 和 2000 之间的成员</div><div class="line">1) &quot;peter&quot;</div><div class="line">2) &quot;tom&quot;</div><div class="line">3) &quot;joe&quot;</div></pre></td></tr></table></figure><h3 id="ZREVRANK"><a href="#ZREVRANK" class="headerlink" title="ZREVRANK"></a><strong>ZREVRANK</strong></h3><p><strong>ZREVRANK key member</strong></p><p> 返回有序集 key 中成员 member 的排名。其中有序集成员按 score 值递减(从大到小)排序。<br> 排名以 0 为底，也就是说， score 值最大的成员排名为 0 。<br> 使用 ZRANK 命令可以获得成员按 score 值递增(从小到大)排列的排名。</p><h4 id="可用版本-12"><a href="#可用版本-12" class="headerlink" title="可用版本"></a>可用版本</h4><p>版本&gt;= 2.0.0</p><h4 id="时间复杂度-12"><a href="#时间复杂度-12" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><p>O(log(N))</p><h4 id="返回值-12"><a href="#返回值-12" class="headerlink" title="返回值"></a>返回值</h4><p>如果 member 是有序集 key 的成员，返回 member 的排名。<br>如果 member 不是有序集 key 的成员，返回 nil 。</p><h4 id="示例-12"><a href="#示例-12" class="headerlink" title="示例"></a>示例</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">redis 127.0.0.1:6379&gt; ZRANGE salary 0 -1 WITHSCORES     # 测试数据</div><div class="line">1) &quot;jack&quot;</div><div class="line">2) &quot;2000&quot;</div><div class="line">3) &quot;peter&quot;</div><div class="line">4) &quot;3500&quot;</div><div class="line">5) &quot;tom&quot;</div><div class="line">6) &quot;5000&quot;</div><div class="line">redis&gt; ZREVRANK salary peter     # peter 的工资排第二</div><div class="line">(integer) 1</div><div class="line">redis&gt; ZREVRANK salary tom       # tom 的工资最高</div><div class="line">(integer) 0</div></pre></td></tr></table></figure><h3 id="ZSCORE"><a href="#ZSCORE" class="headerlink" title="ZSCORE"></a><strong>ZSCORE</strong></h3><p><strong>ZSCORE key member</strong></p><p> 返回有序集 key 中，成员 member 的 score 值。<br> 如果 member 元素不是有序集 key 的成员，或 key 不存在，返回 nil 。</p><h4 id="可用版本-13"><a href="#可用版本-13" class="headerlink" title="可用版本"></a>可用版本</h4><p>版本&gt;= 1.2.0</p><h4 id="时间复杂度-13"><a href="#时间复杂度-13" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><p>O(1)</p><h4 id="返回值-13"><a href="#返回值-13" class="headerlink" title="返回值"></a>返回值</h4><p>member 成员的 score 值，以字符串形式表示。</p><h4 id="示例-13"><a href="#示例-13" class="headerlink" title="示例"></a>示例</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">redis&gt; ZRANGE salary 0 -1 WITHSCORES    # 测试数据</div><div class="line">1) &quot;tom&quot;</div><div class="line">2) &quot;2000&quot;</div><div class="line">3) &quot;peter&quot;</div><div class="line">4) &quot;3500&quot;</div><div class="line">5) &quot;jack&quot;</div><div class="line">6) &quot;5000&quot;</div><div class="line">redis&gt; ZSCORE salary peter              # 注意返回值是字符串</div><div class="line">&quot;3500&quot;</div></pre></td></tr></table></figure><h3 id="ZUNIONSTORE"><a href="#ZUNIONSTORE" class="headerlink" title="ZUNIONSTORE"></a><strong>ZUNIONSTORE</strong></h3><p><strong>ZUNIONSTORE destination numkeys key [key …] [WEIGHTS weight [weight …]] [AGGREGATE SUM|MIN|MAX]</strong></p><p> 计算给定的一个或多个有序集的并集，其中给定 key 的数量必须以 numkeys 参数指定，并将该并集(结果集)储存到 destination 。<br> 默认情况下，结果集中某个成员的 score 值是所有给定集下该成员 score 值之 和 。</p><p><strong>WEIGHTS</strong></p><p> 使用 WEIGHTS 选项，你可以为 每个 给定有序集 分别 指定一个乘法因子(multiplication factor)，每个给定有序集的所有成员的 score 值在传递给聚合函数(aggregation function)之前都要先乘以该有序集的因子。<br> 如果没有指定 WEIGHTS 选项，乘法因子默认设置为 1 。</p><p><strong>AGGREGATE</strong></p><p> 使用 AGGREGATE 选项，你可以指定并集的结果集的聚合方式。<br> 默认使用的参数 SUM ，可以将所有集合中某个成员的 score 值之 和 作为结果集中该成员的 score 值；使用参数 MIN ，可以将所有集合中某个成员的 最小 score 值作为结果集中该成员的 score 值；而参数 MAX 则是将所有集合中某个成员的 最大 score 值作为结果集中该成员的 score 值。</p><h4 id="可用版本-14"><a href="#可用版本-14" class="headerlink" title="可用版本"></a>可用版本</h4><p>版本&gt;= 2.0.0</p><h4 id="时间复杂度-14"><a href="#时间复杂度-14" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><p>O(N)+O(M log(M))， N 为给定有序集基数的总和， M 为结果集的基数。</p><h4 id="返回值-14"><a href="#返回值-14" class="headerlink" title="返回值"></a>返回值</h4><p>保存到 destination 的结果集的基数。</p><h4 id="示例-14"><a href="#示例-14" class="headerlink" title="示例"></a>示例</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">redis&gt; ZRANGE programmer 0 -1 WITHSCORES</div><div class="line">1) &quot;peter&quot;</div><div class="line">2) &quot;2000&quot;</div><div class="line">3) &quot;jack&quot;</div><div class="line">4) &quot;3500&quot;</div><div class="line">5) &quot;tom&quot;</div><div class="line">6) &quot;5000&quot;</div><div class="line">redis&gt; ZRANGE manager 0 -1 WITHSCORES</div><div class="line">1) &quot;herry&quot;</div><div class="line">2) &quot;2000&quot;</div><div class="line">3) &quot;mary&quot;</div><div class="line">4) &quot;3500&quot;</div><div class="line">5) &quot;bob&quot;</div><div class="line">6) &quot;4000&quot;</div><div class="line">redis&gt; ZUNIONSTORE salary 2 programmer manager WEIGHTS 1 3   # 公司决定加薪。。。除了程序员。。。</div><div class="line">(integer) 6</div><div class="line">redis&gt; ZRANGE salary 0 -1 WITHSCORES</div><div class="line">1) &quot;peter&quot;</div><div class="line">2) &quot;2000&quot;</div><div class="line">3) &quot;jack&quot;</div><div class="line">4) &quot;3500&quot;</div><div class="line">5) &quot;tom&quot;</div><div class="line">6) &quot;5000&quot;</div><div class="line">7) &quot;herry&quot;</div><div class="line">8) &quot;6000&quot;</div><div class="line">9) &quot;mary&quot;</div><div class="line">10) &quot;10500&quot;</div><div class="line">11) &quot;bob&quot;</div><div class="line">12) &quot;12000&quot;</div></pre></td></tr></table></figure><h3 id="ZINTERSTORE"><a href="#ZINTERSTORE" class="headerlink" title="ZINTERSTORE"></a><strong>ZINTERSTORE</strong></h3><p><strong>ZINTERSTORE destination numkeys key [key …] [WEIGHTS weight [weight …]] [AGGREGATE SUM|MIN|MAX]</strong></p><p> 计算给定的一个或多个有序集的交集，其中给定 key 的数量必须以 numkeys 参数指定，并将该交集(结果集)储存到 destination 。<br> 默认情况下，结果集中某个成员的 score 值是所有给定集下该成员 score 值之和.<br> 关于 WEIGHTS 和 AGGREGATE 选项的描述，参见 ZUNIONSTORE 命令。</p><h4 id="可用版本-15"><a href="#可用版本-15" class="headerlink" title="可用版本"></a>可用版本</h4><p>版本&gt;= 2.0.0</p><h4 id="时间复杂度-15"><a href="#时间复杂度-15" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><p>O(N<em>K)+O(M</em>log(M))， N 为给定 key 中基数最小的有序集， K 为给定有序集的数量， M 为结果集的基数。</p><h4 id="返回值-15"><a href="#返回值-15" class="headerlink" title="返回值"></a>返回值</h4><p>保存到 destination 的结果集的基数。</p><h4 id="示例-15"><a href="#示例-15" class="headerlink" title="示例"></a>示例</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">redis &gt; ZADD mid_test 70 &quot;Li Lei&quot;</div><div class="line">(integer) 1</div><div class="line">redis &gt; ZADD mid_test 70 &quot;Han Meimei&quot;</div><div class="line">(integer) 1</div><div class="line">redis &gt; ZADD mid_test 99.5 &quot;Tom&quot;</div><div class="line">(integer) 1</div><div class="line">redis &gt; ZADD fin_test 88 &quot;Li Lei&quot;</div><div class="line">(integer) 1</div><div class="line">redis &gt; ZADD fin_test 75 &quot;Han Meimei&quot;</div><div class="line">(integer) 1</div><div class="line">redis &gt; ZADD fin_test 99.5 &quot;Tom&quot;</div><div class="line">(integer) 1</div><div class="line">redis &gt; ZINTERSTORE sum_point 2 mid_test fin_test</div><div class="line">(integer) 3</div><div class="line">redis &gt; ZRANGE sum_point 0 -1 WITHSCORES     # 显示有序集内所有成员及其 score 值</div><div class="line">1) &quot;Han Meimei&quot;</div><div class="line">2) &quot;145&quot;</div><div class="line">3) &quot;Li Lei&quot;</div><div class="line">4) &quot;158&quot;</div><div class="line">5) &quot;Tom&quot;</div><div class="line">6) &quot;199&quot;</div></pre></td></tr></table></figure><h3 id="ZSCAN"><a href="#ZSCAN" class="headerlink" title="ZSCAN"></a><strong>ZSCAN</strong></h3><p><strong>ZSCAN key cursor [MATCH pattern] [COUNT count]</strong></p><p> 详细信息请参考 SCAN 命令。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;有序集合和散列一样，都用于存储键值对：有序集合的键被称为成员（member），每个成员都是各不相同；而有序集合的值则被称为分值（score），分值必须为浮点数。有序集合是Redis里面唯一一个既可以根据成员访问元素（这一点和散列一样），又可以根据分值以及分值的排列顺序来访问元素的结构。字符串成员（member）与浮点数分值（score）之间的有序映射，元素的排列顺序由分值的大小决定。&lt;br&gt;结构的读写：&lt;br&gt; 添加、获取、删除单个元素&lt;br&gt; 根据分值范围（range）或者成员来获取元素&lt;br&gt;
    
    </summary>
    
      <category term="Redis" scheme="http://yoursite.com/categories/Redis/"/>
    
    
      <category term="Redis" scheme="http://yoursite.com/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Redis数据类型--String（字符串）</title>
    <link href="http://yoursite.com/2017/03/06/Redis%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B--String%EF%BC%88%E5%AD%97%E7%AC%A6%E4%B8%B2%EF%BC%89/"/>
    <id>http://yoursite.com/2017/03/06/Redis数据类型--String（字符串）/</id>
    <published>2017-03-06T13:02:25.000Z</published>
    <updated>2017-09-28T09:36:40.330Z</updated>
    
    <content type="html"><![CDATA[<p>Redis的字符串和其他编程语言或者其他键值存储提供的字符串非常相似。一个key对应一个value。<br>string类型是二进制安全的，可以包含任何数据，比如jpg图片或者序列化的对象。从内部实现来看其实string可以看作byte数组，最大上限1G字节。<br>另外string类型可以被部分命令按int处理，比如incr等命令。<br>文档目前描述的内容以 Redis 2.8 版本为准。<br><a id="more"></a></p><h3 id="SET"><a href="#SET" class="headerlink" title="SET"></a><strong>SET</strong></h3><p><strong>SET key value [EX seconds] [PX milliseconds] [NX|XX]</strong><br> 将字符串值 value 关联到 key 。<br> 如果 key 已经持有其他值， SET 就覆写旧值，无视类型。<br> 对于某个原本带有生存时间（TTL）的键来说， 当 SET 命令成功在这个键上执行时， 这个键原有的 TTL 将被清除。</p><h4 id="可选参数"><a href="#可选参数" class="headerlink" title="可选参数"></a>可选参数</h4><p> <strong>EX second ：</strong>设置键的过期时间为 second 秒。 SET key value EX second 效果等同于 SETEX key second value 。<br> <strong>PX millisecond ：</strong>设置键的过期时间为 millisecond 毫秒。 SET key value PX millisecond 效果等同于 PSETEX key millisecond value 。<br> <strong>NX ：</strong>只在键不存在时，才对键进行设置操作。 SET key value NX 效果等同于 SETNX key value 。<br> <strong>XX ：</strong>只在键已经存在时，才对键进行设置操作。</p><h4 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h4><p> SET 在设置操作成功完成时，才返回 OK 。如果设置了 NX 或者 XX ，但因为条件没达到而造成设置操作未执行，那么命令返回空批量回复（NULL Bulk Reply）。</p><h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">127.0.0.1:6379&gt; SET key &quot;value&quot;</div><div class="line">OK</div><div class="line">127.0.0.1:6379&gt; SET key &quot;value1&quot; EX 10086 XX</div><div class="line">OK</div><div class="line">127.0.0.1:6379&gt; SET key &quot;value1&quot; PX 10086 NX</div><div class="line">(nil)</div></pre></td></tr></table></figure><h3 id="SETBIT"><a href="#SETBIT" class="headerlink" title="SETBIT"></a><strong>SETBIT</strong></h3><p><strong>SETBIT key offset value</strong><br> 对 key 所储存的字符串值，设置或清除指定偏移量上的位(bit)。<br> 位的设置或清除取决于 value 参数，可以是 0 也可以是 1 。<br> 当 key 不存在时，自动生成一个新的字符串值。<br> 字符串会进行伸展(grown)以确保它可以将 value 保存在指定的偏移量上。当字符串值进行伸展时，空白位置以 0 填充。<br> offset 参数必须大于或等于 0 ，小于 2^32 (bit 映射被限制在 512 MB 之内)。</p><h4 id="返回值-1"><a href="#返回值-1" class="headerlink" title="返回值"></a>返回值</h4><p>指定偏移量原来储存的位。</p><h4 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">127.0.0.1:6379&gt; SETBIT bit 50 1</div><div class="line">(integer) 0</div><div class="line">127.0.0.1:6379&gt; GETBIT bit 50</div><div class="line">(integer) 1</div><div class="line">127.0.0.1:6379&gt; GETBIT bit 40</div><div class="line">(integer) 0</div></pre></td></tr></table></figure><h3 id="SETEX"><a href="#SETEX" class="headerlink" title="SETEX"></a><strong>SETEX</strong></h3><p><strong>SETEX key seconds value</strong><br> 将值 value 关联到 key ，并将 key 的生存时间设为 seconds (以秒为单位)。<br> 如果 key 已经存在， SETEX 命令将覆写旧值。</p><h4 id="返回值-2"><a href="#返回值-2" class="headerlink" title="返回值"></a>返回值</h4><p>设置成功时返回 OK 。当 seconds 参数不合法时，返回一个错误。</p><h4 id="示例-2"><a href="#示例-2" class="headerlink" title="示例"></a>示例</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">127.0.0.1:6379&gt; SETEX key 50 &quot;value&quot;</div><div class="line">OK</div><div class="line">127.0.0.1:6379&gt; GET key</div><div class="line">&quot;value&quot;</div><div class="line">127.0.0.1:6379&gt; TTL key</div><div class="line">(integer) 29</div></pre></td></tr></table></figure><h3 id="SETNX"><a href="#SETNX" class="headerlink" title="SETNX"></a><strong>SETNX</strong></h3><p><strong>SETNX key value</strong><br> 将 key 的值设为 value ，当且仅当 key 不存在。<br> 若给定的 key 已经存在，则 SETNX 不做任何动作。<br> SETNX 是『SET if Not eXists』(如果不存在，则 SET)的简写。</p><h4 id="返回值-3"><a href="#返回值-3" class="headerlink" title="返回值"></a>返回值</h4><p>设置成功，返回 1 。设置失败，返回 0 。</p><h4 id="示例-3"><a href="#示例-3" class="headerlink" title="示例"></a>示例</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">127.0.0.1:6379&gt; SETNX key &quot;value&quot;</div><div class="line">(integer) 1</div><div class="line">127.0.0.1:6379&gt; SETNX key &quot;value1&quot;</div><div class="line">(integer) 0</div></pre></td></tr></table></figure><h3 id="SETRANGE"><a href="#SETRANGE" class="headerlink" title="SETRANGE"></a><strong>SETRANGE</strong></h3><p><strong>SETRANGE key offset value</strong><br> 用 value 参数覆写(overwrite)给定 key 所储存的字符串值，从偏移量 offset 开始。<br> 不存在的 key 当作空白字符串处理。<br> SETRANGE 命令会确保字符串足够长以便将 value 设置在指定的偏移量上，如果给定 key 原来储存的字符串长度比偏移量小(比如字符串只有 5 个字符长，但你设置的 offset 是 10 )，那么原字符和偏移量之间的空白将用零字节(zerobytes, “\x00” )来填充。<br> 注意你能使用的最大偏移量是 2^29-1(536870911) ，因为 Redis 字符串的大小被限制在 512 兆(megabytes)以内。如果你需要使用比这更大的空间，你可以使用多个 key 。</p><p><strong>注意：</strong>当生成一个很长的字符串时，Redis 需要分配内存空间，该操作有时候可能会造成服务器阻塞(block)。在2010年的Macbook Pro上，设置偏移量为 536870911(512MB 内存分配)，耗费约 300 毫秒， 设置偏移量为 134217728(128MB 内存分配)，耗费约 80 毫秒，设置偏移量 33554432(32MB 内存分配)，耗费约 30 毫秒，设置偏移量为 8388608(8MB 内存分配)，耗费约 8 毫秒。 注意若首次内存分配成功之后，再对同一个 key 调用 SETRANGE 操作，无须再重新内存。</p><h4 id="返回值-4"><a href="#返回值-4" class="headerlink" title="返回值"></a>返回值</h4><p>被 SETRANGE 修改之后，字符串的长度。</p><h4 id="示例-4"><a href="#示例-4" class="headerlink" title="示例"></a>示例</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">127.0.0.1:6379&gt; EXISTS empty_key</div><div class="line">(integer) 0</div><div class="line">127.0.0.1:6379&gt; SETRANGE empty_key 5 &quot;Redis!&quot;</div><div class="line">(integer) 11</div><div class="line">127.0.0.1:6379&gt; GET empty_key</div><div class="line">&quot;\x00\x00\x00\x00\x00Redis!&quot;</div><div class="line">127.0.0.1:6379&gt;</div></pre></td></tr></table></figure><h3 id="GET"><a href="#GET" class="headerlink" title="GET"></a><strong>GET</strong></h3><p><strong>GET key</strong><br> 返回 key 所关联的字符串值。<br> 如果 key 不存在那么返回特殊值 nil 。<br> 假如 key 储存的值不是字符串类型，返回一个错误，因为 GET 只能用于处理字符串值。</p><h4 id="返回值-5"><a href="#返回值-5" class="headerlink" title="返回值"></a>返回值</h4><p>当 key 不存在时，返回 nil ，否则，返回 key 的值。如果 key 不是字符串类型，那么返回一个错误。</p><h4 id="示例-5"><a href="#示例-5" class="headerlink" title="示例"></a>示例</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">127.0.0.1:6379&gt; SET key &quot;value&quot;</div><div class="line">OK</div><div class="line">127.0.0.1:6379&gt; GET key</div><div class="line">&quot;value&quot;</div></pre></td></tr></table></figure><h3 id="GETBIT"><a href="#GETBIT" class="headerlink" title="GETBIT"></a><strong>GETBIT</strong></h3><p><strong>GETBIT key offset</strong><br> 对 key 所储存的字符串值，获取指定偏移量上的位(bit)。<br> 当 offset 比字符串值的长度大，或者 key 不存在时，返回 0 。</p><h4 id="返回值-6"><a href="#返回值-6" class="headerlink" title="返回值"></a>返回值</h4><p>字符串值指定偏移量上的位(bit)。对不存在的 key 或者不存在的 offset 进行 GETBIT， 返回 0。</p><h4 id="示例-6"><a href="#示例-6" class="headerlink" title="示例"></a>示例</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">127.0.0.1:6379&gt; EXISTS bits</div><div class="line">(integer) 0</div><div class="line">127.0.0.1:6379&gt; GETBIT bits 100</div><div class="line">(integer) 0</div><div class="line">127.0.0.1:6379&gt; SETBIT bits 101 1</div><div class="line">(integer) 0</div><div class="line">127.0.0.1:6379&gt; GETBIT bits 101</div><div class="line">(integer) 1</div></pre></td></tr></table></figure><h3 id="GETRANGE"><a href="#GETRANGE" class="headerlink" title="GETRANGE"></a><strong>GETRANGE</strong></h3><p><strong>GETRANGE key start end</strong><br> 返回 key 中字符串值的子字符串，字符串的截取范围由 start 和 end 两个偏移量决定(包括 start 和 end 在内)。<br> 负数偏移量表示从字符串最后开始计数， -1 表示最后一个字符， -2 表示倒数第二个，以此类推。<br> GETRANGE 通过保证子字符串的值域(range)不超过实际字符串的值域来处理超出范围的值域请求。</p><h4 id="返回值-7"><a href="#返回值-7" class="headerlink" title="返回值"></a>返回值</h4><p>截取得出的子字符串。</p><h4 id="示例-7"><a href="#示例-7" class="headerlink" title="示例"></a>示例</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">127.0.0.1:6379&gt; SET greeting &quot;hello, my friend&quot;</div><div class="line">OK</div><div class="line">127.0.0.1:6379&gt; GETRANGE greeting 0 4          # 返回索引0-4的字符，包括4。</div><div class="line">&quot;hello&quot;</div><div class="line">127.0.0.1:6379&gt; GETRANGE greeting -1 -5        # 不支持回绕操作</div><div class="line">&quot;&quot;</div><div class="line">127.0.0.1:6379&gt; GETRANGE greeting -3 -1        # 负数索引</div><div class="line">&quot;end&quot;</div><div class="line">127.0.0.1:6379&gt; GETRANGE greeting 0 -1         # 从第一个到最后一个</div><div class="line">&quot;hello, my friend&quot;</div><div class="line">127.0.0.1:6379&gt; GETRANGE greeting 0 1008611    # 值域超出部分被符略</div><div class="line">&quot;hello, my friend&quot;</div></pre></td></tr></table></figure><h3 id="GETSET"><a href="#GETSET" class="headerlink" title="GETSET"></a><strong>GETSET</strong></h3><p><strong>GETSET key value</strong><br> 将给定 key 的值设为 value ，并返回 key 的旧值(old value)。<br> 当 key 存在但不是字符串类型时，返回一个错误。</p><h4 id="可用版本"><a href="#可用版本" class="headerlink" title="可用版本"></a>可用版本</h4><p>   版本&gt;= 1.0.0</p><h4 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><p>O(1)</p><h4 id="返回值-8"><a href="#返回值-8" class="headerlink" title="返回值"></a>返回值</h4><p> 返回给定 key 的旧值。<br> 当 key 没有旧值时，也即是， key 不存在时，返回 nil 。</p><h4 id="示例-8"><a href="#示例-8" class="headerlink" title="示例"></a>示例</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">redis&gt; GETSET db mongodb    # 没有旧值，返回 nil</div><div class="line">(nil)</div><div class="line">redis&gt; GET db</div><div class="line">&quot;mongodb&quot;</div><div class="line">redis&gt; GETSET db redis      # 返回旧值 mongodb</div><div class="line">&quot;mongodb&quot;</div><div class="line">redis&gt; GET db</div><div class="line">&quot;redis&quot;</div></pre></td></tr></table></figure><h3 id="APPEND"><a href="#APPEND" class="headerlink" title="APPEND"></a><strong>APPEND</strong></h3><p><strong>APPEND key value</strong><br> 如果 key 已经存在并且是一个字符串， APPEND 命令将 value 追加到 key 原来的值的末尾。<br> 如果 key 不存在， APPEND 就简单地将给定 key 设为 value ，就像执行 SET key value 一样。</p><h4 id="可用版本-1"><a href="#可用版本-1" class="headerlink" title="可用版本"></a>可用版本</h4><blockquote><p>= 2.0.0</p><h4 id="时间复杂度-1"><a href="#时间复杂度-1" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><p>平摊O(1)</p><h4 id="返回值-9"><a href="#返回值-9" class="headerlink" title="返回值"></a>返回值</h4><p>追加 value 之后， key 中字符串的长度。</p></blockquote><h4 id="示例-9"><a href="#示例-9" class="headerlink" title="示例"></a>示例</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"># 对不存在的 key 执行 APPEND</div><div class="line">redis&gt; EXISTS myphone               # 确保 myphone 不存在</div><div class="line">(integer) 0</div><div class="line">redis&gt; APPEND myphone &quot;nokia&quot;       # 对不存在的 key 进行 APPEND  ，等同于 SET myphone &quot;nokia&quot;</div><div class="line">(integer) 5                         # 字符长度</div><div class="line"># 对已存在的字符串进行 APPEND</div><div class="line">redis&gt; APPEND myphone &quot; - 1110&quot;     # 长度从 5 个字符增加到 12 个字符</div><div class="line">(integer) 12</div><div class="line">redis&gt; GET myphone</div><div class="line">&quot;nokia - 1110&quot;</div></pre></td></tr></table></figure><h3 id="BITCOUNT"><a href="#BITCOUNT" class="headerlink" title="BITCOUNT"></a><strong>BITCOUNT</strong></h3><p><strong>BITCOUNT key [start] [end]</strong><br> 计算给定字符串中，被设置为 1 的比特位的数量。<br> 一般情况下，给定的整个字符串都会被进行计数，通过指定额外的 start 或 end 参数，可以让计数只在特定的位上进行。<br> start 和 end 参数的设置和 GETRANGE 命令类似，都可以使用负数值：比如 -1 表示最后一个位，而 -2 表示倒数第二个位，以此类推。<br> 不存在的 key 被当成是空字符串来处理，因此对一个不存在的 key 进行 BITCOUNT 操作，结果为 0 。</p><h4 id="可用版本-2"><a href="#可用版本-2" class="headerlink" title="可用版本"></a>可用版本</h4><p>版本&gt;= 2.6.0</p><h4 id="时间复杂度-2"><a href="#时间复杂度-2" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><p>O(N)</p><h4 id="返回值-10"><a href="#返回值-10" class="headerlink" title="返回值"></a>返回值</h4><p>被设置为 1 的位的数量。</p><h4 id="示例-10"><a href="#示例-10" class="headerlink" title="示例"></a>示例</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">redis&gt; BITCOUNT bits</div><div class="line">(integer) 0</div><div class="line">redis&gt; SETBIT bits 0 1          # 0001</div><div class="line">(integer) 0</div><div class="line">redis&gt; BITCOUNT bits</div><div class="line">(integer) 1</div><div class="line">redis&gt; SETBIT bits 3 1          # 1001</div><div class="line">(integer) 0</div><div class="line">redis&gt; BITCOUNT bits</div><div class="line">(integer) 2</div></pre></td></tr></table></figure><h3 id="BITOP"><a href="#BITOP" class="headerlink" title="BITOP"></a><strong>BITOP</strong></h3><p><strong>BITOP operation destkey key [key …]</strong><br> 对一个或多个保存二进制位的字符串 key 进行位元操作，并将结果保存到 destkey 上。<br> operation 可以是 AND 、 OR 、 NOT 、 XOR 这四种操作中的任意一种：</p><ul><li>BITOP AND destkey key [key …] ，对一个或多个 key 求逻辑并，并将结果保存到 destkey 。</li><li>BITOP OR destkey key [key …] ，对一个或多个 key 求逻辑或，并将结果保存到 destkey 。</li><li>BITOP XOR destkey key [key …] ，对一个或多个 key 求逻辑异或，并将结果保存到 destkey 。</li><li>BITOP NOT destkey key ，对给定 key 求逻辑非，并将结果保存到 destkey 。</li></ul><p> 除了 NOT 操作之外，其他操作都可以接受一个或多个 key 作为输入。</p><h4 id="处理不同长度的字符串"><a href="#处理不同长度的字符串" class="headerlink" title="处理不同长度的字符串"></a>处理不同长度的字符串</h4><p>当 BITOP 处理不同长度的字符串时，较短的那个字符串所缺少的部分会被看作 0 。空的 key 也被看作是包含 0 的字符串序列。</p><h4 id="可用版本-3"><a href="#可用版本-3" class="headerlink" title="可用版本"></a>可用版本</h4><p>版本&gt;= 2.6.0</p><h4 id="时间复杂度-3"><a href="#时间复杂度-3" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><p>O(N)</p><h4 id="返回值-11"><a href="#返回值-11" class="headerlink" title="返回值"></a>返回值</h4><p>保存到 destkey 的字符串的长度，和输入 key 中最长的字符串长度相等。</p><p><strong>注意：</strong> BITOP 的复杂度为 O(N) ，当处理大型矩阵(matrix)或者进行大数据量的统计时，最好将任务指派到附属节点(slave)进行，避免阻塞主节点。</p><h4 id="示例-11"><a href="#示例-11" class="headerlink" title="示例"></a>示例</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">redis&gt; SETBIT bits-1 0 1        # bits-1 = 1001</div><div class="line">(integer) 0</div><div class="line">redis&gt; SETBIT bits-1 3 1</div><div class="line">(integer) 0</div><div class="line">redis&gt; SETBIT bits-2 0 1        # bits-2 = 1011</div><div class="line">(integer) 0</div><div class="line">redis&gt; SETBIT bits-2 1 1</div><div class="line">(integer) 0</div><div class="line">redis&gt; SETBIT bits-2 3 1</div><div class="line">(integer) 0</div><div class="line">redis&gt; BITOP AND and-result bits-1 bits-2</div><div class="line">(integer) 1</div><div class="line">redis&gt; GETBIT and-result 0      # and-result = 1001</div><div class="line">(integer) 1</div><div class="line">redis&gt; GETBIT and-result 1</div><div class="line">(integer) 0</div><div class="line">redis&gt; GETBIT and-result 2</div><div class="line">(integer) 0</div><div class="line">redis&gt; GETBIT and-result 3</div><div class="line">(integer) 1</div></pre></td></tr></table></figure><h3 id="DECR"><a href="#DECR" class="headerlink" title="DECR"></a><strong>DECR</strong></h3><p><strong>DECR key</strong><br> 将 key 中储存的数字值减一。<br> 如果 key 不存在，那么 key 的值会先被初始化为 0 ，然后再执行 DECR 操作。<br> 如果值包含错误的类型，或字符串类型的值不能表示为数字，那么返回一个错误。<br> 本操作的值限制在 64 位(bit)有符号数字表示之内。</p><h4 id="可用版本-4"><a href="#可用版本-4" class="headerlink" title="可用版本"></a>可用版本</h4><p>版本&gt;= 1.0.0</p><h4 id="时间复杂度-4"><a href="#时间复杂度-4" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><p>O(1)</p><h4 id="返回值-12"><a href="#返回值-12" class="headerlink" title="返回值"></a>返回值</h4><p>执行 DECR 命令之后 key 的值。</p><h4 id="示例-12"><a href="#示例-12" class="headerlink" title="示例"></a>示例</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"># 对存在的数字值 key 进行 DECR</div><div class="line">redis&gt; SET failure_times 10</div><div class="line">OK</div><div class="line">redis&gt; DECR failure_times</div><div class="line">(integer) 9</div><div class="line"># 对不存在的 key 值进行 DECR</div><div class="line">redis&gt; EXISTS count</div><div class="line">(integer) 0</div><div class="line">redis&gt; DECR count</div><div class="line">(integer) -1</div><div class="line"># 对存在但不是数值的 key 进行 DECR</div><div class="line">redis&gt; SET company YOUR_CODE_SUCKS.LLC</div><div class="line">OK</div><div class="line">redis&gt; DECR company</div><div class="line">(error) ERR value is not an integer or out of range</div></pre></td></tr></table></figure><h3 id="DECRBY"><a href="#DECRBY" class="headerlink" title="DECRBY"></a><strong>DECRBY</strong></h3><p><strong>DECRBY key decrement</strong><br> 将 key 所储存的值减去减量 decrement 。<br> 如果 key 不存在，那么 key 的值会先被初始化为 0 ，然后再执行 DECRBY 操作。<br> 如果值包含错误的类型，或字符串类型的值不能表示为数字，那么返回一个错误。<br> 本操作的值限制在 64 位(bit)有符号数字表示之内。</p><h4 id="可用版本-5"><a href="#可用版本-5" class="headerlink" title="可用版本"></a>可用版本</h4><p>版本&gt;= 1.0.0</p><h4 id="时间复杂度-5"><a href="#时间复杂度-5" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><p>O(1)</p><h4 id="返回值-13"><a href="#返回值-13" class="headerlink" title="返回值"></a>返回值</h4><p>减去 decrement 之后， key 的值。</p><h3 id="示例-13"><a href="#示例-13" class="headerlink" title="示例"></a>示例</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"># 对已存在的 key 进行 DECRBY</div><div class="line">redis&gt; SET count 100</div><div class="line">OK</div><div class="line">redis&gt; DECRBY count 20</div><div class="line">(integer) 80</div><div class="line"># 对不存在的 key 进行DECRBY</div><div class="line">redis&gt; EXISTS pages</div><div class="line">(integer) 0</div><div class="line">redis&gt; DECRBY pages 10</div><div class="line">(integer) -10</div></pre></td></tr></table></figure><h3 id="INCR"><a href="#INCR" class="headerlink" title="INCR"></a><strong>INCR</strong></h3><p><strong>INCR key</strong><br> 将 key 中储存的数字值增一。<br> 如果 key 不存在，那么 key 的值会先被初始化为 0 ，然后再执行 INCR 操作。<br> 如果值包含错误的类型，或字符串类型的值不能表示为数字，那么返回一个错误。<br> 本操作的值限制在 64 位(bit)有符号数字表示之内。</p><p><strong>注意：</strong>这是一个针对字符串的操作，因为 Redis 没有专用的整数类型，所以 key 内储存的字符串被解释为十进制 64 位有符号整数来执行 INCR 操作。</p><h4 id="可用版本-6"><a href="#可用版本-6" class="headerlink" title="可用版本"></a>可用版本</h4><p>版本&gt;= 1.0.0</p><h4 id="时间复杂度-6"><a href="#时间复杂度-6" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><p>O(1)</p><h4 id="返回值-14"><a href="#返回值-14" class="headerlink" title="返回值"></a>返回值</h4><p>执行 INCR 命令之后 key 的值。</p><h4 id="示例-14"><a href="#示例-14" class="headerlink" title="示例"></a>示例</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">redis&gt; SET page_view 20</div><div class="line">OK</div><div class="line">redis&gt; INCR page_view</div><div class="line">(integer) 21</div><div class="line">redis&gt; GET page_view    # 数字值在 Redis 中以字符串的形式保存</div><div class="line">&quot;21&quot;</div></pre></td></tr></table></figure><h3 id="INCRBY"><a href="#INCRBY" class="headerlink" title="INCRBY"></a><strong>INCRBY</strong></h3><p><strong>INCRBY key increment</strong><br> 将 key 所储存的值加上增量 increment 。<br> 如果 key 不存在，那么 key 的值会先被初始化为 0 ，然后再执行 INCRBY 命令。<br> 如果值包含错误的类型，或字符串类型的值不能表示为数字，那么返回一个错误。<br> 本操作的值限制在 64 位(bit)有符号数字表示之内。</p><h4 id="可用版本-7"><a href="#可用版本-7" class="headerlink" title="可用版本"></a>可用版本</h4><p>版本&gt;= 1.0.0</p><h4 id="时间复杂度-7"><a href="#时间复杂度-7" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><p>O(1)</p><h4 id="返回值-15"><a href="#返回值-15" class="headerlink" title="返回值"></a>返回值</h4><p>加上 increment 之后， key 的值。</p><h4 id="示例-15"><a href="#示例-15" class="headerlink" title="示例"></a>示例</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"># key 存在且是数字值</div><div class="line">redis&gt; SET rank 50</div><div class="line">OK</div><div class="line">redis&gt; INCRBY rank 20</div><div class="line">(integer) 70</div><div class="line">redis&gt; GET rank</div><div class="line">&quot;70&quot;</div><div class="line"># key 不存在时</div><div class="line">redis&gt; EXISTS counter</div><div class="line">(integer) 0</div><div class="line">redis&gt; INCRBY counter 30</div><div class="line">(integer) 30</div><div class="line">redis&gt; GET counter</div><div class="line">&quot;30&quot;</div><div class="line"># key 不是数字值时</div><div class="line">redis&gt; SET book &quot;long long ago...&quot;</div><div class="line">OK</div><div class="line">redis&gt; INCRBY book 200</div><div class="line">(error) ERR value is not an integer or out of range</div></pre></td></tr></table></figure><h3 id="INCRBYFLOAT"><a href="#INCRBYFLOAT" class="headerlink" title="INCRBYFLOAT"></a><strong>INCRBYFLOAT</strong></h3><p><strong>INCRBYFLOAT key increment</strong><br> 为 key 中所储存的值加上浮点数增量 increment 。<br> 如果 key 不存在，那么 INCRBYFLOAT 会先将 key 的值设为 0 ，再执行加法操作。<br> 如果命令执行成功，那么 key 的值会被更新为（执行加法之后的）新值，并且新值会以字符串的形式返回给调用者。<br> 无论是 key 的值，还是增量 increment ，都可以使用像 2.0e7 、 3e5 、 90e-2 那样的指数符号(exponential notation)来表示，但是，执行 INCRBYFLOAT 命令之后的值总是以同样的形式储存，也即是，它们总是由一个数字，一个（可选的）小数点和一个任意位的小数部分组成（比如 3.14 、 69.768 ，诸如此类)，小数部分尾随的 0 会被移除，如果有需要的话，还会将浮点数改为整数（比如 3.0 会被保存成 3 ）。<br> 除此之外，无论加法计算所得的浮点数的实际精度有多长， INCRBYFLOAT 的计算结果也最多只能表示小数点的后十七位。</p><p>当以下任意一个条件发生时，返回一个错误：</p><ul><li>key 的值不是字符串类型(因为 Redis 中的数字和浮点数都以字符串的形式保存，所以它们都属于字符串类型）</li><li>key 当前的值或者给定的增量 increment 不能解释(parse)为双精度浮点数(double precision floating point number）</li></ul><h4 id="可用版本-8"><a href="#可用版本-8" class="headerlink" title="可用版本"></a>可用版本</h4><p>版本&gt;= 2.6.0</p><h4 id="时间复杂度-8"><a href="#时间复杂度-8" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><p>O(1)</p><h4 id="返回值-16"><a href="#返回值-16" class="headerlink" title="返回值"></a>返回值</h4><p>执行命令之后 key 的值。</p><h4 id="示例-16"><a href="#示例-16" class="headerlink" title="示例"></a>示例</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"># 值和增量都不是指数符号</div><div class="line">redis&gt; SET mykey 10.50</div><div class="line">OK</div><div class="line">redis&gt; INCRBYFLOAT mykey 0.1</div><div class="line">&quot;10.6&quot;</div><div class="line"># 值和增量都是指数符号</div><div class="line">redis&gt; SET mykey 314e-2</div><div class="line">OK</div><div class="line">redis&gt; GET mykey                # 用 SET 设置的值可以是指数符号</div><div class="line">&quot;314e-2&quot;</div><div class="line">redis&gt; INCRBYFLOAT mykey 0      # 但执行 INCRBYFLOAT 之后格式会被改成非指数符号</div><div class="line">&quot;3.14&quot;</div><div class="line"># 可以对整数类型执行</div><div class="line">redis&gt; SET mykey 3</div><div class="line">OK</div><div class="line">redis&gt; INCRBYFLOAT mykey 1.1</div><div class="line">&quot;4.1&quot;</div><div class="line"># 后跟的 0 会被移除</div><div class="line">redis&gt; SET mykey 3.0</div><div class="line">OK</div><div class="line">redis&gt; GET mykey                                    # SET 设置的值小数部分可以是 0</div><div class="line">&quot;3.0&quot;</div><div class="line">redis&gt; INCRBYFLOAT mykey 1.000000000000000000000    # 但 INCRBYFLOAT 会将无用的 0 忽略掉，有需要的话，将浮点变为整数</div><div class="line">&quot;4&quot;</div><div class="line">redis&gt; GET mykey</div><div class="line">&quot;4&quot;</div></pre></td></tr></table></figure><h3 id="MGET"><a href="#MGET" class="headerlink" title="MGET"></a><strong>MGET</strong></h3><p><strong>MGET key [key …]</strong><br> 返回所有(一个或多个)给定 key 的值。<br> 如果给定的 key 里面，有某个 key 不存在，那么这个 key 返回特殊值 nil 。因此，该命令永不失败。</p><h4 id="可用版本-9"><a href="#可用版本-9" class="headerlink" title="可用版本"></a>可用版本</h4><p>版本&gt;= 1.0.0</p><h4 id="时间复杂度-9"><a href="#时间复杂度-9" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><p>O(N) , N 为给定 key 的数量。</p><h4 id="返回值-17"><a href="#返回值-17" class="headerlink" title="返回值"></a>返回值</h4><p>一个包含所有给定 key 的值的列表。</p><h4 id="示例-17"><a href="#示例-17" class="headerlink" title="示例"></a>示例</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">redis&gt; SET redis redis.com</div><div class="line">OK</div><div class="line">redis&gt; SET mongodb mongodb.org</div><div class="line">OK</div><div class="line">redis&gt; MGET redis mongodb</div><div class="line">1) &quot;redis.com&quot;</div><div class="line">2) &quot;mongodb.org&quot;</div><div class="line">redis&gt; MGET redis mongodb mysql     # 不存在的 mysql 返回 nil</div><div class="line">1) &quot;redis.com&quot;</div><div class="line">2) &quot;mongodb.org&quot;</div><div class="line">3) (nil)</div></pre></td></tr></table></figure><h3 id="MSET"><a href="#MSET" class="headerlink" title="MSET"></a><strong>MSET</strong></h3><p><strong>MSET key value [key value …]</strong><br> 同时设置一个或多个 key-value 对。<br> 如果某个给定 key 已经存在，那么 MSET 会用新值覆盖原来的旧值，如果这不是你所希望的效果，请考虑使用 MSETNX 命令：它只会在所有给定 key 都不存在的情况下进行设置操作。<br> MSET 是一个原子性(atomic)操作，所有给定 key 都会在同一时间内被设置，某些给定 key 被更新而另一些给定 key 没有改变的情况，不可能发生。</p><h4 id="可用版本-10"><a href="#可用版本-10" class="headerlink" title="可用版本"></a>可用版本</h4><p>版本&gt;= 1.0.1</p><h4 id="时间复杂度-10"><a href="#时间复杂度-10" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><p>O(N)， N 为要设置的 key 数量。</p><h4 id="返回值-18"><a href="#返回值-18" class="headerlink" title="返回值"></a>返回值</h4><p>总是返回 OK (因为 MSET 不可能失败)</p><h4 id="示例-18"><a href="#示例-18" class="headerlink" title="示例"></a>示例</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">redis&gt; MSET date &quot;2012.3.30&quot; time &quot;11:00 a.m.&quot; weather &quot;sunny&quot;</div><div class="line">OK</div><div class="line">redis&gt; MGET date time weather</div><div class="line">1) &quot;2012.3.30&quot;</div><div class="line">2) &quot;11:00 a.m.&quot;</div><div class="line">3) &quot;sunny&quot;</div><div class="line"># MSET 覆盖旧值例子</div><div class="line">redis&gt; SET google &quot;google.hk&quot;</div><div class="line">OK</div><div class="line">redis&gt; MSET google &quot;google.com&quot;</div><div class="line">OK</div><div class="line">redis&gt; GET google</div><div class="line">&quot;google.com&quot;</div></pre></td></tr></table></figure><h3 id="MSETNX"><a href="#MSETNX" class="headerlink" title="MSETNX"></a><strong>MSETNX</strong></h3><p><strong>MSETNX key value [key value …]</strong><br> 同时设置一个或多个 key-value 对，当且仅当所有给定 key 都不存在。<br> 即使只有一个给定 key 已存在， MSETNX 也会拒绝执行所有给定 key 的设置操作。<br> MSETNX 是原子性的，因此它可以用作设置多个不同 key 表示不同字段(field)的唯一性逻辑对象(unique logic object)，所有字段要么全被设置，要么全不被设置。</p><h4 id="可用版本-11"><a href="#可用版本-11" class="headerlink" title="可用版本"></a>可用版本</h4><p>版本&gt;= 1.0.1</p><h4 id="时间复杂度-11"><a href="#时间复杂度-11" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><p>O(N)， N 为要设置的 key 的数量。</p><h4 id="返回值-19"><a href="#返回值-19" class="headerlink" title="返回值"></a>返回值</h4><p>当所有 key 都成功设置，返回 1 。<br>如果所有给定 key 都设置失败(至少有一个 key 已经存在)，那么返回 0 。</p><h4 id="示例-19"><a href="#示例-19" class="headerlink" title="示例"></a>示例</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"># 对不存在的 key 进行 MSETNX</div><div class="line">redis&gt; MSETNX rmdbs &quot;MySQL&quot; nosql &quot;MongoDB&quot; key-value-store &quot;redis&quot;</div><div class="line">(integer) 1</div><div class="line">redis&gt; MGET rmdbs nosql key-value-store</div><div class="line">1) &quot;MySQL&quot;</div><div class="line">2) &quot;MongoDB&quot;</div><div class="line">3) &quot;redis&quot;</div><div class="line"># MSET 的给定 key 当中有已存在的 key</div><div class="line">redis&gt; MSETNX rmdbs &quot;Sqlite&quot; language &quot;python&quot;  # rmdbs 键已经存在，操作失败</div><div class="line">(integer) 0</div><div class="line">redis&gt; EXISTS language                          # 因为 MSET 是原子性操作，language 没有被设置</div><div class="line">(integer) 0</div><div class="line">redis&gt; GET rmdbs                                # rmdbs 也没有被修改</div><div class="line">&quot;MySQL&quot;</div></pre></td></tr></table></figure><h3 id="PSETEX"><a href="#PSETEX" class="headerlink" title="PSETEX"></a><strong>PSETEX</strong></h3><p><strong>PSETEX key milliseconds value</strong><br>  这个命令和 SETEX 命令相似，但它以毫秒为单位设置 key 的生存时间，而不是像 SETEX 命令那样，以秒为单位。</p><h4 id="可用版本-12"><a href="#可用版本-12" class="headerlink" title="可用版本"></a>可用版本</h4><p>版本&gt;= 2.6.0</p><h4 id="时间复杂度-12"><a href="#时间复杂度-12" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><p>O(1)</p><h4 id="返回值-20"><a href="#返回值-20" class="headerlink" title="返回值"></a>返回值</h4><p>设置成功时返回 OK 。</p><h4 id="示例-20"><a href="#示例-20" class="headerlink" title="示例"></a>示例</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">redis&gt; PSETEX mykey 1000 &quot;Hello&quot;</div><div class="line">OK</div><div class="line">redis&gt; PTTL mykey</div><div class="line">(integer) 999</div><div class="line">redis&gt; GET mykey</div><div class="line">&quot;Hello&quot;</div></pre></td></tr></table></figure><h3 id="STRLEN"><a href="#STRLEN" class="headerlink" title="STRLEN"></a><strong>STRLEN</strong></h3><p><strong>STRLEN key</strong><br> 返回 key 所储存的字符串值的长度。<br> 当 key 储存的不是字符串值时，返回一个错误。</p><h4 id="可用版本-13"><a href="#可用版本-13" class="headerlink" title="可用版本"></a>可用版本</h4><p>版本&gt;= 2.2.0</p><h4 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h4><p>O(1)</p><h4 id="返回值-21"><a href="#返回值-21" class="headerlink" title="返回值"></a>返回值</h4><p>字符串值的长度。<br>当 key 不存在时，返回 0 。</p><h4 id="示例-21"><a href="#示例-21" class="headerlink" title="示例"></a>示例</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"># 获取字符串的长度</div><div class="line">redis&gt; SET mykey &quot;Hello world&quot;</div><div class="line">OK</div><div class="line">redis&gt; STRLEN mykey</div><div class="line">(integer) 11</div><div class="line"># 不存在的 key 长度为 0</div><div class="line">redis&gt; STRLEN nonexisting</div><div class="line">(integer) 0</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Redis的字符串和其他编程语言或者其他键值存储提供的字符串非常相似。一个key对应一个value。&lt;br&gt;string类型是二进制安全的，可以包含任何数据，比如jpg图片或者序列化的对象。从内部实现来看其实string可以看作byte数组，最大上限1G字节。&lt;br&gt;另外string类型可以被部分命令按int处理，比如incr等命令。&lt;br&gt;文档目前描述的内容以 Redis 2.8 版本为准。&lt;br&gt;
    
    </summary>
    
      <category term="Redis" scheme="http://yoursite.com/categories/Redis/"/>
    
    
      <category term="Redis" scheme="http://yoursite.com/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>精通Hibernate</title>
    <link href="http://yoursite.com/2017/03/01/%E7%B2%BE%E9%80%9Ahibernate/"/>
    <id>http://yoursite.com/2017/03/01/精通hibernate/</id>
    <published>2017-03-01T13:02:25.000Z</published>
    <updated>2017-09-28T08:24:37.614Z</updated>
    
    <content type="html"><![CDATA[<p>   今天去公司上班了，公司后台框架是hibernate+springMvc,虽然之前看过hibernate，但是没有在实际的开发过程中用到，很多都忘记了，就准备看孙卫琴的《精通Hibernate》。</p><a id="more"></a><h2 id="Java对象持久化技术概论"><a href="#Java对象持久化技术概论" class="headerlink" title="Java对象持久化技术概论"></a>Java对象持久化技术概论</h2><p>从不同的角度解释hibernate：</p><ul><li>它是连接Java应用程序和关系数据库的中间件。</li><li>它对JDBC API进行了封装，负责Java的持久化。</li><li>在分层软件架构中它位于持久化层，封装了所有数据访问细节，使业务逻辑层可以专注与实现业务逻辑。</li><li>它是一只ORM映射工具，能够建立面向对象的域模型和关系数据模型之间的映射。</li></ul><p>本章介绍软件的三种模型：概念模型、域模型和数据模型，然后介绍了Java对象的持久化概念，并介绍了实现对象持久化的几种模式：</p><ul><li>业务逻辑和数据访问耦合</li><li>主动域对象模式</li><li>ORM模式</li><li>JDO模式</li><li>CMP模式</li></ul><h3 id="应用程序的分层体系结构"><a href="#应用程序的分层体系结构" class="headerlink" title="应用程序的分层体系结构"></a>应用程序的分层体系结构</h3><p>四层结构应用软件的结构。</p><ul><li>表述层：提供与用户交互的界面。GUI(图形用户界面)和web页面而是表述层的两个典型的例子。</li><li>业务逻辑层：实现各种业务逻辑。例如当用户发出生产订单的请求时，业务逻辑层负责计算的价格、验证订单的信息。</li><li>持久层：封装数据访问细节，为业务逻辑提供了面向对象的API</li><li>数据库层：负责存放和管理应用的持久性业务数据。例如对于电子商务网站应用，在数据库中保存了客户、订单和商品等业务数据。关系数据库依然是目前最流行的数据库。</li></ul><h4 id="软件分层的优点"><a href="#软件分层的优点" class="headerlink" title="软件分层的优点"></a>软件分层的优点</h4><p>恰当地为软件分层，将会提高软件的以下性能。</p><ul><li>伸缩性：伸缩性指应用程序是否能支持更多的用户。</li><li>可维护性：当发生需求变化，只需修改软件的某一部分，不会影响其他部分的代码。层次越多，可维护性也会不断提高，因为修改软件的某一部分的实现，不会影响其它层。</li><li>可扩展性：是在现有的系统中增加新功能的难易程度。层数越少，添加新功能就越容易破坏现有的程序结构。层数越多，就可以在每个层次中提供扩展点，不会打破应用的整体框架。</li><li>可重复性：程序代码有冗余，同一个程序就能满足多种需求。</li><li>可管理性：管理系统的难易程度。将应用程序分为多层后，可以将工作分解给不同的开发小组，从而便于管理。应用越复杂，规模越大，需要的层就越多。</li></ul><h4 id="软件分层的缺点"><a href="#软件分层的缺点" class="headerlink" title="软件分层的缺点"></a>软件分层的缺点</h4><ul><li>软件分层越多，对软件设计人员的要求就越高。</li><li>在设计阶段，必须花时间构思合理的体系结构。</li><li>开发流程相对复杂，降低开发效率。</li></ul><h4 id="Java应用的持久化层"><a href="#Java应用的持久化层" class="headerlink" title="Java应用的持久化层"></a>Java应用的持久化层</h4><h3 id="Hibernate-API简介"><a href="#Hibernate-API简介" class="headerlink" title="Hibernate API简介"></a>Hibernate API简介</h3><p>hibernate中的接口可分为以下几类：</p><ul><li>提供访问数据库的操作（如保存、更新、删除和查询对象）的接口。这些接口包括：Session、Transaction和Quer接口。</li><li>用于配置Hibernate的接口：Configuration。</li><li>回调接口，使应用程序接受Hibernate内部发生的事件，并做出相应的回应。这些接口包括：Interceptor、Lifecycle和Validatable接口。</li><li>用于扩展Hibernate的功能的接口，如UserType、CompositeUserType和IdentifierGenerator接口，如果需要的话，应用程序可以扩展这些接口。</li></ul><h2 id="Hibernate入门"><a href="#Hibernate入门" class="headerlink" title="Hibernate入门"></a>Hibernate入门</h2><p>Hibernate是Java应用和关系型数据库之间的桥梁，内部封装了通过JDBC访问数据库的操作，向上层应用提供了面向对象的数据访问API。在Java应用中使用hibernate包含以下步骤。</p><ul><li>创建Hibernate的配置文件。</li><li>创建持久化类。</li><li>创建对象-关系映射文件。</li><li>通过HibernateAPI编写访问数据库的代码。</li></ul><h3 id="创建Hibernate的配置文件"><a href="#创建Hibernate的配置文件" class="headerlink" title="创建Hibernate的配置文件"></a>创建Hibernate的配置文件</h3><p>hibernate的配置文件中读取了数据库连接的有关信息，有两种形式：一种是XML格式文件；还有一种是Java属性文件，采用“健=值”的形式。<br>配置文件的属性：<br>hibernate.properties</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">hibernate.dialect=net.sf.hibernate.dialect.MySQLDialct //指定数据库使用SQL方言</div><div class="line">hibernate.connection.driver_class=com.mysql.jdbc.Driver //指定数据库的驱动程序</div><div class="line">hibernate.connection.url=jdbc:mysql://localhost:3306/SAMPLEDB //指定数据库的URL</div><div class="line">hibernate.connection.username=root //指定数据库的连接名</div><div class="line">hibernate.connection.password=root //指定数据库的口令</div><div class="line">hibernate.show_sql=ture //是否在控制台输出SQL语句</div></pre></td></tr></table></figure><h3 id="创建持久化类"><a href="#创建持久化类" class="headerlink" title="创建持久化类"></a>创建持久化类</h3><p>持久化类是指其实例需要被Hibernate持久化到数据库中的类。持久化类通常都是域模型中的实体域类。持久化类符合JavaBean的规范，包含一些属性，以及与之对应的getXXX()和setXXX()方法。下列中定义了一个名为Customer的持久化类。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">package mypack;</div><div class="line"></div><div class="line">import java.io.Serializable;</div><div class="line">import java.sql.Date;</div><div class="line">import java.sql.Timestamp;</div><div class="line"></div><div class="line">public class Customer implements Serializable &#123;</div><div class="line">-</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>持久化类符合JavaBean的规范，包含一些属性，以及与之对应的getXXX()和setXXX()方法。getXXX()和setXXX()方法必须符合特定的命名规范，”get”和”set”后面紧跟属性的名字，并且属性名的首字母为大写，例如name属性的getName(),如果把get方法写为getname()或者getNANE(),会导致Hibernate在运行时抛出以下的异常：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">net.sf.hibernate.PropertNotFountException:Could not find a getter for property name in class mypack.Customer</div></pre></td></tr></table></figure><p>如果为boolean类型可以用isXXX()或者getXXX().<br>Hibernate并不要求持久化类必须实现java.io.Serializable接口，但是对于采用分布式结构的Java应用，当Java对象在不同的进程点之间传输时，这个对象所属的类必须实现Serializable接口，此外，在Java web应用中，如果希望对HttpSession中存放的Java对象进行持久化，那么这个Java对象所属的类也必须实现Serializable接口。<br>Customer持久化类有一个id属性，用来唯一标识Customer类的每个属性。在面向对象术语中，这个id属性称为对象标识符(OID,Object Identifier)。通常为整数也可以为其他类型。<br>Hibernate要求持久化类必须提供一个不带参数的默认构造方法，在程序运行时，Hibernate运用Java反射机制，调用java.lang.reflenct.Constructor.newInstance()方法来构造持久化的实例。如果对这个持久化类使用延迟检索策略，为了使Hibernate能够在运行时为这个持久化类创建动态代理，要求持久化类的默认构造方法的访问级别必须是public或protected类型，而不是default 或private类型。<br>在Customer类中没有引入任何Hibernate API，Customer类不需要继承Hibernate的类或者实现Hibernate的接口，这提高了持久化类的独立性。</p><h3 id="创建数据库Schema"><a href="#创建数据库Schema" class="headerlink" title="创建数据库Schema"></a>创建数据库Schema</h3><p>下面为Customer类对应的数据库表名为CUSTOMERS，它在MySQL数据库中的DDL定义如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">create table CUSTOMERS(</div><div class="line"> ID bigint not null primary key,</div><div class="line"> NAME varchar(15) not null,</div><div class="line"> EMAIL varchar(128) not null,</div><div class="line"> PASSWORD varchar(8) not null,</div><div class="line"> PHONE int,</div><div class="line"> ADDRESS varchar(255),</div><div class="line"> SEX char(1),</div><div class="line"> IS_MARRIED bit,</div><div class="line"> DESCRIPTION text,</div><div class="line"> IMAGE blob,</div><div class="line"> BIRTHDAY date,</div><div class="line"> REGISTERED_TIME timestamp</div><div class="line">);</div></pre></td></tr></table></figure><h3 id="创建对象-关系映射文件"><a href="#创建对象-关系映射文件" class="headerlink" title="创建对象-关系映射文件"></a>创建对象-关系映射文件</h3><p>Hibernate采用XML格式的文件来指定对象和关系数据之间的映射。在运行时，Hibernate将根据这个映射文件来生成各种SQL语句。下面的Customer.hbm.xml把Customer类映射到CUSTOMERS表：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version=&quot;1.0&quot;?&gt;</div><div class="line">&lt;!DOCTYPE hibernate-mapping PUBLIC &quot;-//Hibernate/Hibernate Mapping DTD 2.0//EN&quot;</div><div class="line">&quot;http://hibernate.sourceforge.net/hibernate-mapping-2.0.dtd&quot;&gt; </div><div class="line">&lt;hibernate-mapping&gt;</div><div class="line">&lt;class name=&quot;mypack.Customer&quot; table=&quot;CUSTOMERS&quot;&gt;</div><div class="line">&lt;id name=&quot;id&quot; column=&quot;ID&quot; type=&quot;long&quot;&gt;&lt;generator class=&quot;increment&quot;/&gt;&lt;/id&gt;</div><div class="line">&lt;property name=&quot;name&quot; column=&quot;NAME&quot; type=&quot;string&quot; not-null=&quot;true&quot;/&gt;</div><div class="line">&lt;property name=&quot;email&quot; column=&quot;EMAIL&quot; type=&quot;string&quot; not-null=&quot;true&quot;/&gt;</div><div class="line">&lt;property name=&quot;password&quot; column=&quot;PASSWORD&quot; type=&quot;string&quot; not-null=&quot;true&quot;/&gt;</div><div class="line">&lt;property name=&quot;phone&quot; column=&quot;PHONE&quot; type=&quot;int&quot;/&gt;</div><div class="line">&lt;property name=&quot;address&quot; column=&quot;ADDRESS&quot; type=&quot;string&quot;/&gt;</div><div class="line">&lt;property name=&quot;sex&quot; column=&quot;SEX&quot; type=&quot;character&quot;/&gt;</div><div class="line">&lt;property name=&quot;married&quot; column=&quot;IS_MARRIED&quot; type=&quot;boolean&quot;/&gt;</div><div class="line">&lt;property name=&quot;description&quot; column=&quot;DESCRIPTION&quot; type=&quot;text&quot;/&gt;</div><div class="line">&lt;property name=&quot;image&quot; column=&quot;IMAGE&quot; type=&quot;binary&quot;/&gt;</div><div class="line">&lt;property name=&quot;birthday&quot; column=&quot;BIRTHDAY&quot; type=&quot;date&quot;/&gt;</div><div class="line">&lt;property name=&quot;registeredTime&quot; column=&quot;REGISTEREDTIME&quot; type=&quot;timestamp&quot;/&gt;</div><div class="line">&lt;/class&gt;</div><div class="line">&lt;/hibernate-mapping&gt;</div></pre></td></tr></table></figure><h4 id="映射文件的文档类型定义（DTD）"><a href="#映射文件的文档类型定义（DTD）" class="headerlink" title="映射文件的文档类型定义（DTD）"></a>映射文件的文档类型定义（DTD）</h4><p>Customer.hbm.xml文件的开头定义声明DTD（Document Type Definition,文档类型定义），它对XML文件的语法和格式做了定义。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;   今天去公司上班了，公司后台框架是hibernate+springMvc,虽然之前看过hibernate，但是没有在实际的开发过程中用到，很多都忘记了，就准备看孙卫琴的《精通Hibernate》。&lt;/p&gt;
    
    </summary>
    
      <category term="Hibernate" scheme="http://yoursite.com/categories/Hibernate/"/>
    
    
      <category term="Hibernate" scheme="http://yoursite.com/tags/Hibernate/"/>
    
  </entry>
  
  <entry>
    <title>MySQL数据库常见面试题目</title>
    <link href="http://yoursite.com/2017/02/20/MySQL%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98%E7%9B%AE/"/>
    <id>http://yoursite.com/2017/02/20/MySQL常见面试题目/</id>
    <published>2017-02-20T13:02:25.000Z</published>
    <updated>2017-02-21T07:57:50.713Z</updated>
    
    <content type="html"><![CDATA[<p>   在准备面试，就在网上收集了一些MySQL面试题目。</p><a id="more"></a><h3 id="如何登陆mysql数据库"><a href="#如何登陆mysql数据库" class="headerlink" title="如何登陆mysql数据库"></a>如何登陆mysql数据库</h3><p>MySQL -u username -p</p><h3 id="如何开启-关闭mysql服务"><a href="#如何开启-关闭mysql服务" class="headerlink" title="如何开启/关闭mysql服务"></a>如何开启/关闭mysql服务</h3><p>service mysql start/stop</p><h3 id="查看mysql的状态"><a href="#查看mysql的状态" class="headerlink" title="查看mysql的状态"></a>查看mysql的状态</h3><p>service mysql status</p><h3 id="如何显示数所有数据库"><a href="#如何显示数所有数据库" class="headerlink" title="如何显示数所有数据库"></a>如何显示数所有数据库</h3><p>show databases</p><h3 id="如何获取表内所有字段对象的名称和类型"><a href="#如何获取表内所有字段对象的名称和类型" class="headerlink" title="如何获取表内所有字段对象的名称和类型"></a>如何获取表内所有字段对象的名称和类型</h3><p>describe table_name;</p><h3 id="MYSQL支持事务吗？"><a href="#MYSQL支持事务吗？" class="headerlink" title="MYSQL支持事务吗？"></a>MYSQL支持事务吗？</h3><p>在缺省模式下，MYSQL是autocommit模式的，所有的数据库更新操作都会即时提交，所以在缺省情况下，mysql是不支持事务的。<br>但是如果你的MYSQL表类型是使用InnoDB Tables 或 BDB tables的话，你的MYSQL就可以使用事务处理,使用SET AUTOCOMMIT=0就可以使MYSQL允许在非autocommit模式，在非autocommit模式下，你必须使用COMMIT来提交你的更改，或者用ROLLBACK来回滚你的更改。<br>示例如下：<br>START TRANSACTION;<br>SELECT @A:=SUM(salary) FROM table1 WHERE type=1;<br>UPDATE table2 SET summmary=@A WHERE type=1;<br>COMMIT;</p><h3 id="MYSQL相比于其他数据库有哪些特点？"><a href="#MYSQL相比于其他数据库有哪些特点？" class="headerlink" title="MYSQL相比于其他数据库有哪些特点？"></a>MYSQL相比于其他数据库有哪些特点？</h3><p>MySQL是一个小型关系型数据库管理系统，开发者为瑞典MySQL AB公司，现在已经被Sun公司收购，支持FreeBSD、Linux、MAC、Windows等多种操作系统与其他的大型数据库例如Oracle、DB2、SQL Server等相比功能稍弱一些<br>1、可以处理拥有上千万条记录的大型数据<br>2、支持常见的SQL语句规范<br>3、可移植行高，安装简单小巧<br>4、良好的运行效率，有丰富信息的网络支持<br>5、调试、管理，优化简单（相对其他大型数据库）</p><h3 id="varchar和char的区别"><a href="#varchar和char的区别" class="headerlink" title="varchar和char的区别"></a>varchar和char的区别</h3><p>Char是一种固定长度的类型，varchar是一种可变长度的类型</p><h3 id="数据库事物有哪几种？"><a href="#数据库事物有哪几种？" class="headerlink" title="数据库事物有哪几种？"></a>数据库事物有哪几种？</h3><p>隔离性、持续性、一致性、原子性</p><h3 id="请简洁地描述下MySQL中InnoDB支持的四种事务隔离级别名称，以及逐级之间的区别？"><a href="#请简洁地描述下MySQL中InnoDB支持的四种事务隔离级别名称，以及逐级之间的区别？" class="headerlink" title="请简洁地描述下MySQL中InnoDB支持的四种事务隔离级别名称，以及逐级之间的区别？"></a>请简洁地描述下MySQL中InnoDB支持的四种事务隔离级别名称，以及逐级之间的区别？</h3><p>SQL标准定义的四个隔离级别为：<br>read uncommited：读取未提交内容<br>read committed：读取提交内容<br>repeatable read：可重读<br>serializable：可串行化<br>详细解释如下：<br>Read Uncommitted（读取未提交内容）<br>在该隔离级别，所有事务都可以看到其他未提交事务的执行结果。本隔离级别很少用于实际应用，因为它的性能也不比其他级别好多少。读取未提交的数据，也被称之为脏读（Dirty Read）。<br>Read Committed（读取提交内容）<br>这是大多数数据库系统的默认隔离级别（但不是MySQL默认的）。它满足了隔离的简单定义：一个事务只能看见已经提交事务所做的改变。这种隔离级别也支持所谓的不可重复读（Nonrepeatable Read），因为同一事务的其他实例在该实例处理其间可能会有新的commit，所以同一select可能返回不同结果。<br>Repeatable Read（可重读）<br>这是MySQL的默认事务隔离级别，它确保同一事务的多个实例在并发读取数据时，会看到同样的数据行。不过理论上，这会导致另一个棘手的问题：幻读（Phantom Read）。简单的说，幻读指当用户读取某一范围的数据行时，另一个事务又在该范围内插入了新行，当用户再读取该范围的数据行时，会发现有新的“幻影” 行。InnoDB和Falcon存储引擎通过多版本并发控制（MVCC，Multiversion Concurrency Control 间隙锁）机制解决了该问题。注：其实多版本只是解决不可重复读问题，而加上间隙锁（也就是它这里所谓的并发控制）才解决了幻读问题。<br>Serializable（可串行化）<br>这是最高的隔离级别，它通过强制事务排序，使之不可能相互冲突，从而解决幻读问题。简言之，它是在每个读的数据行上加上共享锁。在这个级别，可能导致大量的超时现象和锁竞争。<br>对于不同的事务，采用不同的隔离级别分别有不同的结果。不同的隔离级别有不同的现象。主要有下面3种现在：<br>1、脏读（dirty read）：一个事务可以读取另一个尚未提交事务的修改数据。<br>2、非重复读（nonrepeatable read）：在同一个事务中，同一个查询在T1时间读取某一行，在T2时间重新读取这一行时候，这一行的数据已经发生修改，可能被更新了（update），也可能被删除了（delete）。<br>3、幻像读（phantom read）：在同一事务中，同一查询多次进行时候，由于其他插入操作（insert）的事务提交，导致每次返回不同的结果集。<br>不同的隔离级别有不同的现象，并有不同的锁定/并发机制，隔离级别越高，数据库的并发性就越差，4种事务隔离级别分别表现的现象如下表：<br>这里写图片描述</p><h3 id="mysql数据库引擎MyISAM和InnoDB的区别"><a href="#mysql数据库引擎MyISAM和InnoDB的区别" class="headerlink" title="mysql数据库引擎MyISAM和InnoDB的区别"></a>mysql数据库引擎MyISAM和InnoDB的区别</h3><p>这里写图片描述</p><h3 id="mysql有关权限的表都有哪几个"><a href="#mysql有关权限的表都有哪几个" class="headerlink" title="mysql有关权限的表都有哪几个"></a>mysql有关权限的表都有哪几个</h3><p>MySQL服务器通过权限表来控制用户对数据库的访问，权限表存放在mysql数据库里，由mysql_install_db脚本初始化。这些权限表分别user，db，table_priv，columns_priv和host。下面分别介绍一下这些表的结构和内容：<br>user权限表：记录允许连接到服务器的用户帐号信息，里面的权限是全局级的。<br>db权限表：记录各个帐号在各个数据库上的操作权限。<br>table_priv权限表：记录数据表级的操作权限。<br>columns_priv权限表：记录数据列级的操作权限。<br>host权限表：配合db权限表对给定主机上数据库级操作权限作更细致的控制。这个权限表不受GRANT和REVOKE语句的影响。</p><h3 id="mysql存储引擎有哪些？如何修改mysql存储引擎？"><a href="#mysql存储引擎有哪些？如何修改mysql存储引擎？" class="headerlink" title="mysql存储引擎有哪些？如何修改mysql存储引擎？"></a>mysql存储引擎有哪些？如何修改mysql存储引擎？</h3><p>MyISAM indexed sequential access method (有索引的顺序访问方法)<br>MyISAM 具有检查和修复表格的大多数工具。表格可以被压缩，而且支持全文收索<br>不是事务安全的，而且不支持外键。<br>MEMORY 也是以前的(HEAP) 该类型表存储在内存中，表的索引是哈希分布的。<br>merge 这些表为了查询目的，把myisam 表集合作为单个表，因此你可以在某些操作系统中避开最大文件大小的限制。<br>archive 这种类型的表只支持，insert ,select 不支持delete,update,replace ,不使用索引。<br>csv 这些表保存在服务器的单个文件中，它包含了用逗号间隔的数据。</p><p>innodb 这种表是事务安全的。提供了commit（提交） rollback（实务回滚）支持外键，比myisam慢。<br>修改mysql存储引擎alter table tablename type = innodb;</p><h3 id="MYSQL-数据表修复及数据恢复面试题"><a href="#MYSQL-数据表修复及数据恢复面试题" class="headerlink" title="MYSQL 数据表修复及数据恢复面试题"></a>MYSQL 数据表修复及数据恢复面试题</h3><p>MYSQL数据表在什么情况下容易损坏？<br>服务器突然断电导致数据文件损坏。<br>强制关机，没有先关闭mysql 服务等。<br>数据表损坏后的主要现象是什么？<br>从表中选择数据之时，得到如下错误：Incorrect key file for table: ‘…’. Try to repair it<br>查询不能在表中找到行或返回不完全的数据。<br>Error: Table ‘p’ is marked as crashed and should be repaired 。<br>打开表失败： Can’t open file: ‘×××.MYI’ (errno: 145) 。<br>数据表损坏的修复方式有哪些？<br>使用 myisamchk 来修复，具体步骤：<br>1）修复前将mysql服务停止。<br>2）打开命令行方式，然后进入到mysql的/bin目录。<br>3）执行myisamchk –recover 数据库所在路径/*.MYI<br>使用repair table 或者 OPTIMIZE table命令来修复，REPAIR TABLE table_name 修复表 OPTIMIZE TABLE table_name 优化表 REPAIR TABLE 用于修复被破坏的表。<br>OPTIMIZE TABLE 用于回收闲置的数据库空间，当表上的数据行被删除时，所占据的磁盘空间并没有立即被回收，使用了OPTIMIZE TABLE命令后这些空间将被回收，并且对磁盘上的数据行进行重排（注意：是磁盘上，而非数据库）</p><h3 id="MYSQL数据库服务器性能分析的方法命令有哪些"><a href="#MYSQL数据库服务器性能分析的方法命令有哪些" class="headerlink" title="MYSQL数据库服务器性能分析的方法命令有哪些?"></a>MYSQL数据库服务器性能分析的方法命令有哪些?</h3><p>Show status<br>一些值得监控的变量值：<br>Bytes_received和Bytes<em>sent<br>和服务器之间来往的流量。<br>Com</em><em>服务器正在执行的命令。<br>Created_</em>在查询执行期限间创建的临时表和文件。<br>Handler<em>*存储引擎操作。<br>Select</em><em>不同类型的联接执行计划。<br>Sort_</em>几种排序信息。<br>Show session status like ‘Select’;<br>Show profiles<br>SET profiling=1;<br>Show profiles\G<br>Show profile;</p><h3 id="mysql里记录货币用什么字段类型好"><a href="#mysql里记录货币用什么字段类型好" class="headerlink" title="mysql里记录货币用什么字段类型好"></a>mysql里记录货币用什么字段类型好</h3><p>NUMERIC和DECIMAL类型被MySQL实现为同样的类型，这在SQL92标准允许。他们被用于保存值，该值的准确精度是极其重要的值，例如与金钱有关的数据。当声明一个类是这些类型之一时，精度和规模的能被(并且通常是)指定；例如：<br>salary DECIMAL(9,2)<br>在这个例子中，9(precision)代表将被用于存储值的总的小数位数，而2(scale)代表将被用于存储小数点后的位数。因此，在这种情况下，能被存储在salary列中的值的范围是从-9999999.99到9999999.99。在ANSI/ISO SQL92中，句法DECIMAL(p)等价于DECIMAL(p,0)。同样，句法DECIMAL等价于DECIMAL(p,0)，这里实现被允许决定值p。MySQL当前不支持DECIMAL/NUMERIC数据类型的这些变种形式的任一种。这一般说来不是一个严重的问题，因为这些类型的主要益处得自于明显地控制精度和规模的能力。<br>DECIMAL和NUMERIC值作为字符串存储，而不是作为二进制浮点数，以便保存那些值的小数精度。一个字符用于值的每一位、小数点(如果scale&gt;0)和“-”符号(对于负值)。如果scale是0，DECIMAL和NUMERIC值不包含小数点或小数部分。<br>DECIMAL和NUMERIC值得最大的范围与DOUBLE一样，但是对于一个给定的DECIMAL或NUMERIC列，实际的范围可由制由给定列的precision或scale限制。当这样的列赋给了小数点后面的位超过指定scale所允许的位的值，该值根据scale四舍五入。当一个DECIMAL或NUMERIC列被赋给了其大小超过指定(或缺省的）precision和scale隐含的范围的值，MySQL存储表示那个范围的相应的端点值。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;   在准备面试，就在网上收集了一些MySQL面试题目。&lt;/p&gt;
    
    </summary>
    
      <category term="Database" scheme="http://yoursite.com/categories/Database/"/>
    
    
      <category term="MySQL" scheme="http://yoursite.com/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>Mybatis</title>
    <link href="http://yoursite.com/2017/02/12/Mybatis%E5%85%A5%E9%97%A8/"/>
    <id>http://yoursite.com/2017/02/12/Mybatis入门/</id>
    <published>2017-02-12T13:02:25.000Z</published>
    <updated>2017-09-28T08:26:27.417Z</updated>
    
    <content type="html"><![CDATA[<p>   初学mybatis。</p><a id="more"></a><h2 id="SqlSession"><a href="#SqlSession" class="headerlink" title="SqlSession"></a>SqlSession</h2><p>SqlSession的作用：</p><ul><li>向SQL语句传入参数</li><li>执行SQL语句</li><li>获取执行SQL语句的结果</li><li>事务的控制</li></ul><p>如何得到SqlSession:</p><ul><li>通过配置文件获取数据库连接相关信息</li><li>通过配置信息构建SqlSessionFactory</li><li>通过SqlSessionFactory打开数据库会话<h2 id="各层分工"><a href="#各层分工" class="headerlink" title="各层分工"></a>各层分工</h2>servlet 负责接收页面的值，向页面传值，如果有相应的业务逻辑需要处理，则调用相应service层。<br>service 负责接收servlet传过来的值，并做执行处理，业务的操作、算法等等，如果有需要要调用相应的dao层。<br>dao 完成与数据库的交互，执行相应的sql语句<br>bean 对象</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;   初学mybatis。&lt;/p&gt;
    
    </summary>
    
      <category term="Mybatis" scheme="http://yoursite.com/categories/Mybatis/"/>
    
    
      <category term="Mybatis" scheme="http://yoursite.com/tags/Mybatis/"/>
    
  </entry>
  
  <entry>
    <title>Nginx安装过程</title>
    <link href="http://yoursite.com/2017/02/11/Nginx%E5%AE%89%E8%A3%85%E8%BF%87%E7%A8%8B/"/>
    <id>http://yoursite.com/2017/02/11/Nginx安装过程/</id>
    <published>2017-02-10T17:43:50.000Z</published>
    <updated>2017-09-29T01:45:04.671Z</updated>
    
    <content type="html"><![CDATA[<p>nginx是C语言开发，建议在linux上运行，本教程使用Centos6.5作为安装环境。<br><a id="more"></a></p><h3 id="nginx安装环境"><a href="#nginx安装环境" class="headerlink" title="nginx安装环境"></a>nginx安装环境</h3><ul><li>gcc<br>安装nginx需要先将官网下载的源码进行编译，编译依赖gcc环境，如果没有gcc环境，需要安装gcc：<strong>yum install gcc-c++</strong></li><li>PCRE<br>PCRE(Perl Compatible Regular Expressions)是一个Perl库，包括 perl 兼容的正则表达式库。nginx的http模块使用pcre来解析正则表达式，所以需要在linux上安装pcre库。<br><strong>yum install -y pcre pcre-devel</strong><br>注：pcre-devel是使用pcre开发的一个二次开发库。nginx也需要此库。</li><li>zlib<br>zlib库提供了很多种压缩和解压缩的方式，nginx使用zlib对http包的内容进行gzip，所以需要在linux上安装zlib库。<br><strong>yum install -y zlib zlib-devel</strong></li><li>openssl<br>OpenSSL 是一个强大的安全套接字层密码库，囊括主要的密码算法、常用的密钥和证书封装管理功能及SSL协议，并提供丰富的应用程序供测试或其它目的使用。<br>  nginx不仅支持http协议，还支持https（即在ssl协议上传输http），所以需要在linux安装openssl库。<br><strong>yum install -y openssl openssl-devel</strong></li></ul><h3 id="编译安装"><a href="#编译安装" class="headerlink" title="编译安装"></a>编译安装</h3><p>将nginx-1.8.0.tar.gz拷贝至linux服务器。<br>解压：<br>  <strong>tar -zxvf nginx-1.8.0.tar.gz</strong><br>  <strong>cd nginx-1.8.0</strong></p><ul><li>configure<br>./configure –help查询详细参数</li></ul><p>参数设置如下：<br><strong>./configure \</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">--prefix=/usr/local/nginx \</div><div class="line">--pid-path=/var/run/nginx/nginx.pid \</div><div class="line">--lock-path=/var/lock/nginx.lock \</div><div class="line">--error-log-path=/var/log/nginx/error.log \</div><div class="line">--http-log-path=/var/log/nginx/access.log \</div><div class="line">--with-http_gzip_static_module \</div><div class="line">--http-client-body-temp-path=/var/temp/nginx/client \</div><div class="line">--http-proxy-temp-path=/var/temp/nginx/proxy \</div><div class="line">--http-fastcgi-temp-path=/var/temp/nginx/fastcgi \</div><div class="line">--http-uwsgi-temp-path=/var/temp/nginx/uwsgi \</div><div class="line">--http-scgi-temp-path=/var/temp/nginx/scgi</div></pre></td></tr></table></figure></p><p><strong>注意：上边将临时文件目录指定为/var/temp/nginx，需要在/var下创建temp及nginx目录</strong></p><ul><li>编译安装<br><strong>make</strong><br><strong>make  install</strong><br>安装成功查看安装目录 ：</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;nginx是C语言开发，建议在linux上运行，本教程使用Centos6.5作为安装环境。&lt;br&gt;
    
    </summary>
    
      <category term="Operations" scheme="http://yoursite.com/categories/Operations/"/>
    
    
      <category term="Nginx" scheme="http://yoursite.com/tags/Nginx/"/>
    
  </entry>
  
  <entry>
    <title>Markdown using</title>
    <link href="http://yoursite.com/2017/01/12/Markdown/"/>
    <id>http://yoursite.com/2017/01/12/Markdown/</id>
    <published>2017-01-12T13:02:25.000Z</published>
    <updated>2017-09-28T08:23:36.450Z</updated>
    
    <content type="html"><![CDATA[<p> Markdown 和 Haroopad 介绍文档<br><a id="more"></a></p><hr><p><strong>要想写一遍自己的博客，一个好的工具往往会带来很多的便利</strong><br><strong>这里我推荐本人使用的一款工具Markdown编辑器Haroopad</strong></p><h3 id="Markdown简介"><a href="#Markdown简介" class="headerlink" title="Markdown简介"></a>Markdown简介</h3><blockquote><p>是一种轻量级标记语言，创始人为约翰·格鲁伯（John Gruber）。它允许人们“使用易读易写的纯文本格式编写文档，然后转换成有效的XHTML(或者HTML)文档”。这种语言吸收了很多在电子邮件中已有的纯文本标记的特性。    —— <a href="https://zh.wikipedia.org/wiki/Markdown" target="_blank" rel="external">维基百科</a><br>可以理解是通过类似html的语法渲染文本的工具。</p></blockquote><p>正如您在阅读的这份文档，它使用简单的符号标识不同的标题，将某些文字标记为<strong>粗体</strong>或者<em>斜体</em>，跨平台，代码高亮，Vim 键绑定，多列模式，行号，折叠， Github Flavored Markdown 等功能~下面列举了几个高级功能，更多语法可以查看<a href="http://daringfireball.net/projects/markdown/" target="_blank" rel="external">官网</a>或者<a href="http://www.appinn.com/markdown/" target="_blank" rel="external">中文文档</a>。</p><h3 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h3><p><strong>可以在标题内容前输入特定数量的井号(‘#’)来实现对应级别的HTML样式的标题(HTML提供六级标题)</strong></p><hr><p><img src="http://ojo6kjb1v.bkt.clouddn.com/title.png" alt="标题" title="title"></p><hr><h3 id="特殊格式的字体"><a href="#特殊格式的字体" class="headerlink" title="特殊格式的字体"></a>特殊格式的字体</h3><p><strong>在需要改变的文字片段前后 使用一对符号可以改变文字为特殊格式：</strong></p><ul><li>粗体     使用<code>**文字**</code>或者<code>__文字__</code>    效果：<strong>这里请大家尤其注意！</strong>  </li><li>斜体    使用<code>*文字*</code>或者<code>_文字_</code>    效果：会不调用父类的 <em>析构函数</em> 呢？  </li><li>高亮    使用 <code>==文字==</code>    效果：==这里是高亮的重点==，但这里不是。  </li><li>下划线    使用<code>++文字++</code>    效果：如果此时的++判断结果为真++……  </li><li>删除线    使用<code>~~文字~~</code>    效果：<del>1.2的版本已经修复这个Bug？</del>  </li><li>上角标    使用<code>^文字^</code>    效果：单位圆的方程式是x^2^+y^2^=1。  </li><li>下角标    使用<code>~文字~</code>    效果：最常见的氧化反应是C+O~2~=CO~2~  </li></ul><h3 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h3><p><strong>引用代码块的时候，先空一行，按tab接着就可以编写您需要的代码了</strong></p><pre><code>function a(){return(&quot;这是引用代码，亦即使代码块在浏览器显示的时候，区别对待&quot;)；}</code></pre><h3 id="LaTeX-公式"><a href="#LaTeX-公式" class="headerlink" title="LaTeX 公式"></a>LaTeX 公式</h3><p><strong>为了让haroopad支持数学公式首先需要在配置里面开启数学公式支持</strong><br><strong>点击文件-&gt;偏好设置-&gt;markdown-&gt;将数学表达式全部勾选</strong><br><img src="http://ojo6kjb1v.bkt.clouddn.com/math.png" alt="配置说明" title="config"></p><p>可以创建行内公式，例如<br> $$<br>\sqrt{3x-1}+{1+x}^2<br>$$<br>或者块级公式：</p><p>$$<br>x = \dfrac{-b \pm \sqrt{b^2 - 4ac}}{2a}<br>$$</p><h3 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h3><p><strong>Haroopad中绘制表格的语法如下:  <br></strong><br><img src="http://ojo6kjb1v.bkt.clouddn.com/table.png" alt="表格" title="table"><br><strong>效果如下:  <br></strong></p><table><thead><tr><th>姓名</th><th>性别</th><th>年龄</th></tr></thead><tbody><tr><td>张三</td><td>男</td><td>20</td></tr><tr><td>李四</td><td>女</td><td>20</td></tr></tbody></table><h3 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h3><p><strong>Haroopad支持 <a href="https://github.com/knsv/mermaid/wiki" target="_blank" rel="external">mermaid</a> 扩展。Mermaid是一套绘图的符号语言扩展，支持绘制各种关系图，序列图</strong></p><ul><li>Haroopad中mermaid绘图以 ~~~mermaid 单独一行开始，以 ~~~ 单独一行结束。</li><li>其中graph TD指定绘图方向是从上而下</li><li>改为graph LR则是从左至右</li></ul><p><strong>绘制流程图的语法如下：  <br></strong></p><p><img src="http://ojo6kjb1v.bkt.clouddn.com/mer_maid.png" alt="流程图" title="流程图"><br><strong>效果如下:  <br></strong><br><img src="http://ojo6kjb1v.bkt.clouddn.com/col_img.png" alt="流程图" title="横向"><br><img src="http://ojo6kjb1v.bkt.clouddn.com/row_img.png" alt="流程图" title="纵向"></p><p>Mermaid扩展还支持其它绘图方式，以及调整绘图样式，具体见<a href="https://github.com/knsv/mermaid/wiki" target="_blank" rel="external">绘图介绍</a></p><pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">graph TD;</div><div class="line">         subgraph 子图;</div><div class="line">         a1[矩形];</div><div class="line">         a2&gt;旗帜形];</div><div class="line">         a3(圆角方形);</div><div class="line">         end;</div><div class="line">         subgraph 第二个子图;</div><div class="line">         b1((圆形));</div><div class="line">         b2&#123;斜方形&#125;;</div><div class="line">         end;</div><div class="line">         a1--&gt;|实线箭头|a2;</div><div class="line">         a2--&gt;a1;</div><div class="line">         a2-.-&gt;|虚线箭头|a3;</div><div class="line">         a3-.-&gt;a2;</div><div class="line">         a3==&gt;|加粗箭头|a1;</div><div class="line">         a1==&gt;a3;</div><div class="line">         b1---b2;</div><div class="line">         b2---|实线无箭头|b1;</div><div class="line">         a1--&gt;b1;</div></pre></td></tr></table></figure></pre><h3 id="时序图"><a href="#时序图" class="headerlink" title="时序图"></a>时序图</h3><p><img src="http://ojo6kjb1v.bkt.clouddn.com/time.png" alt="时序图" title="时序图"></p><pre>~~~mermaid  sequenceDiagram          Alice->>Bob: Hello Bob, how are you?          alt is sick              Bob->>Alice: Not so good :(          else is well              Bob->>Alice: Feeling fresh like a daisy          end          opt Extra response              Bob->>Alice: Thanks for asking          end  ~~~  </pre><h3 id="复选框（任务清单）"><a href="#复选框（任务清单）" class="headerlink" title="复选框（任务清单）"></a>复选框（任务清单）</h3><p><strong>使用 <code>- [ ]</code> 和 <code>- [x]</code> 语法可以创建复选框，实现 todo-list 等功能。</strong><br><strong>Haroopad扩展支持tasklist，语法如下：</strong></p><ul><li>[x] a</li><li>[ ] b</li><li>[ ] c</li><li>[ ] d</li></ul><blockquote><p>**目前支持尚不完全，在编辑器勾选复选框是无效、不能同步的</p></blockquote><p>###兼容HTML</p><ul><li>一些 HTML 区块元素――比如 <code>&lt;div&gt;、&lt;table&gt;、&lt;pre&gt;、&lt;p&gt;</code> 等标签，需在标签前后加上空行，且标签本身不能缩进</li></ul><blockquote><p><strong>在HTML里面的Markdown是不被解析的</strong></p></blockquote><ul><li>在Markdown里面可以是直接<code>空格+enter键</code>换行，也可以是使用<code>&lt;br/&gt;</code>标签进行换行</li></ul><blockquote><p><strong>使用标签换行的方法是在需要换行的地方键入两个空格，回车之后加上<code>&lt;br/&gt;</code>标签即可</strong><br>语法示例：<br><img src="http://ojo6kjb1v.bkt.clouddn.com/br.png" alt="流程图" title="换行"><br>效果显示：</p><pre>我要  <br>在第二个字换行</pre></blockquote><ul><li>区块引用，直接在文本前面增加<code>&gt;</code>符号即可（使用不同数量的<code>&gt;</code>符号可以进行引用的嵌套，并且还支持Markdown语法）</li><li>段落和换行</li></ul><blockquote><p>你可以在一行中用三个以上的星号、减号、底线来建立一个分隔线，行内不能有其他东西。你也可以在星号或是减号中间插入空格。</p></blockquote><ul><li><p>链接（行内式和参考式）</p><blockquote><p>行内式语法加效果<br><code>This is [an example](http://example.com/ &quot;Title&quot;) inline link.</code><br>This is <a href="http://example.com/" title="Title" target="_blank" rel="external">an example</a> inline link.  <br><br>参考式语法加效果<br><code>This is [an example] [id] reference-style link.</code><br>This is [an example][id] reference-style link.</p></blockquote></li><li><p>强调(在需要强调的文字两边加上<code>*</code>或者<code>_</code>字符)</p></li><li>反引号<code>` </code>起到保护不被解析的作用</li><li><p>图片（行内式和参考式）</p><blockquote><p><code>![Alt text](/path/to/img.jpg)</code><br><code>![Alt text](/path/to/img.jpg &quot;Optional title&quot;)</code><br><code>[id]: url/to/image  &quot;Optional title attribute&quot;</code></p></blockquote></li><li><p>自动链接<br>Markdown 支持以比较简短的自动链接形式来处理网址和电子邮件信箱，只要是用尖括号包起来， Markdown 就会自动把它转成链接。一般网址的链接文字就和链接地址一样</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3></li></ul><blockquote><p>由于其简单易用，Markdown在社区已经越来越流行。甚至有些项目将自动化测试用例都用markdown语法来写，可以直接发布给客户当作说明文档，执行的时候靠一段解释代码将其翻译成目标语言执行，真的做到测试即文档。而Haroopad是一款非常强大的markdown编辑器，它内置的很多mardown扩展都是为了方便程序员，避免了大家到处寻找插件自行配制的繁琐。到目前为止haroopad是我找到的最好用的markdown编辑器，这篇文档就是用haroopad撰写。最后在支持如此多的特性后，haroopad依然非常轻量！ 希望Haroopad同样适合你！</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt; Markdown 和 Haroopad 介绍文档&lt;br&gt;
    
    </summary>
    
      <category term="Blog" scheme="http://yoursite.com/categories/Blog/"/>
    
    
      <category term="Markdown" scheme="http://yoursite.com/tags/Markdown/"/>
    
  </entry>
  
  <entry>
    <title>MySQL数据库应用从入门到精通</title>
    <link href="http://yoursite.com/2017/01/12/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E5%BA%94%E7%94%A8%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/"/>
    <id>http://yoursite.com/2017/01/12/MySQL数据库应用从入门到精通/</id>
    <published>2017-01-12T13:02:25.000Z</published>
    <updated>2017-09-28T08:25:21.580Z</updated>
    
    <content type="html"><![CDATA[<p>   最近在看《MySQL数据库应用从入门到精通》这本书是基于MySQL5.5版本的，下面是看书过程记录下来的笔记。</p><a id="more"></a><h3 id="数据库概述"><a href="#数据库概述" class="headerlink" title="数据库概述"></a>数据库概述</h3><p>   SQL主要功能：数据定义语言（DDL）,数据操作语言（DML）,数据控制语言（DCL).</p><h3 id="数据可基本操作"><a href="#数据可基本操作" class="headerlink" title="数据可基本操作"></a>数据可基本操作</h3><p><code>create Database database_name;</code>创建数据库<br><code>SHOW DATABASES;</code>查看数据库<br><code>USE database_name;</code> 选择数据库<br><code>DROP DATABASE database_name;</code>删除数据库<br>    在执行SQL语句中，可以用”;”、”\g”、”\G”符号表示语句结束。其中前两个符号的作用一样，而最后一个符号除了表示语句结束外，还可以使得结果显示的更加美观。</p><h3 id="mysql中的存储引擎和数据类型"><a href="#mysql中的存储引擎和数据类型" class="headerlink" title="mysql中的存储引擎和数据类型"></a>mysql中的存储引擎和数据类型</h3><h4 id="存储引擎"><a href="#存储引擎" class="headerlink" title="存储引擎"></a>存储引擎</h4><h5 id="查询存储引擎"><a href="#查询存储引擎" class="headerlink" title="查询存储引擎"></a>查询存储引擎</h5><p>  存储引擎是MySQL数据库管理系统的一个重要特征，在具体开发时，为了提高MySQL数据库管理系统的使用效率和灵活性，可以根据实际需要来选择存储引擎。因为存储引擎指定了表的类型，即如何存储和索引数据、是否支持事物等，同时存储引擎也决定了表在计算机中的存储方式。<br><code>SHOW ENGINES;</code>显示支持的存储引擎<br><code>show variables like &#39;%storage_engine%&#39;;</code>当前默认的存储引擎:</p><h5 id="选择存储引擎"><a href="#选择存储引擎" class="headerlink" title="选择存储引擎"></a>选择存储引擎</h5><p>  下图是3种常用的存储引擎介绍。<br>  <img src="/images/mysql/mysql_ccyq.png" alt="存储引擎特性"><br>   上面主要介绍了MyISAM、InnoDB和MEMORY三种存储引擎特性的对比，接下来将详细介绍这3个存储引擎的应用场合并给出相应的建议。</p><ul><li>MyISAM:由于该存储引擎不支持事务、也不支持外键，所以访问速度比较快。因为此对事务完整性没有要求并以访问为主的应用适用于该存储引擎。</li><li>InnoDB:由于该存储引擎在事务上具有优势，即支持具有提交、回滚和崩溃恢复能力的事务安装，所以比MyISAM存储引擎占用更多的磁盘空间。因此需要进行频繁的更新、删除操作，同时还对事务的完整性要求比较高，需要实现必发控制，此时适用适用该存储引擎。</li><li>MEMORY:该存储引擎使用内存来存储数据，因此该存储引擎的数据访问速度比较快，但是安全上没有保障。如果应用中涉及数据比较小，需要进行快速访问，则适用使用该存储引擎。</li></ul><p>关于图形化的存储引擎修改这里不做记录，下面讲解通过修改my.ini配置来配置存储引擎。<br>  <img src="/images/mysql/mysq_myini.png" alt="my.ini配置文件，关于“[mysqld]”组的内容"><br>  如果想要修改默认存储引擎，只需修改[mysqld]组中的<code>default-storage-engine</code>参数。如：<code>default-storage-engine=MyISAM</code><br>   <strong>注意：如果修改参数后，需重启MySQL服务才能生效</strong></p><h4 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h4><h5 id="整形"><a href="#整形" class="headerlink" title="整形"></a>整形</h5><p><strong> 整型具体特性如下图：</strong><br><img src="/images/mysql/mysql_int.png" alt=""></p><h5 id="浮点数类型、定点数类型和位类型"><a href="#浮点数类型、定点数类型和位类型" class="headerlink" title="浮点数类型、定点数类型和位类型"></a>浮点数类型、定点数类型和位类型</h5><p>当需要精确到小数点后10位以上是，需要选择DOUBLE类型。当需要小数数据精确度非常高时，则可以选择DEC和DECIMAL类型，它们的精确度比DOUBLE类型还要高。FLOAT、DOUBLE数据类型存储数据是存储的是近似数，而DECIMAL存储的是字符串，因此提供了更高的精度。<br><strong> 浮点数类型具体特性如下图：</strong><br><img src="/images/mysql/mysql_fd.png" alt=""><br><strong> 定点数类型具体特性如下图：</strong><br><img src="/images/mysql/mysql_dec.png" alt=""><br><strong> FLOAT数据类型和DECIMAL数据类型的区别如下：</strong><br><img src="/images/mysql/mysql_decf.png" alt=""><br>结果为：<img src="/images/mysql/mysql_decfl.png" alt=""><br><strong> 位类型具体类型如下：</strong><br><img src="/images/mysql/mysql_wei.png" alt=""><br>BIT类型的使用<br><img src="/images/mysql/mysql_bit.png" alt=""></p><h5 id="日期和时间类型"><a href="#日期和时间类型" class="headerlink" title="日期和时间类型"></a>日期和时间类型</h5><p><strong> 日期和时间类型具体特性如下图：</strong><br><img src="/images/mysql/mysql_time.png" alt=""></p><h5 id="字符串类型"><a href="#字符串类型" class="headerlink" title="字符串类型"></a>字符串类型</h5><p><strong> CHAR系列字符串类型具体特性如下：</strong><br><img src="/images/mysql/mysql_char.png" alt=""><br><strong> TEXT系列字符串类型具体特性如下：</strong><br><img src="/images/mysql/mysql_text.png" alt=""><br><strong> BINARY系列字符串类型具体特性如下：</strong><br><img src="/images/mysql/mysql_binary.png" alt=""><br>BINARY可以存储二进制数据（例如图片、音乐或者视频文件），而后者只能存储字符数据。如果二进制数据长度经常变化则选择VARBINARY类型，否则选择BINARY。<br><strong> BLOB系列字符类型具体特性如下：</strong><br><img src="/images/mysql/mysql_blob.png" alt=""><br>上面的四种类型与TEXT系列字符串类型非常类似，不同的是，前者可以存储二进制数据（例如图片、音乐或者视频文件），而后者只能存储字符数据。如果需要存储电影等视频文件时则根据实际选择合适长度的BLOB类型</p><h3 id="表的操作"><a href="#表的操作" class="headerlink" title="表的操作"></a>表的操作</h3><h4 id="表的基本概念"><a href="#表的基本概念" class="headerlink" title="表的基本概念"></a>表的基本概念</h4><p>表是包含数据库中所有数据的数据库对象，表中的数据库对象包含列、索引和触发器。</p><h4 id="表的基本语法"><a href="#表的基本语法" class="headerlink" title="表的基本语法"></a>表的基本语法</h4><p>使用<code>USE database_name;</code>进入要操作的数据库。</p><h5 id="创建表的语法形式"><a href="#创建表的语法形式" class="headerlink" title="创建表的语法形式"></a>创建表的语法形式</h5><p><img src="/images/mysql/mysql_yufa.png" alt=""></p><h5 id="可以使用下面几种语法查看表定义"><a href="#可以使用下面几种语法查看表定义" class="headerlink" title="可以使用下面几种语法查看表定义"></a>可以使用下面几种语法查看表定义</h5><p><code>DESCRIBE table_name;</code><br><code>SHOW CREATE TABLE table_name;</code><br><code>DESC table_name;</code></p><h5 id="删除表"><a href="#删除表" class="headerlink" title="删除表"></a>删除表</h5><p><code>DROP TABLE table_name</code>;</p><h5 id="修改表"><a href="#修改表" class="headerlink" title="修改表"></a>修改表</h5><p><code>ALTER TABLE old_name RENAME [TO] new_table_name;</code>修改表名<br><code>ALTER TABLE table_name ADD 属性名 属性类型；</code>在表的最后一个位置添加字段<br><code>ALTER TABLE table_name ADD 属性名 属性类型 FIRST；</code>在表的第一个位置添加字段<br><code>ALTER TABLE table_name ADD 属性名 属性类型 AFTER 属性名；</code>在表指定字段之后添加字段<br><code>ALTER TABLE table_name DROP 属性名;</code>删除表中指定的属性<br><code>ALTER TABLE table_name MODIFY 属性名 数据类型;</code>修改字段的数据类型<br><code>ALTER TABLE table_name CHANGE 旧属性名 新属性名 旧属类型;</code>修改字段名字<br><code>ALTER TABLE table_name CHANGE 旧属性名 新属性名  新属类型;</code>同时修改字段名字和属性<br><code>ALTER TABLE table_name MODIFY 属性名1 数据类型 FIRST |AFTER 属性名2;</code>修改字段的顺序</p><h5 id="MySQL支持的完整性约束"><a href="#MySQL支持的完整性约束" class="headerlink" title="MySQL支持的完整性约束"></a>MySQL支持的完整性约束</h5><p>所谓完整性是指数据的准确性和一致性，而完整性检查就是指检查数据的准确性和一致性。MySQL数据库管理系统提供了一致机制来检查数据库表中的数据是否满足规定的条件，以保证数据库中数据的准确性和一致性，这种机制就是约束。<br>完整性约束如下图：<img src="/images/mysql/mysql_ys.png" alt=""><br><code>CREATE TABLE table_name(  属性名 数据类型 NOT NULL,  ......);</code>非空约束（NOT NULL,NK）<br><code>CREATE TABLE table_name(  属性名 数据类型 DEFAULT 默认值,  ......);</code>默认值（DEFAULT）<br><code>CREATE TABLE table_name(  属性名 数据类型 UNIQUE,  ......);</code>唯一约束（UNIQUE,UK）<br><code>CREATE TABLE table_name(  属性名 数据类型 PRIMARY KEY,  .....);</code>单字段主键（PRIMARY KEY,PK）<br><code>CREATE TABLE table_name(  属性名 数据类型,.....[CONSTRAINT 约束名]PRIMARY KEY(属性名,属性名......));</code>多字段主键（PRIMARY KEY,PK）<br><code>CREATE TABLE table_name(  属性名 数据类型 AUTO_INCREMENT,  .....);</code>自动增加（AUTO_INCREMENT）<br><code>CREATE TABLE table_name(  属性名 数据类型,  属性名 数据类型,  .....  CONSTRAINT 外键约束名 FOREIGN KEY (属性名) REFERENCES 表名 （属性名2）);</code>外键约束（FOREIGN KEY,FK）<br><strong> 注意：如果想给字段上的约束设置一个约束名字，可以执行SQL语句CONSTRAINT.例如：<code>CONSTRAINT  约束名字 约束 (属性名);</code></strong></p><h3 id="索引的操作"><a href="#索引的操作" class="headerlink" title="索引的操作"></a>索引的操作</h3><p>数据库对象索引其实与书的目录非常类似，主要是为了提高从表中检索数据的速度。<br>InnoDB和MyISAM存储引擎支持BTREE类型索引，MEMORY存储引擎支持HASH类型索引，默认为前者索引。<br>MySQL支持6种索引，分别为普通索引、唯一索引、全文索引、单列索引、多列索引和空间索引。</p><h4 id="创建和查看索引"><a href="#创建和查看索引" class="headerlink" title="创建和查看索引"></a>创建和查看索引</h4><p><strong><code>ASC</code>参数用来指定为升序排序，<code>DESC</code>参数用来指定为降序排序</strong></p><h5 id="普通索引"><a href="#普通索引" class="headerlink" title="普通索引"></a>普通索引</h5><p>创表时创建普通索引如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">CREATE TABLE table_name(</div><div class="line">  属性名 数据类型,</div><div class="line">  属性名 数据类型,</div><div class="line">  ......</div><div class="line">  属性名 数据类型,</div><div class="line">  INDEX|KEY [索引名] (属性名1 [(长度)] [ASC|DESC])</div><div class="line">);</div></pre></td></tr></table></figure><p><code>CREATE INDEX 索引名 ON表名(属性名 [(长度)] [ASC|DESC]);</code>在已经存在的表上创建普通索引<br><code>ALTER TABLE table_name ADD INDEX|KEY 索引名 （属性名 [(长度)] [ASC|DESC]);</code>通过SQL语句ALTER TABLE 创建普通索引</p><h5 id="唯一索引"><a href="#唯一索引" class="headerlink" title="唯一索引"></a>唯一索引</h5><p><strong>注意：explain用法<code>EXPLAIN tbl_name或EXPLAIN [EXTENDED] SELECT select_options</code>前者可以得出一个表的字段结构等等，后者主要是给出相关的一些索引信息，而今天要讲述的重点是后者。</strong><br>创建表时创建唯一索引如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">CREATE TABLE table_name(</div><div class="line">  属性名 数据类型,</div><div class="line">  属性名 数据类型,</div><div class="line">  ......</div><div class="line">  属性名 数据类型,</div><div class="line">  UNIQUE INDEX|KEY [索引名] （属性名1 [(长度)] [ASC|DESC])</div><div class="line">);</div></pre></td></tr></table></figure><p><code>CREATE UNIQUE INDEX 索引名 ON表名(属性名 [(长度)] [ASC|DESC]);</code>在已经存在的表上创建唯一索引<br><code>ALTER TABLE table_name ADD UNIQUE INDEX|KEY 索引名 （属性名 [(长度)] [ASC|DESC]);</code>通过SQL语句ALTER TABLE 创建唯一索引</p><h5 id="全文索引"><a href="#全文索引" class="headerlink" title="全文索引"></a>全文索引</h5><p>创建表时创建全文索引如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">CREATE TABLE table_name(</div><div class="line">  属性名 数据类型,</div><div class="line">  属性名 数据类型,</div><div class="line">  ......</div><div class="line">  属性名 数据类型,</div><div class="line">  FULLTEXT INDEX|KEY [索引名] （属性名1 [(长度)] [ASC|DESC])</div><div class="line">  );</div></pre></td></tr></table></figure><p><code>CREATE FULLTEXT INDEX 索引名 ON表名(属性名 [(长度)] [ASC|DESC]);</code>在已经存在的表上创建全文索引<br>  <code>ALTER TABLE table_name ADD FULLTEXT INDEX|KEY 索引名 （属性名 [(长度)] [ASC|DESC]);</code>通过SQL语句ALTER TABLE 创建全文索引</p><h5 id="多列索引"><a href="#多列索引" class="headerlink" title="多列索引"></a>多列索引</h5><p>创建表时创建全文索引如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">CREATE TABLE table_name(</div><div class="line"> 属性名 数据类型,</div><div class="line"> 属性名 数据类型,</div><div class="line"> ......</div><div class="line"> 属性名 数据类型,</div><div class="line"> INDEX|KEY [索引名] （属性名1 [(长度)] [ASC|DESC], </div><div class="line">                     ......</div><div class="line">                     属性名n [(长度)] [ASC|DESC])</div><div class="line">  );</div></pre></td></tr></table></figure><p>在已经存在的表上创建多列索引如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">CREATE INDEX 索引名</div><div class="line">   ON 表名（属性名1 [(长度)] [ASC|DESC],</div><div class="line">      ......</div><div class="line">          属性名n [(长度)] [ASC|DESC]</div><div class="line">   ）;</div></pre></td></tr></table></figure><p>通过SQL语句ALTER TABLE创建多列索引</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">ALTER TABLE table_name(</div><div class="line">  ADD INDEX|KEY 索引名（属性名1 [(长度)] [ASC|DESC],</div><div class="line">                       ......</div><div class="line">                      属性名n [(长度)] [ASC|DESC]</div><div class="line">   ）;</div></pre></td></tr></table></figure><h4 id="删除索引"><a href="#删除索引" class="headerlink" title="删除索引"></a>删除索引</h4><p><code>DROP INDEX index_name ON table_name;</code>删除索引</p><h3 id="视图的操作"><a href="#视图的操作" class="headerlink" title="视图的操作"></a>视图的操作</h3><h4 id="视图的特点"><a href="#视图的特点" class="headerlink" title="视图的特点"></a>视图的特点</h4><p>特点如下：</p><ul><li>视图的列可以来自不同的表，是表的抽象和在逻辑意义上建立的新关系。</li><li>视图是由基本表（实表）产生的表（虚表）。</li><li>视图的建立和删除不影响基本表。</li><li>对视图内容的更新（添加、删除和修改）直接影响基本表。</li><li>当视图来自多个基本表是，不允许添加和删除数据。</li></ul><h4 id="创建视图"><a href="#创建视图" class="headerlink" title="创建视图"></a>创建视图</h4><p><code>CREATE VIEW view_name AS 查询语句;</code>创建视图<br><code>USE view;</code>使用视图</p><h5 id="常量视图"><a href="#常量视图" class="headerlink" title="常量视图"></a>常量视图</h5><p>具体语句如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">CREATE VIEW view_test1</div><div class="line">  AS </div><div class="line">    SELECT 3.1415926;</div></pre></td></tr></table></figure></p><h5 id="封装使用聚合函数（SUM、MIN、MAX、COUNT等）查询语句的视图"><a href="#封装使用聚合函数（SUM、MIN、MAX、COUNT等）查询语句的视图" class="headerlink" title="封装使用聚合函数（SUM、MIN、MAX、COUNT等）查询语句的视图"></a>封装使用聚合函数（SUM、MIN、MAX、COUNT等）查询语句的视图</h5><p>具体语句如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">CREATE VIEW view_test2</div><div class="line">   AS </div><div class="line">     SELECT COUNT(name)</div><div class="line">     FROM database_name;</div></pre></td></tr></table></figure></p><h5 id="封装了实现功能（ORDER-BY）查询语句的视图"><a href="#封装了实现功能（ORDER-BY）查询语句的视图" class="headerlink" title="封装了实现功能（ORDER BY）查询语句的视图"></a>封装了实现功能（ORDER BY）查询语句的视图</h5><p>具体语句如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">CREATE VIEW view_test3</div><div class="line">  AS</div><div class="line">    SELECT name</div><div class="line">       FROM table_name</div><div class="line">         ORDER BY id DESC;</div></pre></td></tr></table></figure></p><h5 id="封装了实现表内连接查询语句的视图"><a href="#封装了实现表内连接查询语句的视图" class="headerlink" title="封装了实现表内连接查询语句的视图"></a>封装了实现表内连接查询语句的视图</h5><p>具体语句如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">CREATE VIEW view_test4</div><div class="line">  AS </div><div class="line">   SELECT s.name</div><div class="line">     FROM t_student as s,t_group as g</div><div class="line">       WHERE s.group_id=g.id AND g.id=2;</div></pre></td></tr></table></figure></p><h5 id="封装了实现表外连接（LEFT-JOIN-和RIGHT-JOIN）查询语句视图"><a href="#封装了实现表外连接（LEFT-JOIN-和RIGHT-JOIN）查询语句视图" class="headerlink" title="封装了实现表外连接（LEFT JOIN 和RIGHT JOIN）查询语句视图"></a>封装了实现表外连接（LEFT JOIN 和RIGHT JOIN）查询语句视图</h5><p>具体语句如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">CREATE VIEW view_test5</div><div class="line">  AS </div><div class="line">    SELECT s.name </div><div class="line">       FROM t_student as s LEFT JOIN t_group as g ON s.group_id=g.id</div><div class="line">        where g.id=2;</div></pre></td></tr></table></figure></p><h5 id="封装了实现子查询相关查询语句的视图"><a href="#封装了实现子查询相关查询语句的视图" class="headerlink" title="封装了实现子查询相关查询语句的视图"></a>封装了实现子查询相关查询语句的视图</h5><p>具体语句如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">CREATE VIEW view_test6</div><div class="line"> AS </div><div class="line"> SELECT s.name</div><div class="line"> FROM t_student AS s</div><div class="line">     WHERE s.grop_id IN(SELECT id FROM t_group);</div></pre></td></tr></table></figure></p><h5 id="封装了实现记录联合（UNION和UNION-ALL）查询语句的视图"><a href="#封装了实现记录联合（UNION和UNION-ALL）查询语句的视图" class="headerlink" title="封装了实现记录联合（UNION和UNION ALL）查询语句的视图"></a>封装了实现记录联合（UNION和UNION ALL）查询语句的视图</h5><p>具体语句如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">CREATE VIEW view_test7</div><div class="line">  AS</div><div class="line">    SELECT id,name FROM t_student</div><div class="line">    UNION ALL</div><div class="line">    SELECT id,name FROM t_group;</div></pre></td></tr></table></figure></p><h4 id="查看视图"><a href="#查看视图" class="headerlink" title="查看视图"></a>查看视图</h4><p><code>USE dababase_name; SHOW TABLES;</code>查看视图名<br><code>USE database_name; SHOW CREATE VIEW viewname;</code>查看视图定义信息<br><code>USE database_name; DESCRIBE | DESC  viewname;</code>查看视图设计信息<br><code>SHOW TABLE STATUS [FROM db_name] [LIKE &#39;pattern&#39;];</code>查看视图（和表）详细信息<br>SHOW TABLE STATUS返回字段含义如下图：<br><img src="/images/mysql/mysql_sta.png" alt=""></p><h4 id="删除视图"><a href="#删除视图" class="headerlink" title="删除视图"></a>删除视图</h4><p><code>USE database_name; DROP VIEW view_name [,view_name] ...;</code>删除视图</p><h4 id="修改视图"><a href="#修改视图" class="headerlink" title="修改视图"></a>修改视图</h4><h5 id="CREATE-OR-REPLACE-VIEW语句修改视图"><a href="#CREATE-OR-REPLACE-VIEW语句修改视图" class="headerlink" title="CREATE OR REPLACE VIEW语句修改视图"></a>CREATE OR REPLACE VIEW语句修改视图</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">`USE database_name;</div><div class="line"> CREATE OR REPLACE VIEW view_selectproduct</div><div class="line">    AS</div><div class="line">       SELECT name</div><div class="line">            FROM  t_products;</div></pre></td></tr></table></figure><h5 id="ALTER-语句修改视图"><a href="#ALTER-语句修改视图" class="headerlink" title="ALTER 语句修改视图"></a>ALTER 语句修改视图</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">`USE database_name;</div><div class="line"> ALTER VIEW view_selectproduct</div><div class="line">    AS</div><div class="line">       SELECT name</div><div class="line">            FROM  t_products;</div></pre></td></tr></table></figure><h4 id="利用视图操作基本表"><a href="#利用视图操作基本表" class="headerlink" title="利用视图操作基本表"></a>利用视图操作基本表</h4><h5 id="检索（查询）数据"><a href="#检索（查询）数据" class="headerlink" title="检索（查询）数据"></a>检索（查询）数据</h5><p><code>SELECT * FROM view_name;</code></p><h5 id="利用视图操作基本表数据"><a href="#利用视图操作基本表数据" class="headerlink" title="利用视图操作基本表数据"></a>利用视图操作基本表数据</h5><ul><li>对视图数据进行添加、删除和更新操作直接影响基本表。</li><li>视图来自多个基本表时，不允许添加和删除数据。</li></ul><p><strong>添加数据操作</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">INSERT INTO view_name(属性1,属性2，属性3...)</div><div class="line"> VALUES(value1,value2,value3...);</div></pre></td></tr></table></figure></p><p><strong>删除数据操作</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">DELETE FROM view_name</div><div class="line">   WHERE name=’属性名‘;</div></pre></td></tr></table></figure></p><p><strong>更新数据操作</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">UPDATE view_name</div><div class="line"> set 属性1=value</div><div class="line">    WHERE 属性2=value；</div></pre></td></tr></table></figure></p><h3 id="触发器的操作"><a href="#触发器的操作" class="headerlink" title="触发器的操作"></a>触发器的操作</h3><p>在具体的应用中，之所以经常使用触发器数据对象，是由与该对象能够加强数据库表中数据的完整性约束和业务规则等。</p><h4 id="创建有一条执行语句的触发器"><a href="#创建有一条执行语句的触发器" class="headerlink" title="创建有一条执行语句的触发器"></a>创建有一条执行语句的触发器</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">create trigger trigger_name</div><div class="line">   BEFORE|AFTER trigger_EVENT</div><div class="line">      ON TABLE_NAME FOR EACH ROW trigger_STMT;</div></pre></td></tr></table></figure><h4 id="创建包含多条执行语句的触发器"><a href="#创建包含多条执行语句的触发器" class="headerlink" title="创建包含多条执行语句的触发器"></a>创建包含多条执行语句的触发器</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">create trigger trigger_name</div><div class="line">   BEFORE|AFTER trigger_EVENT</div><div class="line">    ON TABLE_NAME FOR EACH ROW</div><div class="line">     BEGIN</div><div class="line">     trigger_STMT</div><div class="line">     END;</div></pre></td></tr></table></figure><h4 id="查看触发器"><a href="#查看触发器" class="headerlink" title="查看触发器"></a>查看触发器</h4><p><code>SHOW TRIGGERS;</code>语句查看触发器<br>通过查看系统表triggers实现查看触发器，如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">USE information_schema;</div><div class="line">SELECT * FROM triggers (WHERE TRIGGER_NAME=&apos;trigger_name&apos;) \G</div></pre></td></tr></table></figure></p><h4 id="删除触发器"><a href="#删除触发器" class="headerlink" title="删除触发器"></a>删除触发器</h4><p><code>DROP TRIGGER trigger_name;</code>删除触发器</p><h3 id="数据操作"><a href="#数据操作" class="headerlink" title="数据操作"></a>数据操作</h3><h4 id="插入数据"><a href="#插入数据" class="headerlink" title="插入数据"></a>插入数据</h4><h5 id="插入一部分数据"><a href="#插入一部分数据" class="headerlink" title="插入一部分数据"></a>插入一部分数据</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">INSERT INTO table_name(field1,field2,field3,......fieldn)</div><div class="line">  VALUES(value1,value2,value3......valuen);</div></pre></td></tr></table></figure><h5 id="插入完整数据"><a href="#插入完整数据" class="headerlink" title="插入完整数据"></a>插入完整数据</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">INSERT INTO table_name</div><div class="line">  VALUES(value1,value2,value3......valuen);</div></pre></td></tr></table></figure><h5 id="插入多天数据"><a href="#插入多天数据" class="headerlink" title="插入多天数据"></a>插入多天数据</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">#插入多条部分数据</div><div class="line">INSERT INTO table_name(field1,field2,field3,...fieldn)</div><div class="line">  VALUES(value11,value21,value31...valuen1),</div><div class="line">        (value11,value21,value31...valuen1),</div><div class="line">        (value11,value21,value31...valuen1),</div><div class="line">         ......</div><div class="line">        (value1m,value2m,value3m...valuenm);</div><div class="line"></div><div class="line">#插入多条完整数据</div><div class="line">INSERT INTO table_name</div><div class="line">  VALUES(value11,value21,value31...valuen1),</div><div class="line">        (value11,value21,value31...valuen1),</div><div class="line">        (value11,value21,value31...valuen1),</div><div class="line">         ......</div><div class="line">        (value1m,value2m,value3m...valuenm);</div></pre></td></tr></table></figure><h5 id="插入查询结果"><a href="#插入查询结果" class="headerlink" title="插入查询结果"></a>插入查询结果</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">INSERT INTO table_name1(field11,field12,field13,...field1n)</div><div class="line">    SELECT (field21,field22,field23,...field2n)</div><div class="line">        FROM table name2</div><div class="line">          WHERE ...</div></pre></td></tr></table></figure><h4 id="更新数据记录"><a href="#更新数据记录" class="headerlink" title="更新数据记录"></a>更新数据记录</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">UPDATE table_name</div><div class="line">  SET field1=value1,</div><div class="line">      field2=value2,</div><div class="line">      field3=value3,</div><div class="line">  WHERE CONDITION</div></pre></td></tr></table></figure><h4 id="删除特定数据记录"><a href="#删除特定数据记录" class="headerlink" title="删除特定数据记录"></a>删除特定数据记录</h4> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">DELETE FROM table_name</div><div class="line">WHERE CONDITION</div></pre></td></tr></table></figure><h3 id="单表数据记录查询"><a href="#单表数据记录查询" class="headerlink" title="单表数据记录查询"></a>单表数据记录查询</h3><h4 id="简单数据查询"><a href="#简单数据查询" class="headerlink" title="简单数据查询"></a>简单数据查询</h4><h5 id="一般查询"><a href="#一般查询" class="headerlink" title="一般查询"></a>一般查询</h5><p><code>SELECT field1 field2 ...fieldn FROM table_name;</code> 查询指定字段数据<br><code>SELECT * FROM table_name;</code> 查询所有字段数据<br><code>SELECT DISTINCT field1 field2 ...fieldn FROM table_name;</code>避免数据重复查询–DISTINCT</p><h5 id="实现数学四则运算数据查询"><a href="#实现数学四则运算数据查询" class="headerlink" title="实现数学四则运算数据查询"></a>实现数学四则运算数据查询</h5><p>mysql支持的关系运算符如下：<br><img src="/images/mysql/mysql_sta.png" alt=""><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">SELECT field1 [AS] otherfield1,field2 [AS] otherfield2,...fieldn [AS] otherfieldn</div><div class="line">FROM table_name</div><div class="line">#例如：</div><div class="line">SELECT ename,sal*12 [AS] yearsalary</div><div class="line">FROM t_employee;</div></pre></td></tr></table></figure></p><h5 id="设置显示格式数据查询"><a href="#设置显示格式数据查询" class="headerlink" title="设置显示格式数据查询"></a>设置显示格式数据查询</h5><p>如下显示的是以固定的格式（ename雇员的年薪为：sal）显示查询到数据<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">SELECT CONCAT(ename,&apos;雇员的年薪为：&apos;,sal*12) yearsalary</div><div class="line">   FROM t_employee;</div></pre></td></tr></table></figure></p><p>结果为：<br><img src="/images/mysql/mysql_a.png" alt=""></p><h4 id="条件数据记录查询"><a href="#条件数据记录查询" class="headerlink" title="条件数据记录查询"></a>条件数据记录查询</h4><p>条件查询的语法格式<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">SELECT field1、field2 ...field3</div><div class="line"> FROM table_name</div><div class="line"> WNERE CONDITION;</div></pre></td></tr></table></figure></p><p><strong>带关系运算符和逻辑运算符的条件数据查询</strong><br><img src="/images/mysql/mysql_bijiao.png" alt=""><br><img src="/images/mysql/mysql_yusuanfu.png" alt=""><br><strong>带（not）between value1 and value2查询（不）符合范围之内</strong><br><strong>IS （NOT） NULL查询是（不是）空值 </strong><br><strong>带IN关键字的集合查询</strong><br>注意：IN查询时，查询集合中包括NULL,则不会影响结果；NOT IN查询时，查询集合中包括NULL,则查询不到结果。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">SELECT field1 field2 ...fieldn</div><div class="line">FROM table_name</div><div class="line">WHERE field IN(value1,value2,value3,...,valuen);//在集合中</div><div class="line">WHERE field NOT IN(value1,value2,value3,...,valuen);//不在集合中</div></pre></td></tr></table></figure></p><p><strong>带LIKE关键字模糊查询</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">SELECT field1 field2 ...fieldn</div><div class="line">FROM table_name</div><div class="line">WHERE field [NOT] LIKE value;</div></pre></td></tr></table></figure></p><p>LIKE支持的通配符如下：</p><ul><li>“_”通配符，该通配符值能匹配单个字符</li><li>“%”通配符，该通配符可以匹配任意长度单位字符串，可以0个字符、1个或者更多</li></ul><p><strong>排序数据记录查询</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">SELECT field1 field2 ...fieldn</div><div class="line">FROM table_name</div><div class="line">WHERE CONDITION</div><div class="line">ORDER BY fieldm1 [ASC|DESC] [,fieldm2 [ASC|DESC],];</div></pre></td></tr></table></figure></p><p><strong>限制数据记录查询数量</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">SELECT field1 field2 ...fieldn</div><div class="line">FROM table_name</div><div class="line"> where CONDITION</div><div class="line"> LIMIT OFFSET_START,ROW_COUNT;</div><div class="line">#OFFSET_START为初始位置，可以选择不指定数据。</div></pre></td></tr></table></figure></p><p><strong>统计函数和分组数据记录查询</strong></p><ul><li>COUNT()：记录条数。</li><li>AVG()：平均值。</li><li>SUN():总和。</li><li>MAX():最大值。</li><li>MIN():最小值。</li></ul><p>注意：如果操作表中没有数据，则COUNT()函数返回为0，其它返回为NULL.</p><h4 id="分组数据查询"><a href="#分组数据查询" class="headerlink" title="分组数据查询"></a>分组数据查询</h4><p>分组查询的简单格式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">SELECT function()</div><div class="line">  FROM table_name</div><div class="line">  WHER CONDITION</div><div class="line">   GROUP BY field;</div></pre></td></tr></table></figure></p><p>下面为分组查询不同情况：</p><ul><li>function()为*时是简单分组查询</li><li>function()为GROUP_CONCAT(field)时实现统计功能分组查询，如下：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">SELECT deptno,GROUP_CONCAT(ename),COUNT(ename) number</div><div class="line"> FROM t_employee</div><div class="line"> GROUP BY deptno;</div></pre></td></tr></table></figure><ul><li>多字段分组查询</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">SELECT GROUP_COUNT(field),function(field)</div><div class="line">FROM table_name</div><div class="line">WHERE CONDITION</div><div class="line">GROUP BY field1,field2,...fieldn;</div></pre></td></tr></table></figure><ul><li>实现HAVING字句限定分组查询</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">SELECT function(field)</div><div class="line">FROM table_name</div><div class="line">WHERE CONDITION</div><div class="line">GROUP BY field1,field2,...fieldn</div><div class="line">HAVING CONDITION;</div><div class="line"></div><div class="line">#例如：</div><div class="line">SELECT deptno,AVG(sal) average,GROUP_CONCAT(ename) ename,COUNT(ename) number</div><div class="line">FROM t_employee</div><div class="line">GROUP BY deptno</div><div class="line">HAVING AVG(sal)&gt;2000;</div></pre></td></tr></table></figure><h4 id="自定义排序"><a href="#自定义排序" class="headerlink" title="自定义排序"></a>自定义排序</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">原表 user：</div><div class="line">id  name   roleId</div><div class="line">1    aaa     1</div><div class="line">2    bbb     2</div><div class="line">3    ccc     3</div><div class="line">4    ddd     4</div><div class="line">5    eee     5</div><div class="line">- MySQL可以通过field()函数自定义排序，格式：field(value,str1,str2,str3,str4)，value与str1、str2、str3、str4比较，返回1、2、3、4，如遇到null或者不在列表中的数据则返回0.</div><div class="line">例如：select * from user order by field(roleId,2,3,4,1,5);</div><div class="line">结果：</div><div class="line">id  name   roleId</div><div class="line">2    bbb     2</div><div class="line">3    ccc     3</div><div class="line">4    ddd     4</div><div class="line">1    aaa     1</div><div class="line">5    eee     5</div><div class="line"></div><div class="line">- locate（substr,str）函数返回子串substr在字符串str中第一次出现的位置，可以根据该函数进行排序</div><div class="line">例如：select * from user order by locate(id,&apos;2,3,1,5,4&apos;);</div><div class="line">结果：</div><div class="line">id  name   roleId</div><div class="line">2    bbb     2</div><div class="line">3    ccc     3</div><div class="line">1    aaa     1</div><div class="line">5    eee     5</div><div class="line">4    ddd     4</div></pre></td></tr></table></figure><h3 id="多表数据记录查询"><a href="#多表数据记录查询" class="headerlink" title="多表数据记录查询"></a>多表数据记录查询</h3><h4 id="关系数据库操作"><a href="#关系数据库操作" class="headerlink" title="关系数据库操作"></a>关系数据库操作</h4><h5 id="并（UNION）"><a href="#并（UNION）" class="headerlink" title="并（UNION）"></a>并（UNION）</h5><p>UNION指令的目的是将两个SQL语句的结果合并起来.UNION的一个限制是两个SQL语句所产生的栏位需要是同样的资料种类。另外，当我们用UNION这个指令时，我们只会看到不同的资料值（类似于SELECT DISTINCT），而UNION ALL会将每一笔符合条件的资料都显示出来，无论资料有没有重复。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">SELECT DATA FROM database1</div><div class="line">UNION ALL</div><div class="line">SELECT DATA FROM database2;</div></pre></td></tr></table></figure></p><h5 id="笛卡尔积"><a href="#笛卡尔积" class="headerlink" title="笛卡尔积"></a>笛卡尔积</h5><p><code>SELECT *FROM table1 CROSS JOIN table2;</code>交叉连接<br>笛卡尔积在SQL中的实现方式既是交叉连接(Cross Join)。所有连接方式都会先生成临时笛卡尔积表，笛卡尔积是关系代数里的一个概念，表示两个表中的每一行数据任意组合.</p><h5 id="内连接-INNER-JOIN"><a href="#内连接-INNER-JOIN" class="headerlink" title="内连接(INNER JOIN)"></a>内连接(INNER JOIN)</h5><p>内连接语法形式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">SELECT field1 field2...fieldn</div><div class="line">FROM join_tablename1 INNER JOIN join_tablename2 [INNER JOIN join_tablename]</div><div class="line">ON join_condition;</div></pre></td></tr></table></figure></p><p><strong>自然连接</strong></p><p>在表关系的笛卡尔积中，首先根据表关系中相同名称的字段自动进行记录匹配，然后去掉重复的字段。<br>是一种特殊的等值连接，它要求两个关系进行比较的分量必须是相同的属性组，并且在结果集中将重复属性列去掉。<br>一个简单的例子，将下列关系R和S进行自然连接：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">SELECT *</div><div class="line">from R natural join S;</div><div class="line"></div><div class="line">R：</div><div class="line">A    B     C</div><div class="line">a    b     c</div><div class="line">b    a     d</div><div class="line">c    d     e</div><div class="line">d    f     g</div><div class="line">S：</div><div class="line">A    C    D</div><div class="line">a    c    d</div><div class="line">d    f    g</div><div class="line">b    d    g</div></pre></td></tr></table></figure><p>首先要对两个关系中相同属性组的分量进行比较，即比较R.A，R.C和S.A,S.C。 显然在R中只有第一行和第二行满足条件，因此进行连接得到结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">ABCD</div><div class="line">abcd</div><div class="line">badg</div></pre></td></tr></table></figure></p><p><strong>等值连接</strong><br>表关系的笛卡尔积中，选择所匹配字段值相等（=符号）的数据记录。<br>下面为等值连接与自然连接的区别：</p><ul><li>等值连接中不要求相等属性值的属性名相同，而自然连接要求相等属性值的属性名必须相同，即两关系只有在同名属性才能进行自然连接。</li><li>等值连接不将重复属性去掉，而自然连接去掉重复属性，也可以说，自然连接是去掉重复列的等值连接。<br>一个简单的例子，将下列关系R和S进行等值连接：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">select *</div><div class="line">from R inner join S</div><div class="line">ON  R.B=S.C;</div><div class="line">R：</div><div class="line">A    B     C</div><div class="line">a    b     c</div><div class="line">b    a     d</div><div class="line">c    d     e</div><div class="line">d    f     g</div><div class="line">S：</div><div class="line">A    C    D</div><div class="line">a    c    d</div><div class="line">d    f    g</div><div class="line">b    d    g</div></pre></td></tr></table></figure><p>比较R.B=S.C。 显然在R中只有第一行和第二行满足条件，因此进行连接得到结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">R.AR.BR.CS.A S.C S.D</div><div class="line">c       d       e     b    d   g</div><div class="line">d       f       g     d    f   g</div></pre></td></tr></table></figure></p><p><strong>不等查询</strong><br>表关系的笛卡尔积中，选择所匹配字段不相等的数据操作。<br>内连接查询中的不等连接，就是在关键字ON后的匹配条件中通过除了等于关系运算符来实现不等条件外，可以使用的关系运算符包含”&gt;””&gt;=””&lt;””&lt;=”和”!=”等运算符号。<br>一个简单的例子，将下列关系R和S进行不等值连接：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">select *</div><div class="line">from R inner join S</div><div class="line">ON  R.B!=S.C AND R.A!=&quot;c&quot;;</div><div class="line">R：</div><div class="line">A    B     C</div><div class="line">a    b     c</div><div class="line">b    a     d</div><div class="line">c    d     e</div><div class="line">d    f     g</div><div class="line">S：</div><div class="line">A    C    D</div><div class="line">a    c    d</div><div class="line">d    f    g</div><div class="line">b    d    g</div></pre></td></tr></table></figure><p>比较R.B=S.C 和 R.A!=”c”。 显然在R中只有第一行和第二行满足条件，因此进行连接得到结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">R.AR.BR.CS.A S.C S.D</div><div class="line">c       d      e      b    d   g</div></pre></td></tr></table></figure></p><h5 id="外连接"><a href="#外连接" class="headerlink" title="外连接"></a>外连接</h5><p>所谓外连接(OUTER JOIN),就是在表关系的笛卡尔积数据记录中，不仅保留关系中所有匹配的数据记录，而且还会保留部分不匹配的数据记录。按照保留不匹配的数据记录来源可以分为左外连接（LEFT OUTER JOIN）、右外连接（RIGHT OUTER JOIN)和全外连接（FULL OUTER JOIN).</p><p>一个简单的例子，为外连接的各种情况：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">a表     id   name     </div><div class="line">        1   张3            </div><div class="line">        2   李四                 </div><div class="line">        3   王武           </div><div class="line">b表     id jod parent_id</div><div class="line">1 23 1</div><div class="line">2 34 2</div><div class="line">3 34 4</div><div class="line"></div><div class="line">  左连接   </div><div class="line">  select   a.*,b.*   from   a   left   join   b     on   a.id=b.parent_id       </div><div class="line">  结果是     </div><div class="line">  1   张3                   1     23     1   </div><div class="line">  2   李四                  2     34     2   </div><div class="line">  3   王武                  null   </div><div class="line"></div><div class="line"> </div><div class="line"></div><div class="line"> 右连接   </div><div class="line">  select   a.*,b.*   from   a   right   join   b     on   a.id=b.parent_id       </div><div class="line">  结果是     </div><div class="line">  1   张3                    1     23     1   </div><div class="line">  2   李四                   2     34     2   </div><div class="line">  null                      3     34     4   </div><div class="line">    </div><div class="line"> 完全连接   </div><div class="line">  select   a.*,b.*   from   a   full   join   b     on   a.id=b.parent_id   </div><div class="line"></div><div class="line">  结果是     </div><div class="line">  1   张3                  1     23     1   </div><div class="line">  2   李四                 2     34     2   </div><div class="line">  null               　　  3     34     4   </div><div class="line">  3   王武                 null</div></pre></td></tr></table></figure><h5 id="合并查询记录结果"><a href="#合并查询记录结果" class="headerlink" title="合并查询记录结果"></a>合并查询记录结果</h5><p>语法如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">SELECT field1 field2  ...fieldn</div><div class="line">    FROM tablename1</div><div class="line">UNION |UNION ALL</div><div class="line">SELECT field1 field2  ...fieldn</div><div class="line">    FROM tablename2</div><div class="line">UNION |UNION ALL</div><div class="line">SELECT field1 field2  ...fieldn</div><div class="line">    FROM tablename3</div><div class="line">UNION |UNION ALL</div></pre></td></tr></table></figure></p><h5 id="子查询"><a href="#子查询" class="headerlink" title="子查询"></a>子查询</h5><p>例子如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">- 单行子查询</div><div class="line">        select ename,deptno,sal</div><div class="line">        from emp</div><div class="line">        where deptno=(select deptno from dept where loc=&apos;NEW YORK&apos;)；</div><div class="line"></div><div class="line">- 多行子查询</div><div class="line">        SELECT ename,job,sal</div><div class="line">        FROM EMP</div><div class="line">        WHERE deptno in ( SELECT deptno FROM dept WHERE dname LIKE &apos;A%&apos;)；</div><div class="line"></div><div class="line">- 多列子查询</div><div class="line">        SELECT deptno,ename,job,sal</div><div class="line">        FROM EMP</div><div class="line">        WHERE (deptno,sal) IN (SELECT deptno,MAX(sal) FROM EMP GROUP BY deptno)；</div><div class="line"></div><div class="line">- 内联视图子查询</div><div class="line">       (1)SELECT ename,job,sal,rownum</div><div class="line">          FROM (SELECT ename,job,sal FROM EMP ORDER BY sal)；</div><div class="line">       (2)SELECT ename,job,sal,rownum</div><div class="line">          FROM ( SELECT ename,job,sal FROM EMP ORDER BY sal)</div><div class="line">          WHERE rownum&lt;=5；</div><div class="line">  </div><div class="line">- 在HAVING子句中使用子查询</div><div class="line">        SELECT deptno,job,AVG(sal) FROM EMP GROUP BY deptno,job HAVING AVG(sal)&gt;(SELECT sal FROM EMP WHERE ename=&apos;MARTIN&apos;)； ·</div></pre></td></tr></table></figure></p><h3 id="使用MySQL运算符"><a href="#使用MySQL运算符" class="headerlink" title="使用MySQL运算符"></a>使用MySQL运算符</h3><p>算术、比较、逻辑和位运算符</p><h4 id="算术运算符"><a href="#算术运算符" class="headerlink" title="算术运算符"></a>算术运算符</h4><p>如下图：<img src="/images/mysql/mysql_ss.png" alt=""><br>注意：”&gt;”、”&lt;”、”&gt;=”和”=&lt;”比较运算符不能操作NULL(空值)。</p><h4 id="比较运算符"><a href="#比较运算符" class="headerlink" title="比较运算符"></a>比较运算符</h4><p>如下图：<img src="/images/mysql/mysql_bjiao.png" alt=""><br>特殊功能运算符（实现正则表达式匹配的需要REGEXP）：<br>如下图：<img src="/images/mysql/mysql_ts.png" alt=""><br>如下图：<img src="/images/mysql/mysql_ts2.png" alt=""></p><h4 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h4><p>如下图：<br><img src="/images/mysql/mysql_luoji.png" alt=""></p><h4 id="位运算符"><a href="#位运算符" class="headerlink" title="位运算符"></a>位运算符</h4><p><img src="/images/mysql/mysql_w.png" alt=""></p><h3 id="MySQL常用的函数"><a href="#MySQL常用的函数" class="headerlink" title="MySQL常用的函数"></a>MySQL常用的函数</h3><h4 id="使用字符串函数"><a href="#使用字符串函数" class="headerlink" title="使用字符串函数"></a>使用字符串函数</h4><p><img src="/images/mysql/mysql_zfc.png" alt=""></p><h5 id="合并字符串函数"><a href="#合并字符串函数" class="headerlink" title="合并字符串函数"></a>合并字符串函数</h5><p><code>CONCAT(S1,S2...SN)</code><br><code>CONCAT_WS(SEP,S1,S2...SN)</code> SEP为分隔符可以为一个字符串，也可以为其他参数，如果为NULL时返回NULL，其它位置的NULL则可忽略;</p><h5 id="比较字符串大小函数STRCMP"><a href="#比较字符串大小函数STRCMP" class="headerlink" title="比较字符串大小函数STRCMP()"></a>比较字符串大小函数STRCMP()</h5><p><code>STRCMP(str1,str2);</code>str1&gt;str2为1，str1&lt; str2为-1，str1=str2为0</p><h5 id="获取字符串的长度函数LENGTH-和字符数函数CHAT-LENGTH"><a href="#获取字符串的长度函数LENGTH-和字符数函数CHAT-LENGTH" class="headerlink" title="获取字符串的长度函数LENGTH()和字符数函数CHAT_LENGTH()"></a>获取字符串的长度函数LENGTH()和字符数函数CHAT_LENGTH()</h5><p><code>LENGTH(str);</code>参数str的长度<br><code>CHAR_LENGTH(str);</code>参数str的字符数</p><h5 id="大小写转换"><a href="#大小写转换" class="headerlink" title="大小写转换"></a>大小写转换</h5><p><code>UPPER(S)或者UCASE(S)</code>转换为大写<br><code>LOWER(S)或者LCASE(S)</code>转换为小写</p><h5 id="查找字符串位置"><a href="#查找字符串位置" class="headerlink" title="查找字符串位置"></a>查找字符串位置</h5><p><code>FIND_IN_SET(str1,str2);</code>返回字符串str2中与str1相匹配的字符串位置，str2包含若干个用逗号隔开的字符串。<br><code>FIELD(str,str1,str2...);</code>返回一个与字符串str匹配的位置（str1位置为1开始）</p><h5 id="返回字符串相匹配的开始位置"><a href="#返回字符串相匹配的开始位置" class="headerlink" title="返回字符串相匹配的开始位置"></a>返回字符串相匹配的开始位置</h5><p><code>LOCATE(str1,str)、POSITION(str1 IN str)和INSTR(str,str1)</code>在str中返回str1的开始位置。</p><h5 id="从现有字符串中截取子字符串"><a href="#从现有字符串中截取子字符串" class="headerlink" title="从现有字符串中截取子字符串"></a>从现有字符串中截取子字符串</h5><p><code>LEFT(str ,num)</code>返回字符串中str中包含前num个字母（从左边数）的字符串。<br><code>RIGHT(str ,num)</code>返回字符串中str中包含后num个字母（从左边数）的字符串。</p><h5 id="去除字符串的首尾空格"><a href="#去除字符串的首尾空格" class="headerlink" title="去除字符串的首尾空格"></a>去除字符串的首尾空格</h5><p><code>LTRIM(str);</code>去除字符串开始处空格<br><code>RTRIM(str);</code>去除字符串结束处空格<br><code>TRIM(str);</code>去除字符串首尾空格</p><h5 id="替代字符串"><a href="#替代字符串" class="headerlink" title="替代字符串"></a>替代字符串</h5><p><code>INSERT(str,pos,len,newstr);</code>字符串中的pos位置开始长度为len的字符串用字符串newstr来替换。如果参数pos的值超过字符串的长度，这返回值为原始字符串str.如果len的长度大于原来字符串（str)中所剩字符串的长度，则从位置pos开始进行全部替换。若任何一个参数为NULL，则返回Null.<br><code>REPLACE(str,substr,newstr);</code>字符串substr用字符串newstr来替代。</p><h4 id="使用数值函数"><a href="#使用数值函数" class="headerlink" title="使用数值函数"></a>使用数值函数</h4><p>常用的数值函数：<br><img src="/images/mysql/mysql_shuzuhanshu.png" alt=""></p><h5 id="0-1随机数"><a href="#0-1随机数" class="headerlink" title="0~1随机数"></a>0~1随机数</h5><p><code>RAND();</code>完全随机<br><code>RAND(X);</code>X相同时返回相同的值</p><h5 id="整数随机数"><a href="#整数随机数" class="headerlink" title="整数随机数"></a>整数随机数</h5><p><code>CEIl(X)或CEILING(X);</code>大于或者等于数值X的最小整数<br><code>FLOOR(X);</code>小于或者等于数值X的最大整数</p><h5 id="截取数值函数"><a href="#截取数值函数" class="headerlink" title="截取数值函数"></a>截取数值函数</h5><p><code>TRUNCATE(x,y);</code>返回数值x保留到小数点后y位的值，y可以为负数。</p><h5 id="四舍五入"><a href="#四舍五入" class="headerlink" title="四舍五入"></a>四舍五入</h5><p><code>ROUND(x,y);</code> 返回数值x保留到小数点后y位的值，在具体截取数值是需要进行四舍五入的操作。单没有y时默认为四舍五入到整数。</p><h4 id="使用日期和时间函数"><a href="#使用日期和时间函数" class="headerlink" title="使用日期和时间函数"></a>使用日期和时间函数</h4><p>常用的时间日期函数：<br><img src="/images/mysql/mysql_timehanshu.png" alt=""></p><h5 id="获取当前时间"><a href="#获取当前时间" class="headerlink" title="获取当前时间"></a>获取当前时间</h5><p><strong>当前时间</strong><br><code>NOW(),CURRENT_TIMESTAMP(),LOCALTIME(),SYSDATE();</code>2017-03-20 17:38:50<br><code>CURDATE(),CURRENT_DATE();</code>2017-05-02<br><code>CURTIME(),CURRENT_TIME();</code>16:29:59<br><code>UNIX_TIMESTAMP(NOW());</code>unix格式，可以不用参数表示当前时间，从1970年1月1号开始计算，以秒为单位。<br><code>FROM_UNIXTIME(UNIX_TIMESTAMP(NOW()));</code>把NUIX格式转换为普通格式同NOW()格式。<br><code>UTC_DATE();</code>UTC日期 2012-05-22<br><code>UTC_TIME();</code>UTC时间 13:00:01</p><p><strong>获取时间和日期的各个部分</strong><br>获取时间和日期的各个部分的功能如下：<br><img src="/images/mysql/mysql_timeq.png" alt=""><br>关于月份：<br><code>MONTH(NOW());</code>月<br><code>MONTHNAME(NOW());</code>月<br>关于星期：<br><img src="/images/mysql/mysql_xq.png" alt=""><br>关于天的函数：<br><code>DAYOFYEAR(NOW());</code>年中第几天<br><code>DAYOFMONTH(NOW());</code>月中第几天<br><strong>获取指定值得EXTRACT()函数</strong><br><code>EXTRACT(tye FROM date);</code>函数会从时间和日期参数中获取指定类型type的值。关于type参数的值可以是YEAR、MONTH、DAY、HOUR、MINUTE和SECOND。</p><p><strong>计算日期和时间函数</strong><br><code>TO_DAYS(date);</code>从0000年1月1日开始算起多少天。<br><code>FROM_DAYS(TO_DAYS(NOW()));</code>一段时间后日期和时间。<br><code>DATEDIFF(DATE1,DATE2);</code>日期参数之间的相隔天数。<br><code>ADDTIME(DATE,n);</code>date加上n秒后的时间。<br><code>SUBTIME(DATE,n);</code>date减上n秒后的时间。<br><code>ADDDATE(DATE,n);</code>date加上n天后的日期。<br><code>SUBDATE(DATE,n);</code>date减上n天后的日期。<br>关于ADDDATE()和SUBDATE()函数另外用法：<br><code>ADDDATE(d,INTERVAL expr type);</code>日期d加上一段时间后的日期，expr决定时间的长度，type决定了操作对象。<br><code>SUBDATE(d,INTERVAL expr type);</code>日期d减去一段时间后的日期，expr决定时间的长度，type决定了操作对象。<br>参数type类型：<br><img src="/images/mysql/mysql_timedate.png" alt=""><br>例子如下：<br><img src="/images/mysql/mysql_caozuoriqi.png" alt=""></p><h4 id="使用系统信息函数"><a href="#使用系统信息函数" class="headerlink" title="使用系统信息函数"></a>使用系统信息函数</h4><h5 id="常用系统信息函数"><a href="#常用系统信息函数" class="headerlink" title="常用系统信息函数"></a>常用系统信息函数</h5><p><img src="/images/mysql/mysql_xt.png" alt=""></p><h4 id="其它函数"><a href="#其它函数" class="headerlink" title="其它函数"></a>其它函数</h4><h5 id="流程函数"><a href="#流程函数" class="headerlink" title="流程函数"></a>流程函数</h5><p>如下：<br><img src="/images/mysql/mysql_liuc.png" alt=""></p><h5 id="特殊函数"><a href="#特殊函数" class="headerlink" title="特殊函数"></a>特殊函数</h5><p>如下：<br><img src="/images/mysql/mysql_tes.png" alt=""></p><h3 id="存储过程和函数的操作"><a href="#存储过程和函数的操作" class="headerlink" title="存储过程和函数的操作"></a>存储过程和函数的操作</h3><p>存储过程和函数的执行效率要比在程序中拼sql语句的执行效率要高。<br>存储过程与函数区别：<br>函数必须有返回值，而存储过程则没有，存储过程的参数类型远远多于函数。<br><img src="/images/mysql/mysql_hanshu.png" alt=""></p><h4 id="创建存储过程和函数"><a href="#创建存储过程和函数" class="headerlink" title="创建存储过程和函数"></a>创建存储过程和函数</h4><h5 id="创建存储过程语法形式"><a href="#创建存储过程语法形式" class="headerlink" title="创建存储过程语法形式"></a>创建存储过程语法形式</h5><p>如下图：<br><img src="/images/mysql/mysql_cuncgc.png" alt=""></p><p><img src="/images/mysql/mysql_ccccc.png" alt=""></p><h5 id="创建函数语法形式"><a href="#创建函数语法形式" class="headerlink" title="创建函数语法形式"></a>创建函数语法形式</h5><p><img src="/images/mysql/mysql_Bnnn.png" alt=""></p><h5 id="创建简单的存储过程和函数"><a href="#创建简单的存储过程和函数" class="headerlink" title="创建简单的存储过程和函数"></a>创建简单的存储过程和函数</h5><p>存储过程简单sql语句：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">USE company;</div><div class="line"></div><div class="line">DELIMITER $$</div><div class="line">CREATE PROCEDURE proce_employee_sal()</div><div class="line">COMMENT&apos;查询所有雇员的工资&apos;</div><div class="line">BEGIN </div><div class="line">    SELECT sal</div><div class="line">    FROM t_employee;</div><div class="line">END$$</div><div class="line">DELIMITER ;</div></pre></td></tr></table></figure></p><p>函数简单SQL语句：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">USE company;</div><div class="line"></div><div class="line">DELIMITER $$</div><div class="line">CREATE FUNCTION func_employee_sal(empno INT(11))</div><div class="line">    RETURNS DOUBLE(10,2)</div><div class="line">COMMENT&apos;查询所有雇员的工资&apos;</div><div class="line">BEGIN </div><div class="line">   RETURN (SELECT sal</div><div class="line">    FROM t_employee</div><div class="line">    WHERE t_employee.empno=empno);</div><div class="line">END$$</div><div class="line">DELIMITER ;</div></pre></td></tr></table></figure></p><h3 id="MySQL事务"><a href="#MySQL事务" class="headerlink" title="MySQL事务"></a>MySQL事务</h3><p>当多个用户访问同一份数据，一个用户在更改数据的过程中可能有其他客户同时发起更改请求，为了保证数据库记录的更新从一个一致性状态更改为另外一个一致性状态，使用事务处理是非常必要的，事务有以下4个特性：</p><ul><li>原子性（Atimicity):事务中所有的操作视为一个原子单位，即对事务所进行的数据修改等操作只能完全提交或者完全回滚。</li><li>一致性（Consistency):事务在完成时，必须是所有的数据从一种一致性状态变更为另外一种一致性状态，所有的变更都必须应用于事务的修改，以确保数据的完整性。</li><li>隔离性（ISOLATION):一个事务中的操作语句所做的修改必须与其他事务所做的修改相隔离。</li><li>持久性（Durability):事务完成后，所做的修改对数据的影响是永久的，即使系统重启或者出现系统故障数据仍可以恢复。</li></ul><h3 id="MySQL数据库维护和性能提高"><a href="#MySQL数据库维护和性能提高" class="headerlink" title="MySQL数据库维护和性能提高"></a>MySQL数据库维护和性能提高</h3><h4 id="MySQL数据库性能优化"><a href="#MySQL数据库性能优化" class="headerlink" title="MySQL数据库性能优化"></a>MySQL数据库性能优化</h4><p>建议如下：</p><ul><li>MySQL软件具有特定的硬件建议，在具体安装和使用数据库软件时，该软件所依托的计算机服务器最好能够遵循这些硬件建议。一般来说MySQL软件应该运行在自己的专用计算机服务器上。</li><li>MySQL软件安装成功后，会进行一系列的默认配置，这些配置开始通常是比较适合的，但是一段时间后，就需要调整内存分配、缓存区大小。可以通过执行SHOW VARIABLES 和SHOW STATES来实现。</li><li>MySQL软件是一个多用户多线程的数据库管理系统，对于该类型的服务器，经常会同时执行多个任务。如果这些任务中的某一个执行缓慢，则其他所有任务都会执行缓慢。为了解决这个问题，可以通过执行SQL语句show processlist显示所有的活动进程，或者通过执行kill命令终结消耗太多资源的进程。</li><li>通过SELECT语句实现多表查询时，应该多次试验连接和子查询等各种方式，找出最佳的方式。在具体判断select语句执行性能时，可以通过explain查看select语句的执行情况。</li><li>使用数据储存过程比一条一条执行语句速度要快许多。</li><li>不要查找比需求还要多的数据内容，换言之，不要执行“select *”语句，除非要真正需要查询所有字段。</li><li>通过UNION关键字连接的select语句，替代包含一系列复杂OR条件的SELECT语句，可以极大的改进性能。</li><li>数据库对象索引可以改善数据检索的性能，但会损失数据CUD操作（数据插入、数据更新和删除）性能。因此不经常查询的表，最好不要创建索引。</li><li>关键字LIKE的执行效率很低，一般来说，会通过“full text”来替代关键字LIKE;</li><li>数据库中的表时不断变化的实体。一组结构优良的表，使用一段时间后，表的使用和内容就会需要进行更改，因此当初理想的优化和配置就需要改变。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;   最近在看《MySQL数据库应用从入门到精通》这本书是基于MySQL5.5版本的，下面是看书过程记录下来的笔记。&lt;/p&gt;
    
    </summary>
    
      <category term="Database" scheme="http://yoursite.com/categories/Database/"/>
    
    
      <category term="MySQL" scheme="http://yoursite.com/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>Redis数据类型--List（列表）</title>
    <link href="http://yoursite.com/2017/01/07/Redis%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B--List%EF%BC%88%E5%88%97%E8%A1%A8%EF%BC%89/"/>
    <id>http://yoursite.com/2017/01/07/Redis数据类型--List（列表）/</id>
    <published>2017-01-07T13:02:25.000Z</published>
    <updated>2017-09-28T09:36:40.325Z</updated>
    
    <content type="html"><![CDATA[<p>Redis对链表（linked-list）结构的支持使得它在键值存储的世界中独树一帜。链表上的每个节点包含一个字符串。文档目前描述的内容以 Redis 2.8 版本为准。<br>结构的读写能力：<br>     从链表的两端推入或者弹出元素<br>     根据偏移量对链表进行修剪（trim）<br>     读取单个或者多个元素<br>     根据值查找或者移除元素<br><a id="more"></a></p><h3 id="LSET"><a href="#LSET" class="headerlink" title="LSET"></a><strong>LSET</strong></h3><p><strong>LSET key index value</strong><br>     将列表 key 下标为 index 的元素的值设置为 value 。<br>     当 index 参数超出范围，或对一个空列表( key 不存在)进行 LSET 时，返回一个错误。</p><h4 id="可用版本"><a href="#可用版本" class="headerlink" title="可用版本"></a>可用版本</h4><p>版本&gt;= 1.0.0</p><h4 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><p>对头元素或尾元素进行 LSET 操作，复杂度为 O(1)。<br>其他情况下，为 O(N)， N 为列表的长度。</p><h4 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h4><p>操作成功返回 ok ，否则返回错误信息。</p><h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"># 对空列表(key 不存在)进行 LSET</div><div class="line">redis&gt; EXISTS list</div><div class="line">(integer) 0</div><div class="line">redis&gt; LSET list 0 item</div><div class="line">(error) ERR no such key</div><div class="line"># 对非空列表进行 LSET</div><div class="line">redis&gt; LPUSH job &quot;cook food&quot;</div><div class="line">(integer) 1</div><div class="line">redis&gt; LRANGE job 0 0</div><div class="line">1) &quot;cook food&quot;</div><div class="line">redis&gt; LSET job 0 &quot;play game&quot;</div><div class="line">OK</div><div class="line">redis&gt; LRANGE job  0 0</div><div class="line">1) &quot;play game&quot;</div><div class="line"># index 超出范围</div><div class="line">redis&gt; LLEN list                    # 列表长度为 1</div><div class="line">(integer) 1</div><div class="line">redis&gt; LSET list 3 &apos;out of range&apos;</div><div class="line">(error) ERR index out of range</div></pre></td></tr></table></figure><h3 id="LINDEX"><a href="#LINDEX" class="headerlink" title="LINDEX"></a><strong>LINDEX</strong></h3><p><strong>LINDEX key index</strong><br> 返回列表 key 中，下标为 index 的元素。<br> 下标(index)参数 start 和 stop 都以 0 为底，也就是说，以 0 表示列表的第一个元素，以 1 表示列表的第二个元素，以此类推。<br> 你也可以使用负数下标，以 -1 表示列表的最后一个元素， -2 表示列表的倒数第二个元素，以此类推。<br> 如果 key 不是列表类型，返回一个错误。</p><h4 id="可用版本-1"><a href="#可用版本-1" class="headerlink" title="可用版本"></a>可用版本</h4><p>版本&gt;= 1.0.0</p><h4 id="时间复杂度-1"><a href="#时间复杂度-1" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><p>O(N)， N 为到达下标 index 过程中经过的元素数量。<br>因此，对列表的头元素和尾元素执行 LINDEX 命令，复杂度为O(1)。</p><h4 id="返回值-1"><a href="#返回值-1" class="headerlink" title="返回值"></a>返回值</h4><p>列表中下标为 index 的元素。<br>如果 index 参数的值不在列表的区间范围内(out of range)，返回 nil 。</p><h4 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">redis&gt; LPUSH mylist &quot;World&quot;</div><div class="line">(integer) 1</div><div class="line">redis&gt; LPUSH mylist &quot;Hello&quot;</div><div class="line">(integer) 2</div><div class="line">redis&gt; LINDEX mylist 0</div><div class="line">&quot;Hello&quot;</div><div class="line">redis&gt; LINDEX mylist -1</div><div class="line">&quot;World&quot;</div><div class="line">redis&gt; LINDEX mylist 3        # index不在 mylist 的区间范围内</div><div class="line">(nil)</div></pre></td></tr></table></figure><h3 id="LINSERT"><a href="#LINSERT" class="headerlink" title="LINSERT"></a><strong>LINSERT</strong></h3><p><strong>LINSERT key BEFORE|AFTER pivot valu</strong>e<br> 将值 value 插入到列表 key 当中，位于值 pivot 之前或之后。<br> 当 pivot 不存在于列表 key 时，不执行任何操作。<br> 当 key 不存在时， key 被视为空列表，不执行任何操作。<br> 如果 key 不是列表类型，返回一个错误。</p><h4 id="可用版本-2"><a href="#可用版本-2" class="headerlink" title="可用版本"></a>可用版本</h4><p>版本&gt;= 2.2.0</p><h4 id="时间复杂度-2"><a href="#时间复杂度-2" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><p>O(N)， N 为寻找 pivot 过程中经过的元素数量。</p><h4 id="返回值-2"><a href="#返回值-2" class="headerlink" title="返回值"></a>返回值</h4><p>如果命令执行成功，返回插入操作完成之后，列表的长度。<br>如果没有找到 pivot ，返回 -1 。<br>如果 key 不存在或为空列表，返回 0 。</p><h4 id="示例-2"><a href="#示例-2" class="headerlink" title="示例"></a>示例</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">redis&gt; RPUSH mylist &quot;Hello&quot;</div><div class="line">(integer) 1</div><div class="line">redis&gt; RPUSH mylist &quot;World&quot;</div><div class="line">(integer) 2</div><div class="line">redis&gt; LINSERT mylist BEFORE &quot;World&quot; &quot;There&quot;</div><div class="line">(integer) 3</div><div class="line">redis&gt; LRANGE mylist 0 -1</div><div class="line">1) &quot;Hello&quot;</div><div class="line">2) &quot;There&quot;</div><div class="line">3) &quot;World&quot;</div><div class="line"># 对一个非空列表插入，查找一个不存在的 pivot</div><div class="line">redis&gt; LINSERT mylist BEFORE &quot;go&quot; &quot;let&apos;s&quot;</div><div class="line">(integer) -1                                    # 失败</div><div class="line"># 对一个空列表执行 LINSERT 命令</div><div class="line">redis&gt; EXISTS fake_list</div><div class="line">(integer) 0</div><div class="line">redis&gt; LINSERT fake_list BEFORE &quot;nono&quot; &quot;gogogog&quot;</div><div class="line">(integer) 0                                      # 失败</div></pre></td></tr></table></figure><h3 id="LLEN"><a href="#LLEN" class="headerlink" title="LLEN"></a><strong>LLEN</strong></h3><p><strong>LLEN key</strong><br> 返回列表 key 的长度。<br> 如果 key 不存在，则 key 被解释为一个空列表，返回 0 .<br> 如果 key 不是列表类型，返回一个错误。</p><h4 id="可用版本-3"><a href="#可用版本-3" class="headerlink" title="可用版本"></a>可用版本</h4><p>版本&gt;= 1.0.0</p><h4 id="时间复杂度-3"><a href="#时间复杂度-3" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><p>O(1)</p><h4 id="返回值-3"><a href="#返回值-3" class="headerlink" title="返回值"></a>返回值</h4><p>列表 key 的长度。</p><h4 id="示例-3"><a href="#示例-3" class="headerlink" title="示例"></a>示例</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"># 空列表</div><div class="line">redis&gt; LLEN job</div><div class="line">(integer) 0</div><div class="line"># 非空列表</div><div class="line">redis&gt; LPUSH job &quot;cook food&quot;</div><div class="line">(integer) 1</div><div class="line">redis&gt; LPUSH job &quot;have lunch&quot;</div><div class="line">(integer) 2</div><div class="line">redis&gt; LLEN job</div><div class="line">(integer) 2</div></pre></td></tr></table></figure><h3 id="LPOP"><a href="#LPOP" class="headerlink" title="LPOP"></a><strong>LPOP</strong></h3><p><strong>LPOP key</strong><br> 移除并返回列表 key 的头元素。</p><h4 id="可用版本-4"><a href="#可用版本-4" class="headerlink" title="可用版本"></a>可用版本</h4><p>版本&gt;= 1.0.0</p><h4 id="时间复杂度-4"><a href="#时间复杂度-4" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><p>O(1)</p><h4 id="返回值-4"><a href="#返回值-4" class="headerlink" title="返回值"></a>返回值</h4><p>列表的头元素。<br>当 key 不存在时，返回 nil 。</p><h4 id="示例-4"><a href="#示例-4" class="headerlink" title="示例"></a>示例</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">redis&gt; LLEN course</div><div class="line">(integer) 0</div><div class="line">redis&gt; RPUSH course algorithm001</div><div class="line">(integer) 1</div><div class="line">redis&gt; RPUSH course c++101</div><div class="line">(integer) 2</div><div class="line">redis&gt; LPOP course  # 移除头元素</div><div class="line">&quot;algorithm001&quot;</div></pre></td></tr></table></figure><h3 id="LPUSH"><a href="#LPUSH" class="headerlink" title="LPUSH"></a><strong>LPUSH</strong></h3><p><strong>LPUSH key value [value …]</strong><br> 将一个或多个值 value 插入到列表 key 的表头<br> 如果有多个 value 值，那么各个 value 值按从左到右的顺序依次插入到表头： 比如说，对空列表 mylist 执行命令 LPUSH mylist a b c ，列表的值将是 c b a ，这等同于原子性地执行 LPUSH mylist a 、 LPUSH mylist b 和 LPUSH mylist c 三个命令。<br> 如果 key 不存在，一个空列表会被创建并执行 LPUSH 操作。<br> 当 key 存在但不是列表类型时，返回一个错误。<br> 在Redis 2.4版本以前的 LPUSH 命令，都只接受单个 value 值。</p><h4 id="可用版本-5"><a href="#可用版本-5" class="headerlink" title="可用版本"></a>可用版本</h4><p>版本&gt;= 1.0.0</p><h4 id="时间复杂度-5"><a href="#时间复杂度-5" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><p>O(1)</p><h4 id="返回值-5"><a href="#返回值-5" class="headerlink" title="返回值"></a>返回值</h4><p>执行 LPUSH 命令后，列表的长度。</p><h4 id="示例-5"><a href="#示例-5" class="headerlink" title="示例"></a>示例</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"># 加入单个元素</div><div class="line">redis&gt; LPUSH languages python</div><div class="line">(integer) 1</div><div class="line"># 加入重复元素</div><div class="line">redis&gt; LPUSH languages python</div><div class="line">(integer) 2</div><div class="line">redis&gt; LRANGE languages 0 -1     # 列表允许重复元素</div><div class="line">1) &quot;python&quot;</div><div class="line">2) &quot;python&quot;</div><div class="line"># 加入多个元素</div><div class="line">redis&gt; LPUSH mylist a b c</div><div class="line">(integer) 3</div><div class="line">redis&gt; LRANGE mylist 0 -1</div><div class="line">1) &quot;c&quot;</div><div class="line">2) &quot;b&quot;</div><div class="line">3) &quot;a&quot;</div></pre></td></tr></table></figure><h3 id="LPUSHX"><a href="#LPUSHX" class="headerlink" title="LPUSHX"></a><strong>LPUSHX</strong></h3><p><strong>LPUSHX key value</strong><br> 将值 value 插入到列表 key 的表头，当且仅当 key 存在并且是一个列表。<br> 和 LPUSH 命令相反，当 key 不存在时， LPUSHX 命令什么也不做。</p><h4 id="可用版本-6"><a href="#可用版本-6" class="headerlink" title="可用版本"></a>可用版本</h4><p>版本&gt;= 2.2.0</p><h4 id="时间复杂度-6"><a href="#时间复杂度-6" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><p>O(1)</p><h4 id="返回值-6"><a href="#返回值-6" class="headerlink" title="返回值"></a>返回值</h4><p>LPUSHX 命令执行之后，表的长度。</p><h4 id="示例-6"><a href="#示例-6" class="headerlink" title="示例"></a>示例</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"># 对空列表执行 LPUSHX</div><div class="line">redis&gt; LLEN greet                       # greet 是一个空列表</div><div class="line">(integer) 0</div><div class="line">redis&gt; LPUSHX greet &quot;hello&quot;             # 尝试 LPUSHX，失败，因为列表为空</div><div class="line">(integer) 0</div><div class="line"># 对非空列表执行 LPUSHX</div><div class="line">redis&gt; LPUSH greet &quot;hello&quot;              # 先用 LPUSH 创建一个有一个元素的列表</div><div class="line">(integer) 1</div><div class="line">redis&gt; LPUSHX greet &quot;good morning&quot;      # 这次 LPUSHX 执行成功</div><div class="line">(integer) 2</div><div class="line">redis&gt; LRANGE greet 0 -1</div><div class="line">1) &quot;good morning&quot;</div><div class="line">2) &quot;hello&quot;</div></pre></td></tr></table></figure><h3 id="LRANGE"><a href="#LRANGE" class="headerlink" title="LRANGE"></a><strong>LRANGE</strong></h3><p><strong>LRANGE key start stop</strong><br> 返回列表 key 中指定区间内的元素，区间以偏移量 start 和 stop 指定。<br> 下标(index)参数 start 和 stop 都以 0 为底，也就是说，以 0 表示列表的第一个元素，以 1 表示列表的第二个元素，以此类推。<br> 你也可以使用负数下标，以 -1 表示列表的最后一个元素， -2 表示列表的倒数第二个元素，以此类推。</p><p><strong>注意LRANGE命令和编程语言区间函数的区别</strong><br>假如你有一个包含一百个元素的列表，对该列表执行 LRANGE list 0 10 ，结果是一个包含11个元素的列表，这表明 stop 下标也在 LRANGE 命令的取值范围之内(闭区间)，这和某些语言的区间函数可能不一致，比如Ruby的 Range.new 、 Array#slice 和Python的 range() 函数。</p><p><strong>超出范围的下标</strong><br> 超出范围的下标值不会引起错误。<br> 如果 start 下标比列表的最大下标 end ( LLEN list 减去 1 )还要大，那么 LRANGE 返回一个空列表。<br> 如果 stop 下标比 end 下标还要大，Redis将 stop 的值设置为 end 。</p><h4 id="可用版本-7"><a href="#可用版本-7" class="headerlink" title="可用版本"></a>可用版本</h4><p>版本&gt;= 1.0.0</p><h4 id="时间复杂度-7"><a href="#时间复杂度-7" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><p>O(S+N)， S 为偏移量 start ， N 为指定区间内元素的数量。</p><h4 id="返回值-7"><a href="#返回值-7" class="headerlink" title="返回值"></a>返回值</h4><p>一个列表，包含指定区间内的元素。</p><h4 id="示例-7"><a href="#示例-7" class="headerlink" title="示例"></a>示例</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">redis&gt; RPUSH fp-language lisp</div><div class="line">(integer) 1</div><div class="line">redis&gt; LRANGE fp-language 0 0</div><div class="line">1) &quot;lisp&quot;</div><div class="line">redis&gt; RPUSH fp-language scheme</div><div class="line">(integer) 2</div><div class="line">redis&gt; LRANGE fp-language 0 1</div><div class="line">1) &quot;lisp&quot;</div><div class="line">2) &quot;scheme&quot;</div></pre></td></tr></table></figure><h3 id="LREM"><a href="#LREM" class="headerlink" title="LREM"></a><strong>LREM</strong></h3><p><strong>LREM key count value</strong><br>  根据参数 count 的值，移除列表中与参数 value 相等的元素。<br><strong>count 的值可以是以下几种：</strong><br> count &gt; 0 : 从表头开始向表尾搜索，移除与 value 相等的元素，数量为 count 。<br> count &lt; 0 : 从表尾开始向表头搜索，移除与 value 相等的元素，数量为 count 的绝对值。<br> count = 0 : 移除表中所有与 value 相等的值。</p><h4 id="可用版本-8"><a href="#可用版本-8" class="headerlink" title="可用版本"></a>可用版本</h4><p>版本&gt;= 1.0.0</p><h4 id="时间复杂度-8"><a href="#时间复杂度-8" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><p>O(N)， N 为列表的长度。</p><h4 id="返回值-8"><a href="#返回值-8" class="headerlink" title="返回值"></a>返回值</h4><p>被移除元素的数量。<br>因为不存在的 key 被视作空表(empty list)，所以当 key 不存在时， LREM 命令总是返回 0 。</p><h4 id="示例-8"><a href="#示例-8" class="headerlink" title="示例"></a>示例</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"># 先创建一个表，内容排列是</div><div class="line"># morning hello morning helllo morning</div><div class="line">redis&gt; LPUSH greet &quot;morning&quot;</div><div class="line">(integer) 1</div><div class="line">redis&gt; LPUSH greet &quot;hello&quot;</div><div class="line">(integer) 2</div><div class="line">redis&gt; LPUSH greet &quot;morning&quot;</div><div class="line">(integer) 3</div><div class="line">redis&gt; LPUSH greet &quot;hello&quot;</div><div class="line">(integer) 4</div><div class="line">redis&gt; LPUSH greet &quot;morning&quot;</div><div class="line">(integer) 5</div><div class="line">redis&gt; LRANGE greet 0 4         # 查看所有元素</div><div class="line">1) &quot;morning&quot;</div><div class="line">2) &quot;hello&quot;</div><div class="line">3) &quot;morning&quot;</div><div class="line">4) &quot;hello&quot;</div><div class="line">5) &quot;morning&quot;</div><div class="line">redis&gt; LREM greet 2 morning     # 移除从表头到表尾，最先发现的两个 morning</div><div class="line">(integer) 2                     # 两个元素被移除</div><div class="line">redis&gt; LLEN greet               # 还剩 3 个元素</div><div class="line">(integer) 3</div><div class="line">redis&gt; LRANGE greet 0 2</div><div class="line">1) &quot;hello&quot;</div><div class="line">2) &quot;hello&quot;</div><div class="line">3) &quot;morning&quot;</div><div class="line">redis&gt; LREM greet -1 morning    # 移除从表尾到表头，第一个 morning</div><div class="line">(integer) 1</div><div class="line">redis&gt; LLEN greet               # 剩下两个元素</div><div class="line">(integer) 2</div><div class="line">redis&gt; LRANGE greet 0 1</div><div class="line">1) &quot;hello&quot;</div><div class="line">2) &quot;hello&quot;</div><div class="line">redis&gt; LREM greet 0 hello      # 移除表中所有 hello</div><div class="line">(integer) 2                    # 两个 hello 被移除</div><div class="line">redis&gt; LLEN greet</div><div class="line">(integer) 0</div></pre></td></tr></table></figure><h3 id="LTRIM"><a href="#LTRIM" class="headerlink" title="LTRIM"></a><strong>LTRIM</strong></h3><p><strong>LTRIM key start stop</strong><br> 对一个列表进行修剪(trim)，就是说，让列表只保留指定区间内的元素，不在指定区间之内的元素都将被删除。<br> 举个例子，执行命令 LTRIM list 0 2 ，表示只保留列表 list 的前三个元素，其余元素全部删除。<br> 下标(index)参数 start 和 stop 都以 0 为底，也就是说，以 0 表示列表的第一个元素，以 1 表示列表的第二个元素，以此类推。<br> 你也可以使用负数下标，以 -1 表示列表的最后一个元素， -2 表示列表的倒数第二个元素，以此类推。<br> 当 key 不是列表类型时，返回一个错误。</p><p><strong>LTRIM 命令通常和 LPUSH 命令或 RPUSH 命令配合使用，举个例子：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">LPUSH log newest_log</div><div class="line">LTRIM log 0 99</div></pre></td></tr></table></figure></p><p>这个例子模拟了一个日志程序，每次将最新日志 newest_log 放到 log 列表中，并且只保留最新的 100 项。注意当这样使用 LTRIM 命令时，时间复杂度是O(1)，因为平均情况下，每次只有一个元素被移除。</p><p><strong>注意LTRIM命令和编程语言区间函数的区别</strong></p><p>假如你有一个包含一百个元素的列表 list ，对该列表执行 LTRIM list 0 10 ，结果是一个包含11个元素的列表，这表明 stop 下标也在 LTRIM 命令的取值范围之内(闭区间)，这和某些语言的区间函数可能不一致，比如Ruby的 Range.new 、 Array#slice 和Python的 range() 函数。</p><p><strong>超出范围的下标</strong><br> 超出范围的下标值不会引起错误。<br> 如果 start 下标比列表的最大下标 end ( LLEN list 减去 1 )还要大，或者 start &gt; stop ， LTRIM 返回一个空列表(因为 LTRIM 已经将整个列表清空)。<br> 如果 stop 下标比 end 下标还要大，Redis将 stop 的值设置为 end 。</p><h4 id="可用版本-9"><a href="#可用版本-9" class="headerlink" title="可用版本"></a>可用版本</h4><p>版本&gt;= 1.0.0</p><h4 id="时间复杂度-9"><a href="#时间复杂度-9" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><p>O(N)， N 为被移除的元素的数量。</p><h4 id="返回值-9"><a href="#返回值-9" class="headerlink" title="返回值"></a>返回值</h4><p>命令执行成功时，返回 ok 。</p><h4 id="示例-9"><a href="#示例-9" class="headerlink" title="示例"></a>示例</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"># 情况 1： 常见情况， start 和 stop 都在列表的索引范围之内</div><div class="line">redis&gt; LRANGE alpha 0 -1       # alpha 是一个包含 5 个字符串的列表</div><div class="line">1) &quot;h&quot;</div><div class="line">2) &quot;e&quot;</div><div class="line">3) &quot;l&quot;</div><div class="line">4) &quot;l&quot;</div><div class="line">5) &quot;o&quot;</div><div class="line">redis&gt; LTRIM alpha 1 -1        # 删除 alpha 列表索引为 0 的元素</div><div class="line">OK</div><div class="line">redis&gt; LRANGE alpha 0 -1       # &quot;h&quot; 被删除了</div><div class="line">1) &quot;e&quot;</div><div class="line">2) &quot;l&quot;</div><div class="line">3) &quot;l&quot;</div><div class="line">4) &quot;o&quot;</div><div class="line"># 情况 2： stop 比列表的最大下标还要大</div><div class="line">redis&gt; LTRIM alpha 1 10086     # 保留 alpha 列表索引 1 至索引 10086 上的元素</div><div class="line">OK</div><div class="line">redis&gt; LRANGE alpha 0 -1       # 只有索引 0 上的元素 &quot;e&quot; 被删除了，其他元素还在</div><div class="line">1) &quot;l&quot;</div><div class="line">2) &quot;l&quot;</div><div class="line">3) &quot;o&quot;</div><div class="line"># 情况 3： start 和 stop 都比列表的最大下标要大，并且 start &lt; stop</div><div class="line">redis&gt; LTRIM alpha 10086 123321</div><div class="line">OK</div><div class="line">redis&gt; LRANGE alpha 0 -1        # 列表被清空</div><div class="line">(empty list or set)</div><div class="line"># 情况 4： start 和 stop 都比列表的最大下标要大，并且 start &gt; stop</div><div class="line">redis&gt; RPUSH new-alpha &quot;h&quot; &quot;e&quot; &quot;l&quot; &quot;l&quot; &quot;o&quot;     # 重新建立一个新列表</div><div class="line">(integer) 5</div><div class="line">redis&gt; LRANGE new-alpha 0 -1</div><div class="line">1) &quot;h&quot;</div><div class="line">2) &quot;e&quot;</div><div class="line">3) &quot;l&quot;</div><div class="line">4) &quot;l&quot;</div><div class="line">5) &quot;o&quot;</div><div class="line">redis&gt; LTRIM new-alpha 123321 10086    # 执行 LTRIM</div><div class="line">OK</div><div class="line">redis&gt; LRANGE new-alpha 0 -1           # 同样被清空</div><div class="line">(empty list or set)</div></pre></td></tr></table></figure><h3 id="RPOP"><a href="#RPOP" class="headerlink" title="RPOP"></a><strong>RPOP</strong></h3><p><strong>RPOP key</strong><br> 移除并返回列表 key 的尾元素。</p><h4 id="可用版本-10"><a href="#可用版本-10" class="headerlink" title="可用版本"></a>可用版本</h4><p>版本&gt;= 1.0.0</p><h4 id="时间复杂度-10"><a href="#时间复杂度-10" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><p>O(1)</p><h4 id="返回值-10"><a href="#返回值-10" class="headerlink" title="返回值"></a>返回值</h4><p>列表的尾元素。<br>当 key 不存在时，返回 nil 。</p><h4 id="示例-10"><a href="#示例-10" class="headerlink" title="示例"></a>示例</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">redis&gt; RPUSH mylist &quot;one&quot;</div><div class="line">(integer) 1</div><div class="line">redis&gt; RPUSH mylist &quot;two&quot;</div><div class="line">(integer) 2</div><div class="line">redis&gt; RPUSH mylist &quot;three&quot;</div><div class="line">(integer) 3</div><div class="line">redis&gt; RPOP mylist           # 返回被弹出的元素</div><div class="line">&quot;three&quot;</div><div class="line">redis&gt; LRANGE mylist 0 -1    # 列表剩下的元素</div><div class="line">1) &quot;one&quot;</div><div class="line">2) &quot;two&quot;</div></pre></td></tr></table></figure><h3 id="RPOPLPUSH"><a href="#RPOPLPUSH" class="headerlink" title="RPOPLPUSH"></a><strong>RPOPLPUSH</strong></h3><p><strong>RPOPLPUSH source destination</strong></p><p> 命令 RPOPLPUSH 在一个原子时间内，执行以下两个动作：</p><ul><li>将列表 source 中的最后一个元素(尾元素)弹出，并返回给客户端。</li><li>将 source 弹出的元素插入到列表 destination ，作为 destination 列表的的头元素。<br>举个例子，你有两个列表 source 和 destination ， source 列表有元素 a, b, c ， destination 列表有元素 x, y, z ，执行 RPOPLPUSH source destination 之后， source 列表包含元素 a, b ， destination 列表包含元素 c, x, y, z ，并且元素 c 会被返回给客户端。<br> 如果 source 不存在，值 nil 被返回，并且不执行其他动作。<br> 如果 source 和 destination 相同，则列表中的表尾元素被移动到表头，并返回该元素，可以把这种特殊情况视作列表的旋转(rotation)操作。</li></ul><h4 id="可用版本-11"><a href="#可用版本-11" class="headerlink" title="可用版本"></a>可用版本</h4><p>版本&gt;= 1.2.0</p><h4 id="时间复杂度-11"><a href="#时间复杂度-11" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><p>O(1)</p><h4 id="返回值-11"><a href="#返回值-11" class="headerlink" title="返回值"></a>返回值</h4><p>被弹出的元素。</p><h4 id="示例-11"><a href="#示例-11" class="headerlink" title="示例"></a>示例</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line"># source 和 destination 不同</div><div class="line">redis&gt; LRANGE alpha 0 -1         # 查看所有元素</div><div class="line">1) &quot;a&quot;</div><div class="line">2) &quot;b&quot;</div><div class="line">3) &quot;c&quot;</div><div class="line">4) &quot;d&quot;</div><div class="line">redis&gt; RPOPLPUSH alpha reciver   # 执行一次 RPOPLPUSH 看看</div><div class="line">&quot;d&quot;</div><div class="line">redis&gt; LRANGE alpha 0 -1</div><div class="line">1) &quot;a&quot;</div><div class="line">2) &quot;b&quot;</div><div class="line">3) &quot;c&quot;</div><div class="line">redis&gt; LRANGE reciver 0 -1</div><div class="line">1) &quot;d&quot;</div><div class="line">redis&gt; RPOPLPUSH alpha reciver   # 再执行一次，证实 RPOP 和 LPUSH 的位置正确</div><div class="line">&quot;c&quot;</div><div class="line">redis&gt; LRANGE alpha 0 -1</div><div class="line">1) &quot;a&quot;</div><div class="line">2) &quot;b&quot;</div><div class="line">redis&gt; LRANGE reciver 0 -1</div><div class="line">1) &quot;c&quot;</div><div class="line">2) &quot;d&quot;</div><div class="line"># source 和 destination 相同</div><div class="line">redis&gt; LRANGE number 0 -1</div><div class="line">1) &quot;1&quot;</div><div class="line">2) &quot;2&quot;</div><div class="line">3) &quot;3&quot;</div><div class="line">4) &quot;4&quot;</div><div class="line">redis&gt; RPOPLPUSH number number</div><div class="line">&quot;4&quot;</div><div class="line">redis&gt; LRANGE number 0 -1           # 4 被旋转到了表头</div><div class="line">1) &quot;4&quot;</div><div class="line">2) &quot;1&quot;</div><div class="line">3) &quot;2&quot;</div><div class="line">4) &quot;3&quot;</div><div class="line">redis&gt; RPOPLPUSH number number</div><div class="line">&quot;3&quot;</div><div class="line">redis&gt; LRANGE number 0 -1           # 这次是 3 被旋转到了表头</div><div class="line">1) &quot;3&quot;</div><div class="line">2) &quot;4&quot;</div><div class="line">3) &quot;1&quot;</div><div class="line">4) &quot;2&quot;</div></pre></td></tr></table></figure><h3 id="RPUSH"><a href="#RPUSH" class="headerlink" title="RPUSH"></a><strong>RPUSH</strong></h3><p><strong>RPUSH key value [value …]</strong><br> 将一个或多个值 value 插入到列表 key 的表尾(最右边)。<br> 如果有多个 value 值，那么各个 value 值按从左到右的顺序依次插入到表尾：比如对一个空列表 mylist 执行 RPUSH mylist a b c ，得出的结果列表为 a b c ，等同于执行命令 RPUSH mylist a 、 RPUSH mylist b 、 RPUSH mylist c 。<br> 如果 key 不存在，一个空列表会被创建并执行 RPUSH 操作。<br> 当 key 存在但不是列表类型时，返回一个错误。<br> 在 Redis 2.4 版本以前的 RPUSH 命令，都只接受单个 value 值。</p><h4 id="可用版本-12"><a href="#可用版本-12" class="headerlink" title="可用版本"></a>可用版本</h4><p>版本&gt;= 1.0.0</p><h4 id="时间复杂度-12"><a href="#时间复杂度-12" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><p>O(1)</p><h4 id="返回值-12"><a href="#返回值-12" class="headerlink" title="返回值"></a>返回值</h4><p>执行 RPUSH 操作后，表的长度。</p><h4 id="示例-12"><a href="#示例-12" class="headerlink" title="示例"></a>示例</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"># 添加单个元素</div><div class="line">redis&gt; RPUSH languages c</div><div class="line">(integer) 1</div><div class="line"># 添加重复元素</div><div class="line">redis&gt; RPUSH languages c</div><div class="line">(integer) 2</div><div class="line">redis&gt; LRANGE languages 0 -1 # 列表允许重复元素</div><div class="line">1) &quot;c&quot;</div><div class="line">2) &quot;c&quot;</div><div class="line"># 添加多个元素</div><div class="line">redis&gt; RPUSH mylist a b c</div><div class="line">(integer) 3</div><div class="line">redis&gt; LRANGE mylist 0 -1</div><div class="line">1) &quot;a&quot;</div><div class="line">2) &quot;b&quot;</div><div class="line">3) &quot;c&quot;</div></pre></td></tr></table></figure><h3 id="RPUSHX"><a href="#RPUSHX" class="headerlink" title="RPUSHX"></a><strong>RPUSHX</strong></h3><p><strong>RPUSHX key value</strong><br> 将值 value 插入到列表 key 的表尾，当且仅当 key 存在并且是一个列表。<br> 和 RPUSH 命令相反，当 key 不存在时， RPUSHX 命令什么也不做。</p><h4 id="可用版本-13"><a href="#可用版本-13" class="headerlink" title="可用版本"></a>可用版本</h4><p>版本&gt;= 2.2.0</p><h4 id="时间复杂度-13"><a href="#时间复杂度-13" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><p>O(1)</p><h4 id="返回值-13"><a href="#返回值-13" class="headerlink" title="返回值"></a>返回值</h4><p>RPUSHX 命令执行之后，表的长度。</p><h4 id="示例-13"><a href="#示例-13" class="headerlink" title="示例"></a>示例</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"># key不存在</div><div class="line">redis&gt; LLEN greet</div><div class="line">(integer) 0</div><div class="line">redis&gt; RPUSHX greet &quot;hello&quot;     # 对不存在的 key 进行 RPUSHX，PUSH 失败。</div><div class="line">(integer) 0</div><div class="line"># key 存在且是一个非空列表</div><div class="line">redis&gt; RPUSH greet &quot;hi&quot;         # 先用 RPUSH 插入一个元素</div><div class="line">(integer) 1</div><div class="line">redis&gt; RPUSHX greet &quot;hello&quot;     # greet 现在是一个列表类型，RPUSHX 操作成功。</div><div class="line">(integer) 2</div><div class="line">redis&gt; LRANGE greet 0 -1</div><div class="line">1) &quot;hi&quot;</div><div class="line">2) &quot;hello&quot;</div></pre></td></tr></table></figure><h3 id="BLPOP"><a href="#BLPOP" class="headerlink" title="BLPOP"></a><strong>BLPOP</strong></h3><p><strong>BLPOP key [key …] timeout</strong><br> BLPOP 是列表的阻塞式(blocking)弹出原语。<br> 它是 LPOP 命令的阻塞版本，当给定列表内没有任何元素可供弹出的时候，连接将被 BLPOP 命令阻塞，直到等待超时或发现可弹出元素为止。<br> 当给定多个 key 参数时，按参数 key 的先后顺序依次检查各个列表，弹出第一个非空列表的头元素。</p><h4 id="非阻塞行为"><a href="#非阻塞行为" class="headerlink" title="非阻塞行为"></a>非阻塞行为</h4><p> 当 BLPOP 被调用时，如果给定 key 内至少有一个非空列表，那么弹出遇到的第一个非空列表的头元素，并和被弹出元素所属的列表的名字一起，组成结果返回给调用者。<br> 当存在多个给定 key 时， BLPOP 按给定 key 参数排列的先后顺序，依次检查各个列表。<br> 假设现在有 job 、 command 和 request 三个列表，其中 job 不存在， command 和 request 都持有非空列表。考虑以下命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">BLPOP job command request 0</div></pre></td></tr></table></figure></p><p> BLPOP 保证返回的元素来自 command ，因为它是按”查找 job -&gt; 查找 command -&gt; 查找 request “这样的顺序，第一个找到的非空列表。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">redis&gt; DEL job command request           # 确保key都被删除</div><div class="line">(integer) 0</div><div class="line">redis&gt; LPUSH command &quot;update system...&quot;  # 为command列表增加一个值</div><div class="line">(integer) 1</div><div class="line">redis&gt; LPUSH request &quot;visit page&quot;        # 为request列表增加一个值</div><div class="line">(integer) 1</div><div class="line">redis&gt; BLPOP job command request 0       # job 列表为空，被跳过，紧接着 command 列表的第一个元素被弹出。</div><div class="line">1) &quot;command&quot;                             # 弹出元素所属的列表</div><div class="line">2) &quot;update system...&quot;                    # 弹出元素所属的值</div></pre></td></tr></table></figure><h4 id="阻塞行为"><a href="#阻塞行为" class="headerlink" title="阻塞行为"></a>阻塞行为</h4><p> 如果所有给定 key 都不存在或包含空列表，那么 BLPOP 命令将阻塞连接，直到等待超时，或有另一个客户端对给定 key 的任意一个执行 LPUSH 或 RPUSH 命令为止。</p><p> 超时参数 timeout 接受一个以秒为单位的数字作为值。超时参数设为 0 表示阻塞时间可以无限期延长(block indefinitely) 。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">redis&gt; EXISTS job                # 确保两个 key 都不存在</div><div class="line">(integer) 0</div><div class="line">redis&gt; EXISTS command</div><div class="line">(integer) 0</div><div class="line">redis&gt; BLPOP job command 300     # 因为key一开始不存在，所以操作会被阻塞，直到另一客户端对 job 或者 command 列表进行 PUSH 操作。</div><div class="line">1) &quot;job&quot;                         # 这里被 push 的是 job</div><div class="line">2) &quot;do my home work&quot;             # 被弹出的值</div><div class="line">(26.26s)                         # 等待的秒数</div><div class="line">redis&gt; BLPOP job command 5       # 等待超时的情况</div><div class="line">(nil)</div><div class="line">(5.66s)                          # 等待的秒数</div></pre></td></tr></table></figure></p><p><strong>相同的key被多个客户端同时阻塞</strong></p><p> 相同的 key 可以被多个客户端同时阻塞。<br> 不同的客户端被放进一个队列中，按『先阻塞先服务』(first-BLPOP，first-served)的顺序为 key 执行 BLPOP 命令。<br><strong>在MULTI/EXEC事务中的BLPOP</strong><br>BLPOP 可以用于流水线(pipline,批量地发送多个命令并读入多个回复)，但把它用在 MULTI / EXEC 块当中没有意义。因为这要求整个服务器被阻塞以保证块执行时的原子性，该行为阻止了其他客户端执行 LPUSH 或 RPUSH 命令。</p><p>因此，一个被包裹在 MULTI / EXEC 块内的 BLPOP 命令，行为表现得就像 LPOP 一样，对空列表返回 nil ，对非空列表弹出列表元素，不进行任何阻塞操作。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"># 对非空列表进行操作</div><div class="line">redis&gt; RPUSH job programming</div><div class="line">(integer) 1</div><div class="line">redis&gt; MULTI</div><div class="line">OK</div><div class="line">redis&gt; BLPOP job 30</div><div class="line">QUEUED</div><div class="line">redis&gt; EXEC           # 不阻塞，立即返回</div><div class="line">1) 1) &quot;job&quot;</div><div class="line">   2) &quot;programming&quot;</div><div class="line"># 对空列表进行操作</div><div class="line">redis&gt; LLEN job      # 空列表</div><div class="line">(integer) 0</div><div class="line">redis&gt; MULTI</div><div class="line">OK</div><div class="line">redis&gt; BLPOP job 30</div><div class="line">QUEUED</div><div class="line">redis&gt; EXEC         # 不阻塞，立即返回</div><div class="line">1) (nil)</div></pre></td></tr></table></figure></p><h4 id="可用版本-14"><a href="#可用版本-14" class="headerlink" title="可用版本"></a>可用版本</h4><p>版本&gt;= 2.0.0</p><h4 id="时间复杂度-14"><a href="#时间复杂度-14" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><p>O(1)</p><h4 id="返回值-14"><a href="#返回值-14" class="headerlink" title="返回值"></a>返回值</h4><p>如果列表为空，返回一个 nil 。<br>否则，返回一个含有两个元素的列表，第一个元素是被弹出元素所属的 key ，第二个元素是被弹出元素的值。</p><h3 id="BRPOP"><a href="#BRPOP" class="headerlink" title="BRPOP"></a><strong>BRPOP</strong></h3><p><strong>BRPOP key [key …] timeout</strong><br> BRPOP 是列表的阻塞式(blocking)弹出原语。<br> 它是 RPOP 命令的阻塞版本，当给定列表内没有任何元素可供弹出的时候，连接将被 BRPOP 命令阻塞，直到等待超时或发现可弹出元素为止。<br> 当给定多个 key 参数时，按参数 key 的先后顺序依次检查各个列表，弹出第一个非空列表的尾部元素。<br> 关于阻塞操作的更多信息，请查看 BLPOP 命令， BRPOP 除了弹出元素的位置和 BLPOP 不同之外，其他表现一致。</p><h4 id="可用版本-15"><a href="#可用版本-15" class="headerlink" title="可用版本"></a>可用版本</h4><p>版本&gt;= 2.0.0</p><h4 id="时间复杂度-15"><a href="#时间复杂度-15" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><p>O(1)</p><h4 id="返回值-15"><a href="#返回值-15" class="headerlink" title="返回值"></a>返回值</h4><p>假如在指定时间内没有任何元素被弹出，则返回一个 nil 和等待时长。<br>反之，返回一个含有两个元素的列表，第一个元素是被弹出元素所属的 key ，第二个元素是被弹出元素的值。</p><h4 id="示例-14"><a href="#示例-14" class="headerlink" title="示例"></a>示例</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">redis&gt; LLEN course</div><div class="line">(integer) 0</div><div class="line">redis&gt; RPUSH course algorithm001</div><div class="line">(integer) 1</div><div class="line">redis&gt; RPUSH course c++101</div><div class="line">(integer) 2</div><div class="line">redis&gt; BRPOP course 30</div><div class="line">1) &quot;course&quot;             # 弹出元素的 key</div><div class="line">2) &quot;c++101&quot;             # 弹出元素的值</div></pre></td></tr></table></figure><h3 id="BRPOPLPUSH"><a href="#BRPOPLPUSH" class="headerlink" title="BRPOPLPUSH"></a><strong>BRPOPLPUSH</strong></h3><p><strong>BRPOPLPUSH source destination timeout</strong><br> BRPOPLPUSH 是 RPOPLPUSH 的阻塞版本，当给定列表 source 不为空时， BRPOPLPUSH 的表现和 RPOPLPUSH 一样。<br> 当列表 source 为空时， BRPOPLPUSH 命令将阻塞连接，直到等待超时，或有另一个客户端对 source 执行 LPUSH 或 RPUSH 命令为止。<br> 超时参数 timeout 接受一个以秒为单位的数字作为值。超时参数设为 0 表示阻塞时间可以无限期延长(block indefinitely) 。</p><h4 id="可用版本-16"><a href="#可用版本-16" class="headerlink" title="可用版本"></a>可用版本</h4><p>版本&gt;= 2.2.0</p><h4 id="时间复杂度-16"><a href="#时间复杂度-16" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><p>O(1)</p><h4 id="返回值-16"><a href="#返回值-16" class="headerlink" title="返回值"></a>返回值</h4><p>假如在指定时间内没有任何元素被弹出，则返回一个 nil 和等待时长。<br>反之，返回一个含有两个元素的列表，第一个元素是被弹出元素的值，第二个元素是等待时长。</p><h4 id="示例-15"><a href="#示例-15" class="headerlink" title="示例"></a>示例</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"># 非空列表</div><div class="line">redis&gt; BRPOPLPUSH msg reciver 500</div><div class="line">&quot;hello moto&quot;                        # 弹出元素的值</div><div class="line">(3.38s)                             # 等待时长</div><div class="line">redis&gt; LLEN reciver</div><div class="line">(integer) 1</div><div class="line">redis&gt; LRANGE reciver 0 0</div><div class="line">1) &quot;hello moto&quot;</div><div class="line"># 空列表</div><div class="line">redis&gt; BRPOPLPUSH msg reciver 1</div><div class="line">(nil)</div><div class="line">(1.34s)</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Redis对链表（linked-list）结构的支持使得它在键值存储的世界中独树一帜。链表上的每个节点包含一个字符串。文档目前描述的内容以 Redis 2.8 版本为准。&lt;br&gt;结构的读写能力：&lt;br&gt;     从链表的两端推入或者弹出元素&lt;br&gt;     根据偏移量对链表进行修剪（trim）&lt;br&gt;     读取单个或者多个元素&lt;br&gt;     根据值查找或者移除元素&lt;br&gt;
    
    </summary>
    
      <category term="Redis" scheme="http://yoursite.com/categories/Redis/"/>
    
    
      <category term="Redis" scheme="http://yoursite.com/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Redis数据类型--Hash（哈希表）</title>
    <link href="http://yoursite.com/2017/01/07/Redis%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B--Hash%EF%BC%88%E5%93%88%E5%B8%8C%E8%A1%A8%EF%BC%89/"/>
    <id>http://yoursite.com/2017/01/07/Redis数据类型--Hash（哈希表）/</id>
    <published>2017-01-07T13:02:25.000Z</published>
    <updated>2017-09-28T09:29:50.221Z</updated>
    
    <content type="html"><![CDATA[<p>Redis的散列可以存储多个键值对之间的映射。和字符串一样，散列存储的值既可以是字符串又可以是数字值，并且用户同样子可以对散列存储的数字执行自增操作或者自减操作。<br>结构的读写：<br> 添加、获取、移除单个键值对<br> 获取所有的键值对<br><a id="more"></a></p><h3 id="HDEL"><a href="#HDEL" class="headerlink" title="HDEL"></a><strong>HDEL</strong></h3><p><strong>HDEL key field [field …]</strong></p><p> 删除哈希表 key 中的一个或多个指定域，不存在的域将被忽略。<br> 在Redis2.4以下的版本里， HDEL 每次只能删除单个域，如果你需要在一个原子时间 内删除多个域，请将命令包含在 MULTI / EXEC 块内。</p><h4 id="可用版本"><a href="#可用版本" class="headerlink" title="可用版本"></a>可用版本</h4><p>版本&gt;= 2.0.0</p><h4 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><p>O(N)， N 为要删除的域的数量。</p><h4 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h4><p>被成功移除的域的数量，不包括被忽略的域。</p><h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"># 测试数据</div><div class="line">redis&gt; HGETALL abbr</div><div class="line">1) &quot;a&quot;</div><div class="line">2) &quot;apple&quot;</div><div class="line">3) &quot;b&quot;</div><div class="line">4) &quot;banana&quot;</div><div class="line">5) &quot;c&quot;</div><div class="line">6) &quot;cat&quot;</div><div class="line">7) &quot;d&quot;</div><div class="line">8) &quot;dog&quot;</div><div class="line"># 删除单个域</div><div class="line">redis&gt; HDEL abbr a</div><div class="line">(integer) 1</div><div class="line"># 删除不存在的域</div><div class="line">redis&gt; HDEL abbr not-exists-field</div><div class="line">(integer) 0</div><div class="line"># 删除多个域</div><div class="line">redis&gt; HDEL abbr b c</div><div class="line">(integer) 2</div><div class="line">redis&gt; HGETALL abbr</div><div class="line">1) &quot;d&quot;</div><div class="line">2) &quot;dog&quot;</div></pre></td></tr></table></figure><h3 id="HEXISTS"><a href="#HEXISTS" class="headerlink" title="HEXISTS"></a><strong>HEXISTS</strong></h3><p><strong>HEXISTS key field</strong></p><p> 查看哈希表 key 中，给定域 field 是否存在。</p><h4 id="可用版本-1"><a href="#可用版本-1" class="headerlink" title="可用版本"></a>可用版本</h4><p>版本&gt;= 2.0.0</p><h4 id="时间复杂度-1"><a href="#时间复杂度-1" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><p>O(1)</p><h4 id="返回值-1"><a href="#返回值-1" class="headerlink" title="返回值"></a>返回值</h4><p>如果哈希表含有给定域，返回 1 。<br>如果哈希表不含有给定域，或 key 不存在，返回 0 。</p><h4 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">redis&gt; HEXISTS phone myphone</div><div class="line">(integer) 0</div><div class="line">redis&gt; HSET phone myphone nokia-1110</div><div class="line">(integer) 1</div><div class="line">redis&gt; HEXISTS phone myphone</div><div class="line">(integer) 1</div></pre></td></tr></table></figure><h3 id="HGET"><a href="#HGET" class="headerlink" title="HGET"></a><strong>HGET</strong></h3><p><strong>HGET key field</strong></p><p> 返回哈希表 key 中给定域 field 的值。</p><h4 id="可用版本-2"><a href="#可用版本-2" class="headerlink" title="可用版本"></a>可用版本</h4><p>版本&gt;= 2.0.0</p><h4 id="时间复杂度-2"><a href="#时间复杂度-2" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><p>O(1)</p><h4 id="返回值-2"><a href="#返回值-2" class="headerlink" title="返回值"></a>返回值</h4><p>给定域的值。<br>当给定域不存在或是给定 key 不存在时，返回 nil 。</p><h4 id="示例-2"><a href="#示例-2" class="headerlink" title="示例"></a>示例</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"># 域存在</div><div class="line">redis&gt; HSET site redis redis.com</div><div class="line">(integer) 1</div><div class="line">redis&gt; HGET site redis</div><div class="line">&quot;redis.com&quot;</div><div class="line"># 域不存在</div><div class="line">redis&gt; HGET site mysql</div><div class="line">(nil)</div></pre></td></tr></table></figure><h3 id="HGETALL"><a href="#HGETALL" class="headerlink" title="HGETALL"></a><strong>HGETALL</strong></h3><p><strong>HGETALL key</strong></p><p> 返回哈希表 key 中，所有的域和值。<br> 在返回值里，紧跟每个域名(field name)之后是域的值(value)，所以返回值的长度是哈希表大小的两倍。</p><h4 id="可用版本-3"><a href="#可用版本-3" class="headerlink" title="可用版本"></a>可用版本</h4><p>版本&gt;= 2.0.0</p><h4 id="时间复杂度-3"><a href="#时间复杂度-3" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><p>O(N)， N 为哈希表的大小。</p><p>####返回值<br>以列表形式返回哈希表的域和域的值。<br>若 key 不存在，返回空列表。</p><h4 id="示例-3"><a href="#示例-3" class="headerlink" title="示例"></a>示例</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">redis&gt; HSET people jack &quot;Jack Sparrow&quot;</div><div class="line">(integer) 1</div><div class="line">redis&gt; HSET people gump &quot;Forrest Gump&quot;</div><div class="line">(integer) 1</div><div class="line">redis&gt; HGETALL people</div><div class="line">1) &quot;jack&quot;          # 域</div><div class="line">2) &quot;Jack Sparrow&quot;  # 值</div><div class="line">3) &quot;gump&quot;</div><div class="line">4) &quot;Forrest Gump&quot;</div></pre></td></tr></table></figure><h3 id="HINCRBY"><a href="#HINCRBY" class="headerlink" title="HINCRBY"></a><strong>HINCRBY</strong></h3><p><strong>HINCRBY key field increment</strong></p><p> 为哈希表 key 中的域 field 的值加上增量 increment 。<br> 增量也可以为负数，相当于对给定域进行减法操作。<br> 如果 key 不存在，一个新的哈希表被创建并执行 HINCRBY 命令。<br> 如果域 field 不存在，那么在执行命令前，域的值被初始化为 0 。<br> 对一个储存字符串值的域 field 执行 HINCRBY 命令将造成一个错误。<br> 本操作的值被限制在 64 位(bit)有符号数字表示之内。</p><h4 id="可用版本-4"><a href="#可用版本-4" class="headerlink" title="可用版本"></a>可用版本</h4><p>版本&gt;= 2.0.0</p><h4 id="时间复杂度-4"><a href="#时间复杂度-4" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><p>O(1)</p><p>####返回值<br>执行 HINCRBY 命令之后，哈希表 key 中域 field 的值。</p><h4 id="示例-4"><a href="#示例-4" class="headerlink" title="示例"></a>示例</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"># increment 为正数</div><div class="line">redis&gt; HEXISTS counter page_view    # 对空域进行设置</div><div class="line">(integer) 0</div><div class="line">redis&gt; HINCRBY counter page_view 200</div><div class="line">(integer) 200</div><div class="line">redis&gt; HGET counter page_view</div><div class="line">&quot;200&quot;</div><div class="line"># increment 为负数</div><div class="line">redis&gt; HGET counter page_view</div><div class="line">&quot;200&quot;</div><div class="line">redis&gt; HINCRBY counter page_view -50</div><div class="line">(integer) 150</div><div class="line">redis&gt; HGET counter page_view</div><div class="line">&quot;150&quot;</div><div class="line"># 尝试对字符串值的域执行HINCRBY命令</div><div class="line">redis&gt; HSET myhash string hello,world       # 设定一个字符串值</div><div class="line">(integer) 1</div><div class="line">redis&gt; HGET myhash string</div><div class="line">&quot;hello,world&quot;</div><div class="line">redis&gt; HINCRBY myhash string 1              # 命令执行失败，错误。</div><div class="line">(error) ERR hash value is not an integer</div><div class="line">redis&gt; HGET myhash string                   # 原值不变</div><div class="line">&quot;hello,world&quot;</div></pre></td></tr></table></figure><h3 id="HINCRBYFLOAT"><a href="#HINCRBYFLOAT" class="headerlink" title="HINCRBYFLOAT"></a><strong>HINCRBYFLOAT</strong></h3><p><strong>HINCRBYFLOAT key field increment</strong></p><p> 为哈希表 key 中的域 field 加上浮点数增量 increment 。<br> 如果哈希表中没有域 field ，那么 HINCRBYFLOAT 会先将域 field 的值设为 0 ，然后再执行加法操作。<br> 如果键 key 不存在，那么 HINCRBYFLOAT 会先创建一个哈希表，再创建域 field ，最后再执行加法操作。<br> 当以下任意一个条件发生时，返回一个错误：</p><ul><li>域 field 的值不是字符串类型(因为 redis 中的数字和浮点数都以字符串的形式保存，所以它们都属于字符串类型）</li><li>域 field 当前的值或给定的增量 increment 不能解释(parse)为双精度浮点数(double precision<br>floating point number)</li></ul><p>HINCRBYFLOAT 命令的详细功能和 INCRBYFLOAT 命令类似，请查看 INCRBYFLOAT 命令获取更多相关信息。</p><h4 id="可用版本-5"><a href="#可用版本-5" class="headerlink" title="可用版本"></a>可用版本</h4><p>版本&gt;= 2.6.0</p><h4 id="时间复杂度-5"><a href="#时间复杂度-5" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><p>O(1)</p><h4 id="返回值-3"><a href="#返回值-3" class="headerlink" title="返回值"></a>返回值</h4><p>执行加法操作之后 field 域的值。</p><h4 id="示例-5"><a href="#示例-5" class="headerlink" title="示例"></a>示例</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"># 值和增量都是普通小数</div><div class="line">redis&gt; HSET mykey field 10.50</div><div class="line">(integer) 1</div><div class="line">redis&gt; HINCRBYFLOAT mykey field 0.1</div><div class="line">&quot;10.6&quot;</div><div class="line"># 值和增量都是指数符号</div><div class="line">redis&gt; HSET mykey field 5.0e3</div><div class="line">(integer) 0</div><div class="line">redis&gt; HINCRBYFLOAT mykey field 2.0e2</div><div class="line">&quot;5200&quot;</div><div class="line"># 对不存在的键执行 HINCRBYFLOAT</div><div class="line">redis&gt; EXISTS price</div><div class="line">(integer) 0</div><div class="line">redis&gt; HINCRBYFLOAT price milk 3.5</div><div class="line">&quot;3.5&quot;</div><div class="line">redis&gt; HGETALL price</div><div class="line">1) &quot;milk&quot;</div><div class="line">2) &quot;3.5&quot;</div><div class="line"># 对不存在的域进行 HINCRBYFLOAT</div><div class="line">redis&gt; HGETALL price</div><div class="line">1) &quot;milk&quot;</div><div class="line">2) &quot;3.5&quot;</div><div class="line">redis&gt; HINCRBYFLOAT price coffee 4.5   # 新增 coffee 域</div><div class="line">&quot;4.5&quot;</div><div class="line">redis&gt; HGETALL price</div><div class="line">1) &quot;milk&quot;</div><div class="line">2) &quot;3.5&quot;</div><div class="line">3) &quot;coffee&quot;</div><div class="line">4) &quot;4.5&quot;</div></pre></td></tr></table></figure><h3 id="HKEYS"><a href="#HKEYS" class="headerlink" title="HKEYS"></a><strong>HKEYS</strong></h3><p><strong>HKEYS key</strong></p><p> 返回哈希表 key 中的所有域。</p><h4 id="可用版本-6"><a href="#可用版本-6" class="headerlink" title="可用版本"></a>可用版本</h4><p>版本&gt;= 2.0.0</p><h4 id="时间复杂度-6"><a href="#时间复杂度-6" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><p>O(N)， N 为哈希表的大小。</p><h4 id="返回值-4"><a href="#返回值-4" class="headerlink" title="返回值"></a>返回值</h4><p>一个包含哈希表中所有域的表。<br>当 key 不存在时，返回一个空表。</p><h4 id="示例-6"><a href="#示例-6" class="headerlink" title="示例"></a>示例</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"># 哈希表非空</div><div class="line">redis&gt; HMSET website google www.google.com yahoo www.yahoo.com</div><div class="line">OK</div><div class="line">redis&gt; HKEYS website</div><div class="line">1) &quot;google&quot;</div><div class="line">2) &quot;yahoo&quot;</div><div class="line"># 空哈希表/key不存在</div><div class="line">redis&gt; EXISTS fake_key</div><div class="line">(integer) 0</div><div class="line">redis&gt; HKEYS fake_key</div><div class="line">(empty list or set)</div><div class="line">HLEN</div><div class="line">HLEN key</div><div class="line">返回哈希表 key 中域的数量。</div><div class="line">时间复杂度：</div><div class="line">O(1)</div><div class="line">返回值：</div><div class="line">哈希表中域的数量。</div><div class="line">当 key 不存在时，返回 0 。</div><div class="line">redis&gt; HSET db redis redis.com</div><div class="line">(integer) 1</div><div class="line">redis&gt; HSET db mysql mysql.com</div><div class="line">(integer) 1</div><div class="line">redis&gt; HLEN db</div><div class="line">(integer) 2</div><div class="line">redis&gt; HSET db mongodb mongodb.org</div><div class="line">(integer) 1</div><div class="line">redis&gt; HLEN db</div><div class="line">(integer) 3</div></pre></td></tr></table></figure><h3 id="HMGET"><a href="#HMGET" class="headerlink" title="HMGET"></a><strong>HMGET</strong></h3><p><strong>HMGET key field [field …]</strong></p><p> 返回哈希表 key 中，一个或多个给定域的值。<br> 如果给定的域不存在于哈希表，那么返回一个 nil 值。<br> 因为不存在的 key 被当作一个空哈希表来处理，所以对一个不存在的 key 进行 HMGET 操作将返回一个只带有 nil 值的表。</p><h4 id="可用版本-7"><a href="#可用版本-7" class="headerlink" title="可用版本"></a>可用版本</h4><p>版本&gt;= 2.0.0</p><h4 id="时间复杂度-7"><a href="#时间复杂度-7" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><p>O(N)， N 为给定域的数量。</p><h4 id="返回值-5"><a href="#返回值-5" class="headerlink" title="返回值"></a>返回值</h4><p>一个包含多个给定域的关联值的表，表值的排列顺序和给定域参数的请求顺序一样。</p><h4 id="示例-7"><a href="#示例-7" class="headerlink" title="示例"></a>示例</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">redis&gt; HMSET pet dog &quot;doudou&quot; cat &quot;nounou&quot;    # 一次设置多个域</div><div class="line">OK</div><div class="line">redis&gt; HMGET pet dog cat fake_pet             # 返回值的顺序和传入参数的顺序一样</div><div class="line">1) &quot;doudou&quot;</div><div class="line">2) &quot;nounou&quot;</div><div class="line">3) (nil)                                      # 不存在的域返回nil值</div></pre></td></tr></table></figure><h3 id="HMSET"><a href="#HMSET" class="headerlink" title="HMSET"></a><strong>HMSET</strong></h3><p><strong>HMSET key field value [field value …]</strong></p><p> 同时将多个 field-value (域-值)对设置到哈希表 key 中。<br> 此命令会覆盖哈希表中已存在的域。<br> 如果 key 不存在，一个空哈希表被创建并执行 HMSET 操作。</p><h4 id="可用版本-8"><a href="#可用版本-8" class="headerlink" title="可用版本"></a>可用版本</h4><p>版本&gt;= 2.0.0</p><h4 id="时间复杂度-8"><a href="#时间复杂度-8" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><p>O(N)， N 为 field-value 对的数量。</p><h4 id="返回值-6"><a href="#返回值-6" class="headerlink" title="返回值"></a>返回值</h4><p>如果命令执行成功，返回 OK 。<br>当 key 不是哈希表(hash)类型时，返回一个错误。</p><h4 id="示例-8"><a href="#示例-8" class="headerlink" title="示例"></a>示例</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">redis&gt; HMSET website google www.google.com yahoo www.yahoo.com</div><div class="line">OK</div><div class="line">redis&gt; HGET website google</div><div class="line">&quot;www.google.com&quot;</div><div class="line">redis&gt; HGET website yahoo</div><div class="line">&quot;www.yahoo.com&quot;</div></pre></td></tr></table></figure><h3 id="HSET"><a href="#HSET" class="headerlink" title="HSET"></a><strong>HSET</strong></h3><p><strong>HSET key field value</strong></p><p> 将哈希表 key 中的域 field 的值设为 value 。<br> 如果 key 不存在，一个新的哈希表被创建并进行 HSET 操作。<br> 如果域 field 已经存在于哈希表中，旧值将被覆盖。</p><h4 id="可用版本-9"><a href="#可用版本-9" class="headerlink" title="可用版本"></a>可用版本</h4><p>版本&gt;= 2.0.0</p><h4 id="时间复杂度-9"><a href="#时间复杂度-9" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><p>O(1)</p><h4 id="返回值-7"><a href="#返回值-7" class="headerlink" title="返回值"></a>返回值</h4><p>如果 field 是哈希表中的一个新建域，并且值设置成功，返回 1 。<br>如果哈希表中域 field 已经存在且旧值已被新值覆盖，返回 0 。</p><h4 id="示例-9"><a href="#示例-9" class="headerlink" title="示例"></a>示例</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">redis&gt; HSET website google &quot;www.g.cn&quot;       # 设置一个新域</div><div class="line">(integer) 1</div><div class="line">redis&gt; HSET website google &quot;www.google.com&quot; # 覆盖一个旧域</div><div class="line">(integer) 0</div></pre></td></tr></table></figure><h3 id="HSETNX"><a href="#HSETNX" class="headerlink" title="HSETNX"></a><strong>HSETNX</strong></h3><p><strong>HSETNX key field value</strong></p><p> 将哈希表 key 中的域 field 的值设置为 value ，当且仅当域 field 不存在。<br> 若域 field 已经存在，该操作无效。<br> 如果 key 不存在，一个新哈希表被创建并执行 HSETNX 命令。</p><h4 id="可用版本-10"><a href="#可用版本-10" class="headerlink" title="可用版本"></a>可用版本</h4><p>版本&gt;= 2.0.0</p><h4 id="时间复杂度-10"><a href="#时间复杂度-10" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><p>O(1)</p><h4 id="返回值-8"><a href="#返回值-8" class="headerlink" title="返回值"></a>返回值</h4><p>设置成功，返回 1 。<br>如果给定域已经存在且没有操作被执行，返回 0 。</p><h4 id="示例-10"><a href="#示例-10" class="headerlink" title="示例"></a>示例</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">redis&gt; HSETNX nosql key-value-store redis</div><div class="line">(integer) 1</div><div class="line">redis&gt; HSETNX nosql key-value-store redis       # 操作无效，域 key-value-store 已存在</div><div class="line">(integer) 0</div></pre></td></tr></table></figure><h3 id="HVALS"><a href="#HVALS" class="headerlink" title="HVALS"></a><strong>HVALS</strong></h3><p><strong>HVALS key</strong></p><p> 返回哈希表 key 中所有域的值。</p><h4 id="可用版本-11"><a href="#可用版本-11" class="headerlink" title="可用版本"></a>可用版本</h4><p>版本&gt;= 2.0.0</p><h4 id="时间复杂度-11"><a href="#时间复杂度-11" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><p>O(N)， N 为哈希表的大小。</p><h4 id="返回值-9"><a href="#返回值-9" class="headerlink" title="返回值"></a>返回值</h4><p>一个包含哈希表中所有值的表。<br>当 key 不存在时，返回一个空表。</p><h4 id="示例-11"><a href="#示例-11" class="headerlink" title="示例"></a>示例</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"># 非空哈希表</div><div class="line">redis&gt; HMSET website google www.google.com yahoo www.yahoo.com</div><div class="line">OK</div><div class="line">redis&gt; HVALS website</div><div class="line">1) &quot;www.google.com&quot;</div><div class="line">2) &quot;www.yahoo.com&quot;</div><div class="line"># 空哈希表/不存在的key</div><div class="line">redis&gt; EXISTS not_exists</div><div class="line">(integer) 0</div><div class="line">redis&gt; HVALS not_exists</div><div class="line">(empty list or set)</div></pre></td></tr></table></figure><p><strong>HSCAN</strong><br><strong>HSCAN key cursor [MATCH pattern] [COUNT count]</strong><br> 具体信息请参考 SCAN 命令。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Redis的散列可以存储多个键值对之间的映射。和字符串一样，散列存储的值既可以是字符串又可以是数字值，并且用户同样子可以对散列存储的数字执行自增操作或者自减操作。&lt;br&gt;结构的读写：&lt;br&gt; 添加、获取、移除单个键值对&lt;br&gt; 获取所有的键值对&lt;br&gt;
    
    </summary>
    
      <category term="Redis" scheme="http://yoursite.com/categories/Redis/"/>
    
    
      <category term="Redis" scheme="http://yoursite.com/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>了解如何搭建自己的hexo博客</title>
    <link href="http://yoursite.com/2016/12/11/%E4%BA%86%E8%A7%A3%E5%A6%82%E4%BD%95%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84hexo%E5%8D%9A%E5%AE%A2/"/>
    <id>http://yoursite.com/2016/12/11/了解如何搭建自己的hexo博客/</id>
    <published>2016-12-11T01:42:47.000Z</published>
    <updated>2017-09-28T08:23:24.531Z</updated>
    
    <content type="html"><![CDATA[<p>前段时间在朋友的帮助下，也找过很多资料来搭建自己的hexo博客，之前也就是在简述上写自己的博客文章，说真的，自己如果懂得如何搭建博客来写，更有些自豪感。废话就不多说了，下面就来了解一下hexo以及如何搭建一个属于自己的hexo博客。<br><a id="more"></a></p><h3 id="了解hexo"><a href="#了解hexo" class="headerlink" title="了解hexo"></a>了解hexo</h3><p><a href="https://hexo.io/zh-cn/docs/" target="_blank" rel="external">hexo文档</a>给出的hexo定义是：Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。</p><blockquote><p>hexo出自台湾的tommy351之手，一个基于Node.js的静态博客程序，可以很方便的生成静态网页托管于github、gitcafe和Heroku，类似于jekyll，但Jekyll需要的git命令稍有点繁琐。</p></blockquote><p>重要的是hexo是免费的，可以在各个平台上搭建，如GitHub、GitCafe、coding、七牛。可以快速渲染自己编写的markdown文件。</p><h3 id="hexo的依赖"><a href="#hexo的依赖" class="headerlink" title="hexo的依赖"></a>hexo的依赖</h3><ul><li>搭建nodejs环境 <strong> （必须） </strong><br><a href="https://nodejs.org/zh-cn/" target="_blank" rel="external">node官网</a></li><li><p>git <strong> （必须） </strong></p><ul><li>windows 下载：<a href="https://git-scm.com/downloads" target="_blank" rel="external">git</a></li><li>linux 下载：<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ sudo apt-get update</div><div class="line">$ sudo apt-get install git</div></pre></td></tr></table></figure></li></ul></li><li><p>coding（<strong> 必须 </strong> ，可以用github来搭建）</p></li><li><p>域名（个性化）<br>域名只是让你的博客访问更有个性化，coding默认的访问博客的地址是 <code>http://your-coding-name.coding.me/your-repo-name</code> ，在github中的访问地址是：<code>https://your-github-name.github.io/your-repo-name/</code></p></li></ul><p>编写hexo可以使用Atom，我挺喜欢这款编辑器的markdown预览功能</p><h3 id="安装hexo"><a href="#安装hexo" class="headerlink" title="安装hexo"></a>安装hexo</h3><p>安装hexo，打开git bash操作界面（cmd界面也可以）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm install -g hexo</div></pre></td></tr></table></figure></p><p>初始化blog项目，并安装依赖<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">mkdir blog</div><div class="line">cd blog</div><div class="line">hexo init</div><div class="line">npm install</div></pre></td></tr></table></figure></p><p>运行hexo，在本地中预览 - 全称（hexo server）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">hexo s</div></pre></td></tr></table></figure></p><p>直接输入<code>http://localhost:4000/</code>就可以看到本地部署的hexo</p><p>紧接着就创建自己的coding项目，把本地的hexo放到远程的coding上运行。</p><p>本人是把hexo放在master分支，博文放到coding-pages分支中。</p><h3 id="在coding中创建博客项目"><a href="#在coding中创建博客项目" class="headerlink" title="在coding中创建博客项目"></a>在coding中创建博客项目</h3><h4 id="创建博客项目"><a href="#创建博客项目" class="headerlink" title="创建博客项目"></a>创建博客项目</h4><p><img src="/pic/hexo-blog-1.png" alt="创建博客项目"></p><img src="/pic/hexo-blog-1.png" title="[创建博客项目[创建博客项目]]"><p>这时写上项目名以及项目的描述。</p><h4 id="绑定ssh"><a href="#绑定ssh" class="headerlink" title="绑定ssh"></a>绑定ssh</h4><h5 id="检查本地是否存在ssh-key："><a href="#检查本地是否存在ssh-key：" class="headerlink" title="检查本地是否存在ssh key："></a>检查本地是否存在ssh key：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ cd ~/.ssh</div></pre></td></tr></table></figure><h5 id="生成ssh"><a href="#生成ssh" class="headerlink" title="生成ssh"></a>生成ssh</h5><p>如果本地没有，那么就在本地中生成ssh证书，生成的证书中有两个文件，一个是私钥，一个是公钥。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ssh-keygen -t rsa -C &quot;邮箱地址&quot;</div></pre></td></tr></table></figure></p><p>执行以上代码，会弹出是否需要输入密码，输不输入密码关系不大，这里选择不输入密码。</p><p>把公钥(id_rsa.pub)的内容拷贝到coding账户 -&gt; SSH公钥 -&gt; 新增公钥的内容中去，写上公钥名字，以及将公钥的有效期的<code>永久有效勾上</code></p><h5 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h5><p>对于coding，git@git.coding.net<br>（在windows中是没有ssh指令，可以使用git bash命令窗口就能找到）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ ssh -T git@git.coding.net</div></pre></td></tr></table></figure></p><p>对于github，git@github.com不需要修改<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ ssh -T git@github.com</div></pre></td></tr></table></figure></p><p>会出现类以下的反馈<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">The authenticity of host &apos;github.com (207.97.227.239)&apos; can&apos;t be established.</div><div class="line">RSA key fingerprint is 16:27:ac:a5:76:28:2d:36:63:1b:56:4d:eb:df:a6:48.</div><div class="line">Are you sure you want to continue connecting (yes/no)?</div></pre></td></tr></table></figure></p><p>点击yes，就ok了。</p><h3 id="在hexo中配置与coding相连"><a href="#在hexo中配置与coding相连" class="headerlink" title="在hexo中配置与coding相连"></a>在hexo中配置与coding相连</h3><p>打开你在本地创建的项目blog，找到_config.yml,打开<br>配置如下，将内容推送到coding-pages分支中<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">deploy:</div><div class="line">  type: git</div><div class="line">  repo: git@git.coding.net:your-coding-name/your-repo-name.git</div><div class="line">  branch: coding-pages</div></pre></td></tr></table></figure></p><h3 id="在你的博客项目blog，初始化为git仓库"><a href="#在你的博客项目blog，初始化为git仓库" class="headerlink" title="在你的博客项目blog，初始化为git仓库"></a>在你的博客项目blog，初始化为git仓库</h3><p>安装完git，需要配置以下信息<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ git config --global user.name &quot;username&quot; //用户名</div><div class="line">$ git config --global user.email  &quot;youremail&quot; //填写自己的邮箱</div></pre></td></tr></table></figure></p><p>初始化项目<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git init</div></pre></td></tr></table></figure></p><p>选择要添加进仓库的文件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git add .</div></pre></td></tr></table></figure></p><p>如果你想分享这个文件夹里所有代码，就在add后面加“.”，如果指定某个文件，只需把“.”改为文件名即可。<br>添加进入仓库：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git commit -m &quot;first commit&quot;</div></pre></td></tr></table></figure></p><p><code>-m</code>后面的参数，表示说明，将代码提交到GitHub后，将会给出一个提交说明，表明这是我哪次提交的。<br>所有工作已准备充分，现在开始提交，还是几条命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">// 添加coding源</div><div class="line">git remote add origin git@git.coding.net:your-coding-name/your-repo-name.git</div><div class="line">// 执行 git push 没有指定分支时，只有当前分支会被 push 到你使用 git pull 获取的代码。</div><div class="line">git config --global push.default simple</div><div class="line">// 上传本地项目代码到master分支</div><div class="line">git push -u origin master</div></pre></td></tr></table></figure></p><h3 id="开启Pages服务及配置域名"><a href="#开启Pages服务及配置域名" class="headerlink" title="开启Pages服务及配置域名"></a>开启Pages服务及配置域名</h3><h4 id="域名的使用"><a href="#域名的使用" class="headerlink" title="域名的使用"></a>域名的使用</h4><p>购买域名后，可以配置子域名来绑定hexo博客</p><ul><li>将记录类型设置成CNAME</li><li>主机记录，你喜欢</li><li>记录值设置成，pages.coding.me<br>设置成那样就可以了</li></ul><h4 id="Pages里添加域名访问呢"><a href="#Pages里添加域名访问呢" class="headerlink" title="Pages里添加域名访问呢"></a>Pages里添加域名访问呢</h4><p>进入刚才创建的项目中，点击左侧的代码，再进入Pages服务页面中，点击立即开启，部署来源选择coding-pages分支。</p><p>好像是找不到coding-pages分支的，那么就要手动创建一个coding-pages分支，然后指定分支开启服务。</p><p>在自定义域名里，可以填写自己已经注册的域名，这样就可以通过自己的域名去访问你的博客</p><h3 id="开始使用"><a href="#开始使用" class="headerlink" title="开始使用"></a>开始使用</h3><p>以上配置好后，使用域名就可以访问了</p><h4 id="新建文章"><a href="#新建文章" class="headerlink" title="新建文章"></a>新建文章</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">hexo n &quot;postName&quot; 相当于 hexo new &quot;postName&quot;</div></pre></td></tr></table></figure><h4 id="新建页面"><a href="#新建页面" class="headerlink" title="新建页面"></a>新建页面</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">hexo n page &quot;pageName&quot; 相当于hexo new page &quot;pageName&quot;</div></pre></td></tr></table></figure><h4 id="生成静态页面至public目录"><a href="#生成静态页面至public目录" class="headerlink" title="生成静态页面至public目录"></a>生成静态页面至public目录</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">hexo g 相当于hexo generate</div></pre></td></tr></table></figure><h4 id="开启预览本地博客服务，地址为http-localhost-4000"><a href="#开启预览本地博客服务，地址为http-localhost-4000" class="headerlink" title="开启预览本地博客服务，地址为http://localhost:4000/"></a>开启预览本地博客服务，地址为<code>http://localhost:4000/</code></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">hexo s 相当于hexo server</div></pre></td></tr></table></figure><h4 id="将-deploy目录部署到远程项目中"><a href="#将-deploy目录部署到远程项目中" class="headerlink" title="将.deploy目录部署到远程项目中"></a>将.deploy目录部署到远程项目中</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">hexo d 相当于hexo deplog</div></pre></td></tr></table></figure><p>安装<code>hexo-deployer-git</code>插件 - 第一次使用要安装这个插件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm install hexo-deployer-git --save</div></pre></td></tr></table></figure></p><h4 id="清除缓存文件-db-json-和已生成的静态文件-public"><a href="#清除缓存文件-db-json-和已生成的静态文件-public" class="headerlink" title="清除缓存文件 (db.json) 和已生成的静态文件 (public)"></a>清除缓存文件 (db.json) 和已生成的静态文件 (public)</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">hexo clean</div></pre></td></tr></table></figure><h4 id="查看帮助"><a href="#查看帮助" class="headerlink" title="查看帮助"></a>查看帮助</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">hexo h 相当于hexo help</div></pre></td></tr></table></figure><h4 id="查看hexo的版本"><a href="#查看hexo的版本" class="headerlink" title="查看hexo的版本"></a>查看hexo的版本</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">hexo v 相当于hexo version</div></pre></td></tr></table></figure><p>一般你写好自己的文章或配置好自己的设置，使用以下命令即可<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">hexo clean</div><div class="line">hexo g</div><div class="line">hexo d</div></pre></td></tr></table></figure></p><h3 id="主题-我这个主题为Next"><a href="#主题-我这个主题为Next" class="headerlink" title="主题 - 我这个主题为Next"></a>主题 - 我这个主题为Next</h3><h4 id="下载Next主题"><a href="#下载Next主题" class="headerlink" title="下载Next主题"></a>下载Next主题</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ cd your-hexo-site`</div><div class="line">$ git clone https://github.com/iissnan/hexo-theme-next themes/next</div></pre></td></tr></table></figure><h4 id="修改配置文件"><a href="#修改配置文件" class="headerlink" title="修改配置文件"></a>修改配置文件</h4><p>找到根目录下的_config.yml文件，修改theme使支持<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"># Extensions</div><div class="line">## Plugins: http://hexo.io/plugins/</div><div class="line">## Themes: http://hexo.io/themes/</div><div class="line">#theme: landscape</div><div class="line">theme: next</div></pre></td></tr></table></figure></p><h4 id="选择Scheme为Mist，自己觉得这个样式会比较好看"><a href="#选择Scheme为Mist，自己觉得这个样式会比较好看" class="headerlink" title="选择Scheme为Mist，自己觉得这个样式会比较好看"></a>选择Scheme为Mist，自己觉得这个样式会比较好看</h4><p>找到主题配置文件，blog/themes/next目录下的_config.yml文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"># Schemes</div><div class="line">#scheme: Muse</div><div class="line">scheme: Mist</div><div class="line">#scheme: Pisces</div></pre></td></tr></table></figure></p><h4 id="添加tags标签，与页面中的tag对应"><a href="#添加tags标签，与页面中的tag对应" class="headerlink" title="添加tags标签，与页面中的tag对应"></a>添加tags标签，与页面中的tag对应</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">hexo new page &quot;tags&quot;</div></pre></td></tr></table></figure><p>修改/source/tags/index.md文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">title: tags</div><div class="line">date: 2016-12-04 09:06:02</div><div class="line">type: &quot;tags&quot;</div><div class="line">---</div></pre></td></tr></table></figure></p><h3 id="其他配置"><a href="#其他配置" class="headerlink" title="其他配置"></a>其他配置</h3><h4 id="配置域名与hexo关联"><a href="#配置域名与hexo关联" class="headerlink" title="配置域名与hexo关联"></a>配置域名与hexo关联</h4><p>前面配置的是，域名与coding之间的关联。</p><p>找到根目录的_config.yml文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"># URL</div><div class="line">## If your site is put in a subdirectory, set url as &apos;http://yoursite.com/child&apos; and root as &apos;/child/&apos;</div><div class="line">url: 填写你的域名地址</div><div class="line">root: /</div><div class="line">permalink: :year/:month/:day/:title/</div><div class="line">permalink_defaults:</div></pre></td></tr></table></figure></p><h4 id="配置头像"><a href="#配置头像" class="headerlink" title="配置头像"></a>配置头像</h4><p>在根目录的_config.yml，me.jpg需要放到/blog/source/images目录下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"># 头像</div><div class="line">avatar: /images/me.jpg</div></pre></td></tr></table></figure></p><h4 id="配置多说评论"><a href="#配置多说评论" class="headerlink" title="配置多说评论"></a>配置多说评论</h4><p>在根目录下的配置文件_config.yml添加字段<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">duoshuo_shortname: commit</div></pre></td></tr></table></figure></p><p>commit为你注册多说域名的子域名，就如你多说的域名为：<code>http://commit.duoshuo.com</code></p><h4 id="使你的菜单栏显示中文"><a href="#使你的菜单栏显示中文" class="headerlink" title="使你的菜单栏显示中文"></a>使你的菜单栏显示中文</h4><p>在根目录下的配置文件_config.yml找到language字段，修改为<code>zh-Hans</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"># Site</div><div class="line">language: zh-Hans</div></pre></td></tr></table></figure></p><h4 id="配置社交链接"><a href="#配置社交链接" class="headerlink" title="配置社交链接"></a>配置社交链接</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"># Social links</div><div class="line">social:</div><div class="line">  GitHub: git地址</div><div class="line"># Social Icons</div><div class="line">social_icons:</div><div class="line">  enable: true</div><div class="line">  # Icon Mappings</div><div class="line">  GitHub: github</div></pre></td></tr></table></figure><p>如果想添加其他社交链接，可以查看官方文档</p><h4 id="配置hexo插件"><a href="#配置hexo插件" class="headerlink" title="配置hexo插件"></a>配置hexo插件</h4><h5 id="添加网站地图"><a href="#添加网站地图" class="headerlink" title="添加网站地图"></a>添加网站地图</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">npm install hexo-generator-sitemap --save</div><div class="line">npm install hexo-generator-baidu-sitemap --save</div></pre></td></tr></table></figure><p>在站点配置文件_config.yml中添加如下代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"># hexo sitemap</div><div class="line">sitemap:</div><div class="line">path: sitemap.xml</div><div class="line">baidusitemap:</div><div class="line">path: baidusitemap.xml</div></pre></td></tr></table></figure></p><p>配置成功后，会生成在public目录下生成sitemap.xml 和 baidusitemap.xml，前者适合提交给谷歌搜素引擎，后者适合提交百度搜索引擎。</p><p>其次，在 robots.txt 中添加下面的一段代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Sitemap: http://blog.tangxiaozhu.com/sitemap.xml</div><div class="line">Sitemap: http://blog.tangxiaozhu.com/baidusitemap.xml</div></pre></td></tr></table></figure></p><p>将<code>robots.txt</code> 放置在<code>\source</code> 目录下。</p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://hexo.io/zh-cn/docs/" target="_blank" rel="external">hexo官方文档</a><br><a href="http://theme-next.iissnan.com/theme-settings.html" target="_blank" rel="external">next主题文档</a><br><a href="http://blog.tangxiaozhu.com/p/45374067/" target="_blank" rel="external">使用 Hexo 搭建博客的深度优化与定制</a><br><a href="http://zhiho.github.io/2015/09/29/hexo-next/" target="_blank" rel="external">Hexo搭建GitHub博客（三）- NexT主题配置使用</a><br><a href="http://www.jianshu.com/p/465830080ea9" target="_blank" rel="external">HEXO+Github,搭建属于自己的博客</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前段时间在朋友的帮助下，也找过很多资料来搭建自己的hexo博客，之前也就是在简述上写自己的博客文章，说真的，自己如果懂得如何搭建博客来写，更有些自豪感。废话就不多说了，下面就来了解一下hexo以及如何搭建一个属于自己的hexo博客。&lt;br&gt;
    
    </summary>
    
      <category term="Blog" scheme="http://yoursite.com/categories/Blog/"/>
    
    
      <category term="Hexo" scheme="http://yoursite.com/tags/Hexo/"/>
    
  </entry>
  
</feed>
