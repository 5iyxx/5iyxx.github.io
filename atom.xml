<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>5IYXX</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2017-11-22T17:29:52.294Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Eric Chen</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>实战:OutOfMemoryError异常</title>
    <link href="http://yoursite.com/2017/11/22/OutOfMemoryError%E5%BC%82%E5%B8%B8/"/>
    <id>http://yoursite.com/2017/11/22/OutOfMemoryError异常/</id>
    <published>2017-11-22T13:53:55.000Z</published>
    <updated>2017-11-22T17:29:52.294Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><h3 id="虚拟机栈和本地方法栈溢出"><a href="#虚拟机栈和本地方法栈溢出" class="headerlink" title="虚拟机栈和本地方法栈溢出"></a>虚拟机栈和本地方法栈溢出</h3><p>由于在HotSpot虚拟机中并不区分虚拟机栈和本地方法栈,因此 ,对于HotSpot来 说 ,虽然-Xoss参数 (设置本地方法栈大小)存在 ,但实际上是无效的,栈容量只由-Xss参数设定。 关于虚拟机栈和本地方法栈,在Java虚拟机规范中描述了两种异常:</p><ul><li>如果线程请求的栈深度大于虚拟机所允许的最大深度,将拋出StackOverflowError异常。</li><li>如果虚拟机在扩展栈时无法申请到足够的内存空间,则拋出OutOMemoryError异常。</li></ul><p>这里把异常分成两种情况,看似更加严谨,但却存在着一些互相重叠的地方:<strong>当栈空间无法继续分配时,到底是内存太小,还是已使用的栈空间太大,其本质上只是对同一件事情的两种描述而已</strong>。</p><p>在笔者的实验中,将实验范围限制于单线程中的操作,尝试了下面两种方法均无法让虚拟机产生OutOfMemoryError异常 ,尝试的结果都是获得StackOverflowError异 常 ,测试代码如代码清单2所示。</p><ul><li>使用-Xss参数减少栈内存容量。结果 :拋出StackOverflowError异常 ,异常出现时输出的堆栈深度相应缩小。</li><li>定义了大量的本地变量,增大此方法帧中本地变量表的长度。结果:拋出 StackOverflowError异常时输出的堆栈深度相应缩小。</li></ul><p><strong>代码清单2 虚拟机找和本地方法栈OOM测试(仅作为第1点测试程序)</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * -verbose:gc -Xss128k</div><div class="line"> * @author eric</div><div class="line"> *</div><div class="line"> */</div><div class="line">public class JavaVMStackSOF &#123;</div><div class="line"></div><div class="line">private int stackLength=1;</div><div class="line">public void stackLeak()&#123;</div><div class="line">stackLength++;</div><div class="line">stackLeak();</div><div class="line">&#125;</div><div class="line">public static void main(String[] args) &#123;</div><div class="line">// TODO Auto-generated method stub</div><div class="line"></div><div class="line">JavaVMStackSOF oom=new JavaVMStackSOF();</div><div class="line">try&#123;</div><div class="line">oom.stackLeak();</div><div class="line">&#125;catch(Throwable e)&#123;</div><div class="line">System.out.println(&quot;stack length:&quot;+oom.stackLength);</div><div class="line">        throw e;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>运行结果：<br>stack length:17650<br>Exception in thread “main” java.lang.StackOverflowError<br>    at Chapter_02.JavaVMStackSOF.stackLeak(JavaVMStackSOF.java:12)<br>    at Chapter_02.JavaVMStackSOF.stackLeak(JavaVMStackSOF.java:12)<br>    …..后续异常堆栈信息省略</p><p>实验结果表明:在单个线程下,无论是由于栈帧（一个方法中包含的本地变量数）太大还是虚拟机栈容量（-Xss参数减少每个线程栈内存容量）太小,当内存无法分配的时候,虚拟机拋出的都是StackOverflowError异常。<br>如果测试时不限于单线程,通过不断地建立线程的方式倒是可以产生内存溢出异常,如代码清单2-5所示。但是这样产生的内存溢出异常与栈空间是否足够大并不存在任何联系,或者准确地说，在这种情况下，为每个线程的栈分配的内存越大，反而越容易产生内存溢出异常。<br>其实原因不难理解,操作系统分配给每个进程的内存是有限制的,譬如32位的Windows 限制为2GB。虚拟机提供了参数来控制Java堆和方法区的这两部分内存的最大值。剩余的内存为2GB ( 操作系统限制)减去Xmx ( 最大堆容量),再减去MaxPermSize (最大方法区容量 ),程序计数器消耗内存很小,可以忽略掉。如果虚拟机进程本身耗费的内存不计算在内 ,剩下的内存就由虚拟机栈和本地方法栈“瓜分” 了。每个线程分配到的栈容量越大,可以建立的线程数量自然就越少,建立线程时就越容易把剩下的内存耗尽。<br>这一点读者需要在开发多线程的应用时特别注意,出现StackOverflowError异常时有错误堆栈可以阅读,相对来说,比较容易找到问题的所在。而且 ,如果使用虚拟机默认参数,栈深度在大多数情况下(因为每个方法压入栈的帧大小并不是一样的,所以只能说在大多数情况下)达到1000〜2000完全没有问题,对于正常的方法调用(包括递归),这个深度应该完全够用了。但是 ,如果是建立过多线程导致的内存溢出,在不能减少线程数或者更换64位虚拟机的情况下,就只能通过减少最大堆和减少栈容量来换取更多的线程。如果没有这方面的处理经验,这种通过“减少内存”的手段来解决内存溢出的方式会比较难以想到。<br><strong>代码清单3 创建线程导致内存溢出异常</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h3 id=&quot;虚拟机栈和本地方法栈溢出&quot;&gt;&lt;a href=&quot;#虚拟机栈和本地方法栈溢出&quot; class=&quot;headerlink&quot; title=&quot;虚拟机栈和本地方法栈溢出&quot;&gt;&lt;/a&gt;虚拟机栈和本地方法栈溢出&lt;/h3&gt;&lt;p&gt;由于在HotSpot虚拟
      
    
    </summary>
    
      <category term="Understanding The JVM" scheme="http://yoursite.com/categories/Understanding-The-JVM/"/>
    
    
      <category term="JVM" scheme="http://yoursite.com/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>HotSpot虚拟机对象探秘</title>
    <link href="http://yoursite.com/2017/11/22/HotSpot%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AF%B9%E8%B1%A1%E6%8E%A2%E7%A7%98/"/>
    <id>http://yoursite.com/2017/11/22/HotSpot虚拟机对象探秘/</id>
    <published>2017-11-22T01:21:55.000Z</published>
    <updated>2017-11-22T05:38:28.197Z</updated>
    
    <content type="html"><![CDATA[<p>以常用的虚拟机HotSpot和常用的内存区域Java堆为例，深入探讨HotSpot虚拟机在Java堆中对象分配、布局和访问的全过程。<br><a id="more"></a></p><h3 id="对象的创建"><a href="#对象的创建" class="headerlink" title="对象的创建"></a>对象的创建</h3><p>Java是一门面向对象的编程语言，在Java编程运行过程中无时无刻都有被创建出来。在语言层面上，创建对象(例如克隆、反序列化)通常仅仅是一个new关键字而已，而在虚拟机中，对象(文中讨论的对象限于普通Java对象，不包括数组和Class对象等)的创建又是怎样一个过程呢？<br><strong>虚拟机遇到一条new指令时，首先将去检查这个指令的参数是否能在常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已被加载、解析和初始化过。如果没有，那必须先执行相应的类加载过程</strong>。<br>在类加载检查通过后，接下来虚拟机将为新生对象分配内存。对象所需内存的大小在类加载完成后便可完全确定，为对象分配空间的任务等同于把一块确定大小的内存从Java堆中划分出来。假设Java堆中内存是绝对规整的，所有用过的内存都放在一边，空闲的内存另一边，中间放着一个指针作为分界点的指示器，这种分配方式称为“<strong>指针碰撞</strong>”（Bump the Pointer）。如果Java堆中的内存并不是规整的，已使用的内存和空闲的内存相互交错，那就没有办法简单地进行指针碰撞了，虚拟机就必须维护一个列表，记录哪些内存块是可用的，在分配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上的记录，这种分配方式称为“<strong>空闲列表</strong>（Free List）”。选择哪种分配方式由Java堆是否规整决定，而Java堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定。因此，在使用Serial、ParNew等带有Compact过程的收集器时，系统采用的分配算法是指针碰撞，而使用CMS这种基于Mark-Sweep算法的收集器时，通常采用空闲列表。<br>除如何划分可用空间之外，还有另外一个需要考虑的问题是对象创建在虚拟机中是非常频繁的行为，即使是仅仅修改一个指针所指向的位置，在并发情况下也并不是线程安全的，可能出现正在给对象A分配内存，指针还没来得及修改，对象B又同时使用了原来的指针来分配内存的情况。解决这个问题有两种方案，一种是对分配内存空间的动作进行同步处理————实际上虚拟机采用CAS配上失败重试的方式保证更新操作的原子性；另一种是把内存的动作按照线程划分在不同额空间之中进行，即每个线程在Java堆中预先分配一块内存，称为本地线程分配缓冲(Thread Local Allocation Buffer,TLAB)。哪个线程要分配内存，就在哪个线程的TLAB上分配，只有TLAB用完并分配新的FLAB时，才需要同步锁定。<strong>虚拟机是否使用TLAB，可以通过-XX:+/-UseTLAB参数来设定</strong>。<br>内存分配完成后，虚拟机需要将分配到的内存空间都初始化为零值(不包括对象头)，如果使用TLAB，这一工作过程也可以提前至TLAB分配时进行。这一步操作保证了对象的实例字段在Java代码中可以不赋初始值就直接使用，程序能访问到这些字段的数据类型所对应的零值。<br>接下来，虚拟机要对对象进行必要的设置，例如这个对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的GC分代年龄等信息。这些信息存放在对象的对象头(Object Header)之中。根据虚拟机当前的运行状态的不同，如是否启用偏向锁等，对象头会有不同的设置方式。<br>在上面工作都完成之后，<strong>从虚拟机的视角来看，一个新的对象已经产生了，但从Java程序的视角来看，对象创建才刚刚开始————<int>方法还没有执行，所有的字段都还为零</int></strong>。所以，一般来说（由字节码中是否跟随invokespecial指令所决定），执行new指令之后会接着执行<init>方法，把对象按照程序员的意愿进行初始化，这样一个真正可用的对象才算完全产生出来。<br>下面代码清单1是HotSpot虚拟机bytecodeInterpreter.cpp中的代码片段（这个解释器实现很少有机会实际使用，因为大部分平台了都使用模版解释器；当代码通过JIT编译器执行是差异就更大。不过，这段代码用于了解HotSpot的运行过程是没有什么问题的）。<br><strong>代码清单1 HotSpot解释器的代码片段</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div></pre></td><td class="code"><pre><div class="line">// 确保常量池中存放的是已解释的类 </div><div class="line">if (!constants-&gt;tag_at(index).is_unresolved_klass()) &#123; </div><div class="line">    // 断言确保是klassOop和instanceKlassOop（这部分下一节介绍） </div><div class="line">    oop entry = (klassOop) *constants-&gt;obj_at_addr(index); </div><div class="line">    assert(entry-&gt;is_klass(), &quot;Should be resolved klass&quot;); </div><div class="line">    klassOop k_entry = (klassOop) entry; </div><div class="line">    assert(k_entry-&gt;klass_part()-&gt;oop_is_instance(), &quot;Should be instanceKlass&quot;); </div><div class="line">    instanceKlass* ik = (instanceKlass*) k_entry-&gt;klass_part(); </div><div class="line">    // 确保对象所属类型已经经过初始化阶段 </div><div class="line">    if ( ik-&gt;is_initialized() &amp;&amp; ik-&gt;can_be_fastpath_allocated() ) &#123; </div><div class="line">        // 取对象长度 </div><div class="line">        size_t obj_size = ik-&gt;size_helper(); </div><div class="line">        oop result = NULL; </div><div class="line">        // 记录是否需要将对象所有字段置零值 </div><div class="line">        bool need_zero = !ZeroTLAB; </div><div class="line">        // 是否在TLAB中分配对象 </div><div class="line">        if (UseTLAB) &#123; </div><div class="line">            result = (oop) THREAD-&gt;tlab().allocate(obj_size); </div><div class="line">        &#125; </div><div class="line">        if (result == NULL) &#123; </div><div class="line">            need_zero = true; </div><div class="line">            // 直接在eden中分配对象 </div><div class="line">            retry: </div><div class="line">                HeapWord* compare_to = *Universe::heap()-&gt;top_addr(); </div><div class="line">                HeapWord* new_top = compare_to + obj_size; </div><div class="line">                // cmpxchg是x86中的CAS指令，这里是一个C++方法，通过CAS方式分配空间，并发失败的话，转到retry中重试直至成功分配为止 </div><div class="line">                if (new_top &lt;= *Universe::heap()-&gt;end_addr()) &#123; </div><div class="line">                    if (Atomic::cmpxchg_ptr(new_top, Universe::heap()-&gt;top_addr(), compare_to) != compare_to) &#123; </div><div class="line">                        goto retry; </div><div class="line">                    &#125; </div><div class="line">                    result = (oop) compare_to; </div><div class="line">                &#125; </div><div class="line">        &#125; </div><div class="line">        if (result != NULL) &#123; </div><div class="line">            // 如果需要，为对象初始化零值 </div><div class="line">            if (need_zero ) &#123; </div><div class="line">                HeapWord* to_zero = (HeapWord*) result + sizeof(oopDesc) / oopSize; </div><div class="line">                obj_size -= sizeof(oopDesc) / oopSize; </div><div class="line">                if (obj_size &gt; 0 ) &#123; </div><div class="line">                    memset(to_zero, 0, obj_size * HeapWordSize); </div><div class="line">                &#125; </div><div class="line">            &#125; </div><div class="line">            // 根据是否启用偏向锁，设置对象头信息 </div><div class="line">            if (UseBiasedLocking) &#123; </div><div class="line">                result-&gt;set_mark(ik-&gt;prototype_header()); </div><div class="line">            &#125; else &#123; </div><div class="line">                result-&gt;set_mark(markOopDesc::prototype()); </div><div class="line">            &#125; </div><div class="line">            result-&gt;set_klass_gap(0); </div><div class="line">            result-&gt;set_klass(k_entry); </div><div class="line">            // 将对象引用入栈，继续执行下一条指令 </div><div class="line">            SET_STACK_OBJECT(result, 0); </div><div class="line">            UPDATE_PC_AND_TOS_AND_CONTINUE(3, 1); </div><div class="line">        &#125; </div><div class="line">    &#125; </div><div class="line">&#125;</div></pre></td></tr></table></figure></init></p><h3 id="对象的内存布局"><a href="#对象的内存布局" class="headerlink" title="对象的内存布局"></a>对象的内存布局</h3><p>HotSpot虚拟机中，对象在内存中存储的布局可以分为三块区域：<strong>对象头（Header）、实例数据（Instance Data）和对齐填充（Padding）</strong>。<br>HotSpot虚拟机的对象头包括两部分信息，第一部分用于存储对象自身的运行时数据，如哈希码（HashCode）、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等等，这部分数据的长度在32位和64位的虚拟机（暂不考虑开启压缩指针的场景）中分别为32个和64个Bits，官方称它为“Mark Word”。对象需要存储的运行时数据很多，其实已经超出了32、64位Bitmap结构所能记录的限度，但是对象头信息是与对象自身定义的数据无关的额外存储成本，考虑到虚拟机的空间效率，Mark Word被设计成一个非固定的数据结构以便在极小的空间内存储尽量多的信息，它会根据对象的状态复用自己的存储空间。例如在32位的HotSpot虚拟机中对象未被锁定的状态下，Mark Word的32个Bits空间中的25Bits用于存储对象哈希码（HashCode），4Bits用于存储对象分代年龄，2Bits用于存储锁标志位，1Bit固定为0，在其他状态（轻量级锁定、重量级锁定、GC标记、可偏向）下对象的存储内容如下表1所示。<br><strong>表1 HotSpot虚拟机对象头Mark Word</strong></p><table><thead><tr><th>存储内容</th><th>标志位</th><th>状态</th></tr></thead><tbody><tr><td>对象哈希码、对象分代年龄</td><td>　01　</td><td>未锁定</td></tr><tr><td>指向锁记录的指针</td><td>　00</td><td>轻量级锁定</td></tr><tr><td>指向重量级锁的指针</td><td>　10</td><td>膨胀（重量级锁定）</td></tr><tr><td>空，不需要记录信息</td><td>　11</td><td>GC标记</td></tr><tr><td>偏向线程ID、偏向时间戳、对象分代年龄</td><td>　01</td><td>可偏向</td></tr></tbody></table><p>对象头的另外一部分是类型指针，即是对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。并不是所有的虚拟机实现都必须在对象数据上保留类型指针，换句话说查找对象的元数据信息并不一定要经过对象本身，这点我们在下一节讨论。另外，如果对象是一个Java数组，那在对象头中还必须有一块用于记录数组长度的数据，因为虚拟机可以通过普通Java对象的元数据信息确定Java对象的大小，但是从数组的元数据中无法确定数组的大小。</p><p>代码清单2是HotSpot虚拟机markOop.cpp中的代码（注释）片段，它描述了32bits下MarkWord的存储状态。<br><strong>代码清单2 markOop.cpp片段</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">// Bit-format of an object header (most significant first, big endian layout below): </div><div class="line">// </div><div class="line">// 32 bits: </div><div class="line">// -------- </div><div class="line">// hash:25 ------------&gt;| age:4 biased_lock:1 lock:2 (normal object) </div><div class="line">// JavaThread*:23 epoch:2 age:4 biased_lock:1 lock:2 (biased object) </div><div class="line">// size:32 ------------------------------------------&gt;| (CMS free block) </div><div class="line">// PromotedObject*:29 ----------&gt;| promo_bits:3 -----&gt;| (CMS promoted object)</div></pre></td></tr></table></figure></p><p>接下来实例数据部分是对象真正存储的有效信息，也既是我们在程序代码里面所定义的各种类型的字段内容，无论是从父类继承下来的，还是在子类中定义的都需要记录袭来。这部分的存储顺序会受到虚拟机分配策略参数（FieldsAllocationStyle）和字段在Java源码中定义顺序的影响。HotSpot虚拟机默认的分配策略为longs/doubles、ints、shorts/chars、bytes/booleans、oops（Ordinary Object Pointers），从分配策略中可以看出，相同宽度的字段总是被分配到一起。在满足这个前提条件的情况下，在父类中定义的变量会出现在子类之前。如果CompactFields参数值为true（默认为true），那子类之中较窄的变量也可能会插入到父类变量的空隙之中。</p><p>第三部分对齐填充并不是必然存在的，也没有特别的含义，它仅仅起着占位符的作用。由于HotSpot VM的自动内存管理系统要求对象起始地址必须是8字节的整数倍，换句话说就是对象的大小必须是8字节的整数倍。对象头部分正好似8字节的倍数（1倍或者2倍），因此当对象实例数据部分没有对齐的话，就需要通过对齐填充来补全。</p><h3 id="对象的访问定位"><a href="#对象的访问定位" class="headerlink" title="对象的访问定位"></a>对象的访问定位</h3><p>建立对象是为了使用对象，我们的Java程序需要通过栈上的reference数据来操作堆上的具体对象。由于reference类型在Java虚拟机规范里面只规定了是一个指向对象的引用，并没有定义这个引用应该通过什么种方式去定位、访问到堆中的对象的具体位置，对象访问方式也是取决于虚拟机实现而定的。主流的访问方式有使用句柄和直接指针两种。</p><ul><li>如果使用句柄访问的话，Java堆中将会划分出一块内存来作为句柄池，reference中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与类型数据的具体各自的地址信息。如图1所示。</li></ul><div align="center"><br><img src="/images/JVM/j2.jpg" alt=""><br>图1 通过句柄访问对象</div><ul><li>如果使用直接指针访问的话，Java堆对象的布局中就必须考虑如何放置访问类型数据的相关信息，reference中存储的直接就是对象地址，如图2所示。</li></ul><div align="center"><br><img src="/images/JVM/j3.jpg" alt=""><br>图2 通过直接指针访问对象</div><p>这两种对象访问方式各有优势，使用句柄来访问的最大好处就是reference中存储的是稳定句柄地址，在对象被移动（垃圾收集时移动对象是非常普遍的行为）时只会改变句柄中的实例数据指针，而reference本身不需要被修改。</p><p>使用直接指针来访问最大的好处就是速度更快，它节省了一次指针定位的时间开销，由于对象访问的在Java中非常频繁，因此这类开销积小成多也是一项非常可观的执行成本。从上一部分讲解的对象内存布局可以看出，就虚拟机HotSpot而言，它是使用第二种方式进行对象访问，但在整个软件开发的范围来看，各种语言、框架中使用句柄来访问的情况也十分常见。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;以常用的虚拟机HotSpot和常用的内存区域Java堆为例，深入探讨HotSpot虚拟机在Java堆中对象分配、布局和访问的全过程。&lt;br&gt;
    
    </summary>
    
      <category term="Understanding The JVM" scheme="http://yoursite.com/categories/Understanding-The-JVM/"/>
    
    
      <category term="JVM" scheme="http://yoursite.com/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>Java运行时的数据区域</title>
    <link href="http://yoursite.com/2017/11/17/Java%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E5%9F%9F/"/>
    <id>http://yoursite.com/2017/11/17/Java运行时数据区域/</id>
    <published>2017-11-16T19:28:55.000Z</published>
    <updated>2017-11-21T18:27:32.143Z</updated>
    
    <content type="html"><![CDATA[<p>Java虚拟机在执行Java程序的过程会把它管理的内存划分为若干个不同的数据区域。</p><a id="more"></a><p>这些区域有各自的用途，及创建和销毁的时间，有些区域随虚拟机进程的启动而存在，有些区域则是依赖用户线程的启动和结束来建立和销毁。Java虚拟机所管理的内存包括以下几个运行时数据区域，如图1所示。</p><div align="center"><br><img src="/images/JVM/j1.jpg" alt=""><br>图1 java虚拟机运行时数据区</div><h3 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h3><p>程序计数器（Program Counter Resister）是一块较小的内存空间，它可以看作是当前线程所执行的<a href="https://baike.baidu.com/item/%E5%AD%97%E8%8A%82%E7%A0%81/9953683?fr=aladdin" target="_blank" rel="external">字节码</a>的行号指示器。在虚拟机的概念模型里(仅是概念模型，各种虚拟机可能会通过一些更高效的方式去实现)，<strong>字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令</strong>，分支、循环、跳转异常处理、线程恢复等基层功能都需要依赖这个计数器完成。<br>由于Java虚拟机的多线程是通过线程轮流切换并分配处理执行时间的方式来实现的，在任何一个确定的时刻，一个处理器（对于多核处理器说是一个内核）都只执行一条线程中的指令。因此，为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，各条线程之间计数器互不影响，独立存储，我们称这类内存区域为”线程私有”的内存。<br>如果线程正在执行的是一个Java方法，这个计数器记录的是<strong>正在执行的虚拟机字节码指令的地址</strong>；如果正在执行的是Native方法，这个计数器则为空（Undefined）。此内存区域是唯一一个在Java虚拟机规范中没有规定任何OutOfMemoryError情况的区域。</p><h3 id="Java虚拟机栈"><a href="#Java虚拟机栈" class="headerlink" title="Java虚拟机栈"></a>Java虚拟机栈</h3><p>与程序计数器一样，Java虚拟机栈（Java Virtual Machine Stacks）也是线程私有的，它的生命周期与线程相同。虚拟机栈描述的是Java方法执行的内存模型：每个方法在执行的同时都会创建一个栈帧（Stack Frame）<strong>用于存储局部变量表、操作数栈、动态链接、方法出口等信息</strong>。每个方法从调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中入栈到出栈的过程。<br>经常有人把Java内存区分为堆内存（Heap）和栈内存（Stack），这种分法比较粗糙，Java内存区域的划分实际上远比这复杂。这种划分方式的流行只能说明大多程序员最关注的、与对象内存分配关系最密切的内存区域是这两块。其中所指的“堆”将在下面进行专门的讲述，而所指的“栈”就是现在讲的虚拟机栈，或者说是虚拟机栈中局部变量表部分。<br>局部变量表存放了<strong>编译期可知</strong>的各种基本数据类型(boolean、byte、int、short、long、float、double、char)、对象引用（reference类型，它不等同于对象本身，可能是一个指向对象起始地址的引用指针，也可能是指向一个代表对象的<a href="https://baike.baidu.com/item/%E5%8F%A5%E6%9F%84/3527587?fr=aladdin" target="_blank" rel="external">句柄</a>或其他与此对象相关的位置）和returnAddress类型（指向了一条字节码指令的地址）。<br>其中64位长度的long和double类型的数据会占用2个局部变量空间(Slot),其余的数据类型只占用1个。局部变量表所需的内存空间在编译期间完成分配，当进入一个方法时，这个方法需要在帧中分配多个的局部变量空间是完全正确的，在方法运行期间不会改变局部变量表的大小。<br>在Java虚拟机规范中，对这个区域规定了两种异常情况：如果线程请求的栈深读大于虚拟机所允许的深度，将抛出StackOverflowError异常；如果虚拟机栈可以动态扩展（当前大部分的Java虚拟机都可以动态扩展，只不过Java虚拟机规范中也允许固定长度的虚拟机栈），如果扩展时无法申请到足够的内存，就会抛出OutOfMemoryError异常。</p><h3 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h3><p>本地方法栈（Native Method Shack）与虚拟机栈所发挥的作用非常相似的，它们之间的区别不过是虚拟机栈为虚拟机执行Java（也就是字节码）服务，而本地方法栈则为虚拟机使用到的Native方法服务。在虚拟机规范中对本地方法栈中方法使用的语言、使用方式与数据结构并没有强制规定，因此具体的虚拟机可以自由实现它。甚至有的虚拟机（譬如Sun HotSpot虚拟机）直接就把本地方法栈和虚拟机栈合二为一。与虚拟机栈一样，本地方法也可以抛出StackOverflowError和OutOfMemorryError异常。</p><h3 id="Java堆"><a href="#Java堆" class="headerlink" title="Java堆"></a>Java堆</h3><p>对于大多数应用来说，Java堆（Java Heap）是Java虚拟机所管理的内存中最大的一块。Java堆是被所有线程共享的一块内存区域，在虚拟机启动时创建。此<strong>内存区域的唯一目的就是存放对象实例</strong>，几乎所有的对象实例都在这里分配内存。这一点在Java虚拟机规范中的描述是：<strong>所有的对象实例以及数组都要在堆上分配</strong>，但随着JIT编译的发展与逃逸分析技术逐渐成熟，栈上分配、变量替换优化技术将会导致一些微妙的变化，所有的对象都分配在堆上也渐渐变得不是那么“绝对”了。<br><strong>Java堆是垃圾收集器管理的主要区域</strong>，因此很多时候也被称做“GC堆”。从内存回收的角度来看，由于现在收集器基本都<strong>采用分代收集算法</strong>，所以Java堆中还可以细分为：新生代和老年代；再细致一点的有Eden空间、From Survivor空间、To Survivor空间等。从内存分配的角度来看，<strong>线程共享的Java堆中可能划分出多个线程私有的分配缓冲区</strong>。不过无论如何划分，都与存放内容无关，无论哪个区域，存储的都仍然是对象实例，进一步划分的目的是为了更好地回收内存，或者更快的分配内存。<br>根据Java虚拟机规范的规定，<strong>Java堆可以处于物理上不连续的内存空间中</strong>，只要逻辑上是连续的即可，就像我们的磁盘空间一样。在实际时，既可以实现成固定大小的，也可以是可扩展的，不过当前主流的虚拟机都是按照可扩展来实现的（通过-Xmx和-Xms控制）。如果在堆中没有内存完成实例分配，并且堆也无法再扩展时，将会抛出OutOfMemoryError异常。</p><h3 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h3><p><strong>方法区(Method Area)和Java堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器后的代码等数据</strong>。虽然Java虚拟机范围把方法描述为堆的一个逻辑部分，但是它却有一个别名叫做Non-Heap(非堆)，目的应该是与Java堆区分开来。<br>对于习惯在HotSpot虚拟机上开发、部署程序的开发者来说，很多人都更愿意把方法却有称为“永久代”（Permanent Generation），本质上两者并不等价，仅仅是因为HotSpot虚拟机的设计团队选择把GC分代收集扩展到方法区，或者说使用永久代来实现方法区而已，<strong>这样HotSpot的垃圾收集器可以像管理Java堆一样管理这部分内存，能够省去专门为方法区编写内存管理代码的工作</strong>。对于其他虚拟机(如BEA JRockit、IBM J9等)来说是不存在永久代的概念的。原则上，如何实现方法区属于虚拟机实现细节，不受虚拟机规范约束，但使用永久代来实现方法区，现在看来并不是一个好主意，因为这样容易遇到内存溢出问题（永久代有-XX：MaxPermSize的上限，J9和JRockit只要没有触碰到进程可用内存的上限，例如32位系统中的4GB，就不会出现问题），而且有极少数方法(例如String.intern())会因为这个原因导致不同虚拟机下有不同的表现。因此，对于HotSpot虚拟机，根据官方发布的路线图信息，现在也有放弃永久代并逐步改为采用Native Memory来实现方法区的规划了，在目前已经发布的JDK1.7的HotSpot中，已经把原本放在永久代的字符串常量池移出。<br>Java虚拟机规范对方法区的限制非常宽松，除了和Java堆一样不需要连续的内存和可以选择固定大小或者可扩展外，还可以选择不实现垃圾收集。相对而言，垃圾收集行为在这区域是比较少出现的，但并非数据进入方法区就如永久代的名字一样“永久”存在了。这区域的内存回收目标主要是针对常量池的回收和对类型的卸载，一般来说，这个区域的回收确实是必要的。在Sun公司的BUG列表中，曾出现过若干个严重的BUG就是由于低版本的HotSpot虚拟机对此区域未完全回收而导致内存泄漏。<br>根据Java虚拟机规范的规定，当方法区无法满足内存分配需求时，将抛出OutOfMemoryError异常。</p><h3 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h3><p>运行时常量池(Runtime Constant Pool)是方法去的一部分。Class文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是常量池(Constant Pool Table),用于存放编译期生成的各种字面量和符号引用，这部分内容将在类加载后进入方法区的运行时常量池中存放。<br>Java虚拟机对Class文件没一部分（自然也包括常量池）的格式都有严格规定，每一个字节用于存储哪种数据都必须符合规范上的要求才会被虚拟机认可、装载和执行，但对于运行时常量池，Java虚拟机规范没有做任何细节的要求，不同的提供商实现的虚拟机可以按照自己的需要来实现这个内存区域。不过，一般来说，除了保存Class文件中描述的符号引用外，还会把翻译出来的直接引用也存储在运行时常量池中。<br>运行时常量池相对于Class文件常量池的另外一个重要特征是具备动态性，Java语言并不要求常量一定只有编译期才能产生，也就是并非预置入Class文件中常量池的内容才能进入方法区运行时常量池，运行期间也可能将新的常量放入池中，这种特性被开发人员利用得比较多的便是String类的intern()方法。<br>既然运行时常量池是方法区的一部分，自然受到方法区内存的限制，当常量池无法再申请到内存时会抛出OutOfMemoryError异常。</p><h3 id="直接内存"><a href="#直接内存" class="headerlink" title="直接内存"></a>直接内存</h3><p>直接内存(Direct Memory)并不是虚拟机运行时数据区的一部分，也不是Java虚拟机规范中定义的内存区域。但是这部分内存也被频繁地使用，而且也可能导致OutOutMemoryError异常出现，所以我们放到这里一起讲解。<br>在JDK1.4中新加入了NIO(New Input/Output)类，引入了一种基于通道(Channel)与缓冲区(Buffer)的I/O方式，它可以使用Native函数库直接分配堆外内存，然后通过一个存储在Java堆中的DirectByteBuffer对象作为这块内存的引用进行操作。这样能在一些场景中显著提高性能，因为避免了在Java堆和Native堆中来回复制数据。<br>显然，本机直接内存的分配不会受到Java堆大小的限制，但是，既然是内存，肯定还是会受到本机总内存（包括RAM以及SWAP区或者分页文件）大小以及处理器寻找空间的限制。服务器管理员在配置虚拟机参数时，会根据实际内存设置-Xmx等参数信息，但经常忽略直接内存，使得各个内存区域总和大于物理内存限制（包括物理和操作系统级的限制），从而导致动态扩展时出现OutOfMemoryError异常。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Java虚拟机在执行Java程序的过程会把它管理的内存划分为若干个不同的数据区域。&lt;/p&gt;
    
    </summary>
    
      <category term="Understanding The JVM" scheme="http://yoursite.com/categories/Understanding-The-JVM/"/>
    
    
      <category term="JVM" scheme="http://yoursite.com/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>Lock的使用</title>
    <link href="http://yoursite.com/2017/11/16/Lock%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>http://yoursite.com/2017/11/16/Lock的使用/</id>
    <published>2017-11-16T01:41:55.000Z</published>
    <updated>2017-11-21T14:39:20.020Z</updated>
    
    <content type="html"><![CDATA[<p>使用Java5中Lock对象也能实现同步的效果，而且在使用上也更加方便。</p><a id="more"></a><h2 id="使用ReentrantLock类的使用"><a href="#使用ReentrantLock类的使用" class="headerlink" title="使用ReentrantLock类的使用"></a>使用ReentrantLock类的使用</h2><p>在Java多线程中，可以使用synchronized关键字实现线程之间同步互斥，但在JDK1.5中增加了ReentranLock类也能达到同样的效果，并且在扩展功能上也更加强大，比如具有嗅探锁定，多路分支通知等功能，而且在使用上也比synchronized更加的灵活。</p><h4 id="使用ReentranLock实现同步：测试1"><a href="#使用ReentranLock实现同步：测试1" class="headerlink" title="使用ReentranLock实现同步：测试1"></a>使用ReentranLock实现同步：测试1</h4><p>既然ReentranLock类在功能上相比synchronized更多，那么就以一个初步的程序示例来介绍一下ReentranLock类的使用。<br><strong>代码清单1 测试1</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line">public class MyService &#123;</div><div class="line">private Lock lock = new ReentrantLock();</div><div class="line">public void testMethod() &#123;</div><div class="line">lock.lock();</div><div class="line">for (int i = 0; i &lt; 5; i++) &#123;</div><div class="line">System.out.println(&quot;ThreadName=&quot; + Thread.currentThread().getName() + (&quot; &quot; + (i + 1)));</div><div class="line">&#125;</div><div class="line">lock.unlock();</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">public class MyThread extends Thread &#123;</div><div class="line">private MyService service;</div><div class="line"></div><div class="line">public MyThread(MyService service) &#123;</div><div class="line">super();</div><div class="line">this.service = service;</div><div class="line">&#125;</div><div class="line"></div><div class="line">@Override</div><div class="line">public void run() &#123;</div><div class="line">service.testMethod();</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">public class Run &#123;</div><div class="line">public static void main(String[] args) &#123;</div><div class="line">MyService service = new MyService();</div><div class="line">MyThread a1 = new MyThread(service);</div><div class="line">MyThread a2 = new MyThread(service);</div><div class="line">MyThread a3 = new MyThread(service);</div><div class="line">MyThread a4 = new MyThread(service);</div><div class="line">MyThread a5 = new MyThread(service);</div><div class="line">a1.start();</div><div class="line">a2.start();</div><div class="line">a3.start();</div><div class="line">a4.start();</div><div class="line">a5.start();</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>运行结果如图1所示，从运行结果来看，当前线程打印完毕之后将锁将进行释放，其他线程才可以继续打印。线程打印的数据是分组打印，因为当前线程已经持有锁，但线程之间的打印顺序是随机的。</p><div align="center"><br><img src="/images/Thread/re1.jpg" alt=""><br>图1 同步运行</div><h4 id="使用ReentranLock实现同步：测试2"><a href="#使用ReentranLock实现同步：测试2" class="headerlink" title="使用ReentranLock实现同步：测试2"></a>使用ReentranLock实现同步：测试2</h4><p>Lock下lock()持有对象监听作用。<br><strong>代码清单2 测试2</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div></pre></td><td class="code"><pre><div class="line">public class MyService &#123;</div><div class="line"></div><div class="line">private Lock lock = new ReentrantLock();</div><div class="line"></div><div class="line">public void methodA() &#123;</div><div class="line">try &#123;</div><div class="line">lock.lock();</div><div class="line">System.out.println(&quot;methodA begin ThreadName=&quot;</div><div class="line">+ Thread.currentThread().getName() + &quot; time=&quot;</div><div class="line">+ System.currentTimeMillis());</div><div class="line">Thread.sleep(5000);</div><div class="line">System.out.println(&quot;methodA  end ThreadName=&quot;</div><div class="line">+ Thread.currentThread().getName() + &quot; time=&quot;</div><div class="line">+ System.currentTimeMillis());</div><div class="line">&#125; catch (InterruptedException e) &#123;</div><div class="line">e.printStackTrace();</div><div class="line">&#125; finally &#123;</div><div class="line">lock.unlock();</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">public void methodB() &#123;</div><div class="line">try &#123;</div><div class="line">lock.lock();</div><div class="line">System.out.println(&quot;methodB begin ThreadName=&quot;</div><div class="line">+ Thread.currentThread().getName() + &quot; time=&quot;</div><div class="line">+ System.currentTimeMillis());</div><div class="line">Thread.sleep(5000);</div><div class="line">System.out.println(&quot;methodB  end ThreadName=&quot;</div><div class="line">+ Thread.currentThread().getName() + &quot; time=&quot;</div><div class="line">+ System.currentTimeMillis());</div><div class="line">&#125; catch (InterruptedException e) &#123;</div><div class="line">e.printStackTrace();</div><div class="line">&#125; finally &#123;</div><div class="line">lock.unlock();</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">public class ThreadA extends Thread &#123;</div><div class="line"></div><div class="line">private MyService service;</div><div class="line"></div><div class="line">public ThreadA(MyService service) &#123;</div><div class="line">super();</div><div class="line">this.service = service;</div><div class="line">&#125;</div><div class="line"></div><div class="line">@Override</div><div class="line">public void run() &#123;</div><div class="line">service.methodA();</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">public class ThreadAA extends Thread &#123;</div><div class="line"></div><div class="line">private MyService service;</div><div class="line"></div><div class="line">public ThreadAA(MyService service) &#123;</div><div class="line">super();</div><div class="line">this.service = service;</div><div class="line">&#125;</div><div class="line"></div><div class="line">@Override</div><div class="line">public void run() &#123;</div><div class="line">service.methodA();</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">public class ThreadB extends Thread &#123;</div><div class="line"></div><div class="line">private MyService service;</div><div class="line"></div><div class="line">public ThreadB(MyService service) &#123;</div><div class="line">super();</div><div class="line">this.service = service;</div><div class="line">&#125;</div><div class="line"></div><div class="line">@Override</div><div class="line">public void run() &#123;</div><div class="line">service.methodB();</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">public class ThreadBB extends Thread &#123;</div><div class="line"></div><div class="line">private MyService service;</div><div class="line"></div><div class="line">public ThreadBB(MyService service) &#123;</div><div class="line">super();</div><div class="line">this.service = service;</div><div class="line">&#125;</div><div class="line"></div><div class="line">@Override</div><div class="line">public void run() &#123;</div><div class="line">service.methodB();</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">public class Run &#123;</div><div class="line"></div><div class="line">public static void main(String[] args) throws InterruptedException &#123;</div><div class="line">MyService service = new MyService();</div><div class="line">ThreadA a = new ThreadA(service);</div><div class="line">a.setName(&quot;A&quot;);</div><div class="line">a.start();</div><div class="line">ThreadAA aa = new ThreadAA(service);</div><div class="line">aa.setName(&quot;AA&quot;);</div><div class="line">aa.start();</div><div class="line">Thread.sleep(100);</div><div class="line">ThreadB b = new ThreadB(service);</div><div class="line">b.setName(&quot;B&quot;);</div><div class="line">b.start();</div><div class="line">ThreadBB bb = new ThreadBB(service);</div><div class="line">bb.setName(&quot;BB&quot;);</div><div class="line">bb.start();</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>运行结果如图2所示，，调用lock.lock()代码的线程就持有了“对象监视器”，其他线程只有等待锁被释放时再次抢夺。效果和使用synchronized关键字一样，线程之间还是顺序执行的。</p><div align="center"><br><img src="/images/Thread/re2.jpg" alt=""><br>图2 全部同步运行</div><h3 id="使用Condition实现等待-通知：错误用法与解决"><a href="#使用Condition实现等待-通知：错误用法与解决" class="headerlink" title="使用Condition实现等待/通知：错误用法与解决"></a>使用Condition实现等待/通知：错误用法与解决</h3><p>关键字synchronized与wait()和notify()/notifyAll()方法相结合可以实现等待/通知模式，类ReentrantLock也可以实现同样的功能，但需要借助于Condition对象。Condition类是在JDK5中出现的技术，使用它有更好的灵活性，比如可以实现多路通知功能，也就是在一个Lock对象里面可以创建多个Condition(即对象监视器)实例，<strong>线程对象可以注册在指定的Condition中，从而可以有选择性地进行线程通知</strong>，在调度线程上更加灵活。<br>在使用notify()/notifyAll()方法进行通知时，被通知的线程却是由JVM随机选择的。但使用Reentrant Lock结合Condition类是可以实现前面介绍过的“选择性通知”，这个功能是非常重要的，而且在Condition类中是默认提供的。<br>而synchronized就相当于整个Lock对象中只有一个单一的Condition对象，所有的线程都注册在它一个对象的身上。线程开始notifyAll()时，需要通知所有的WAITING线程，没有选择权，会出现相当大的效率问题。<br><strong>代码清单3 condition错误用法</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line">public class MyService &#123;</div><div class="line"></div><div class="line">private Lock lock = new ReentrantLock();</div><div class="line">private Condition condition = lock.newCondition();</div><div class="line"></div><div class="line">public void await() &#123;</div><div class="line">try &#123;</div><div class="line">condition.await();</div><div class="line">&#125; catch (InterruptedException e) &#123;</div><div class="line">// TODO Auto-generated catch block</div><div class="line">e.printStackTrace();</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">public class ThreadA extends Thread &#123;</div><div class="line"></div><div class="line">private MyService service;</div><div class="line"></div><div class="line">public ThreadA(MyService service) &#123;</div><div class="line">super();</div><div class="line">this.service = service;</div><div class="line">&#125;</div><div class="line">@Override</div><div class="line">public void run() &#123;</div><div class="line">service.await();</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">public class Run &#123;</div><div class="line"></div><div class="line">public static void main(String[] args) &#123;</div><div class="line">MyService service=new MyService();</div><div class="line">ThreadA a=new ThreadA(service);</div><div class="line">a.start();</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>运行结果如图3所示，出现异常没有监视对象。</p><div align="center"><br><img src="/images/Thread/re3.jpg" alt=""><br>图3 出现异常（无监视对象）</div><p>报错的异常信息是监视器出错，解决的办法是必须在condition.await()方法调用之前调用lock.lock()代码获得同步监视器。<br><strong>代码清单4 获得同步监听</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line">public class MyService &#123;</div><div class="line"></div><div class="line">private Lock lock = new ReentrantLock();</div><div class="line">private Condition condition = lock.newCondition();</div><div class="line"></div><div class="line">public void await() &#123;</div><div class="line">try &#123;</div><div class="line">lock.lock();</div><div class="line">System.out.println(&quot;A&quot;);</div><div class="line">condition.await();</div><div class="line">System.out.println(&quot;B&quot;);</div><div class="line">&#125; catch (InterruptedException e) &#123;</div><div class="line">// TODO Auto-generated catch block</div><div class="line">e.printStackTrace();</div><div class="line">&#125; finally &#123;</div><div class="line">lock.unlock();</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">public class ThreadA extends Thread &#123;</div><div class="line"></div><div class="line">private MyService myService;</div><div class="line"></div><div class="line">public ThreadA(MyService myService) &#123;</div><div class="line">super();</div><div class="line">this.myService = myService;</div><div class="line">&#125;</div><div class="line"></div><div class="line">@Override</div><div class="line">public void run() &#123;</div><div class="line">myService.await();</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">public class Run &#123;</div><div class="line"></div><div class="line">public static void main(String[] args) throws InterruptedException &#123;</div><div class="line">MyService service=new MyService();</div><div class="line">ThreadA a=new ThreadA(service);</div><div class="line">a.start();</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">`</div></pre></td></tr></table></figure></p><p>运行结果如图4所示，控制台中只打印一个字母A,原因是调用了Condition对象的await()方法，使当前执行任务的线程进入等待WAITING状态。</p><div align="center"><br><img src="/images/Thread/re4.jpg" alt=""><br>图4 只打印字母A</div><h3 id="正确使用Condition实现等待-通知"><a href="#正确使用Condition实现等待-通知" class="headerlink" title="正确使用Condition实现等待/通知"></a>正确使用Condition实现等待/通知</h3><p><strong>代码清单5 实现等待通知</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div></pre></td><td class="code"><pre><div class="line">public class MyService &#123;</div><div class="line"></div><div class="line">private Lock lock = new ReentrantLock();</div><div class="line">private Condition condition = lock.newCondition();</div><div class="line"></div><div class="line">public void await() &#123;</div><div class="line">try &#123;</div><div class="line">lock.lock();</div><div class="line">System.out.println(&quot;await时间为&quot;+System.currentTimeMillis());</div><div class="line">condition.await();</div><div class="line">&#125; catch (InterruptedException e) &#123;</div><div class="line">// TODO Auto-generated catch block</div><div class="line">e.printStackTrace();</div><div class="line">&#125;finally&#123;</div><div class="line">lock.unlock();</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">public void signal()&#123;</div><div class="line">try&#123;</div><div class="line">lock.lock();</div><div class="line">System.out.println(&quot;signal时间为&quot;+System.currentTimeMillis());</div><div class="line">            condition.signal();</div><div class="line">&#125;finally&#123;</div><div class="line">lock.unlock();</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">public class ThreadA extends Thread &#123;</div><div class="line"></div><div class="line">private MyService service;</div><div class="line"></div><div class="line">public ThreadA(MyService service) &#123;</div><div class="line">super();</div><div class="line">this.service = service;</div><div class="line">&#125;</div><div class="line"></div><div class="line">@Override</div><div class="line">public void run() &#123;</div><div class="line">service.await();</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">public class Run &#123;</div><div class="line"></div><div class="line">public static void main(String[] args) throws InterruptedException &#123;</div><div class="line">MyService service=new MyService();</div><div class="line">ThreadA a=new ThreadA(service);</div><div class="line">a.start();</div><div class="line">Thread.sleep(3000);</div><div class="line">    service.signal();</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>程序运行结果如图5所示，成功实现等待/通知模式。</p><div align="center"><br><img src="/images/Thread/re5.jpg" alt=""><br>图5 正常运行</div><p>Object类中的wait()方法相当于Condition类中的await()方法。<br>Object类中的wait(long timeout)方法相当于Condition类中await(long time,TimeUnit unit)方法。<br>Object类中的notify()方法相当于Condition类中的signal()方法。<br>Object类中的notifyAll()方法相当于Condition类中的signalAll()方法。</p><h3 id="使用多个Condition实现通知部分线程：错误用法"><a href="#使用多个Condition实现通知部分线程：错误用法" class="headerlink" title="使用多个Condition实现通知部分线程：错误用法"></a>使用多个Condition实现通知部分线程：错误用法</h3><p>其实Condition对象也可以创建多个。那么一个Condition对象和多个Condition对象在使用上有什么区别呢？<br><strong>代码清单6 错误用法</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div></pre></td><td class="code"><pre><div class="line">public class MyService &#123;</div><div class="line"></div><div class="line">private Lock lock = new ReentrantLock();</div><div class="line">public Condition condition = lock.newCondition();</div><div class="line"></div><div class="line">public void awaitA() &#123;</div><div class="line">try &#123;</div><div class="line">lock.lock();</div><div class="line">System.out.println(&quot;begin awaitA时间为&quot; + System.currentTimeMillis()</div><div class="line">+ &quot; ThreadName=&quot; + Thread.currentThread().getName());</div><div class="line">condition.await();</div><div class="line">System.out.println(&quot;  end awaitA时间为&quot; + System.currentTimeMillis()</div><div class="line">+ &quot; ThreadName=&quot; + Thread.currentThread().getName());</div><div class="line">&#125; catch (InterruptedException e) &#123;</div><div class="line">e.printStackTrace();</div><div class="line">&#125; finally &#123;</div><div class="line">lock.unlock();</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">public void awaitB() &#123;</div><div class="line">try &#123;</div><div class="line">lock.lock();</div><div class="line">System.out.println(&quot;begin awaitB时间为&quot; + System.currentTimeMillis()</div><div class="line">+ &quot; ThreadName=&quot; + Thread.currentThread().getName());</div><div class="line">condition.await();</div><div class="line">System.out.println(&quot;  end awaitB时间为&quot; + System.currentTimeMillis()</div><div class="line">+ &quot; ThreadName=&quot; + Thread.currentThread().getName());</div><div class="line">&#125; catch (InterruptedException e) &#123;</div><div class="line">e.printStackTrace();</div><div class="line">&#125; finally &#123;</div><div class="line">lock.unlock();</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">public void signalAll() &#123;</div><div class="line">try &#123;</div><div class="line">lock.lock();</div><div class="line">System.out.println(&quot;  signalAll时间为&quot; + System.currentTimeMillis()</div><div class="line">+ &quot; ThreadName=&quot; + Thread.currentThread().getName());</div><div class="line">condition.signalAll();</div><div class="line">&#125; finally &#123;</div><div class="line">lock.unlock();</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">public class ThreadA extends Thread &#123;</div><div class="line"></div><div class="line">private MyService service;</div><div class="line"></div><div class="line">public ThreadA(MyService service) &#123;</div><div class="line">super();</div><div class="line">this.service = service;</div><div class="line">&#125;</div><div class="line"></div><div class="line">@Override</div><div class="line">public void run() &#123;</div><div class="line">service.awaitA();</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">public class ThreadB extends Thread &#123;</div><div class="line"></div><div class="line">private MyService service;</div><div class="line"></div><div class="line">public ThreadB(MyService service) &#123;</div><div class="line">super();</div><div class="line">this.service = service;</div><div class="line">&#125;</div><div class="line"></div><div class="line">@Override</div><div class="line">public void run() &#123;</div><div class="line">service.awaitB();</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">public class Run &#123;</div><div class="line"></div><div class="line">public static void main(String[] args) throws InterruptedException &#123;</div><div class="line"></div><div class="line">MyService service = new MyService();</div><div class="line">ThreadA a = new ThreadA(service);</div><div class="line">a.setName(&quot;A&quot;);</div><div class="line">a.start();</div><div class="line">ThreadB b = new ThreadB(service);</div><div class="line">b.setName(&quot;B&quot;);</div><div class="line">b.start();</div><div class="line">Thread.sleep(3000);</div><div class="line">service.signalAll();</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>运行结果如图6所示，A和B线程都被唤醒了。</p><div align="center"><br><img src="/images/Thread/re6.jpg" alt=""><br>图6 线性A和B都被唤醒</div><p>如果想单独唤醒部分线程该怎么处理呢？这时就有必要使用多个Condition对象了，也就是Condition对象可以唤醒部分指定线程，有助于提升程序运行效率。可以先对线程进行分组，然后再唤醒指定组中的线程。</p><h3 id="使用多个Condition实现通知部分线程：正确用法"><a href="#使用多个Condition实现通知部分线程：正确用法" class="headerlink" title="使用多个Condition实现通知部分线程：正确用法"></a>使用多个Condition实现通知部分线程：正确用法</h3><p><strong>代码清单7 正确用法</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div></pre></td><td class="code"><pre><div class="line">public class MyService &#123;</div><div class="line"></div><div class="line">private Lock lock = new ReentrantLock();</div><div class="line">public Condition conditionA = lock.newCondition();</div><div class="line">public Condition conditionB = lock.newCondition();</div><div class="line"></div><div class="line">public void awaitA() &#123;</div><div class="line">try &#123;</div><div class="line">lock.lock();</div><div class="line">System.out.println(&quot;begin awaitA时间为&quot; + System.currentTimeMillis()</div><div class="line">+ &quot; ThreadName=&quot; + Thread.currentThread().getName());</div><div class="line">conditionA.await();</div><div class="line">System.out.println(&quot;  end awaitA时间为&quot; + System.currentTimeMillis()</div><div class="line">+ &quot; ThreadName=&quot; + Thread.currentThread().getName());</div><div class="line">&#125; catch (InterruptedException e) &#123;</div><div class="line">e.printStackTrace();</div><div class="line">&#125; finally &#123;</div><div class="line">lock.unlock();</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">public void awaitB() &#123;</div><div class="line">try &#123;</div><div class="line">lock.lock();</div><div class="line">System.out.println(&quot;begin awaitB时间为&quot; + System.currentTimeMillis()</div><div class="line">+ &quot; ThreadName=&quot; + Thread.currentThread().getName());</div><div class="line">conditionB.await();</div><div class="line">System.out.println(&quot;  end awaitB时间为&quot; + System.currentTimeMillis()</div><div class="line">+ &quot; ThreadName=&quot; + Thread.currentThread().getName());</div><div class="line">&#125; catch (InterruptedException e) &#123;</div><div class="line">e.printStackTrace();</div><div class="line">&#125; finally &#123;</div><div class="line">lock.unlock();</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">public void signalAll_A() &#123;</div><div class="line">try &#123;</div><div class="line">lock.lock();</div><div class="line">System.out.println(&quot;  signalAll_A时间为&quot; + System.currentTimeMillis()</div><div class="line">+ &quot; ThreadName=&quot; + Thread.currentThread().getName());</div><div class="line">conditionA.signalAll();</div><div class="line">&#125; finally &#123;</div><div class="line">lock.unlock();</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">public void signalAll_B() &#123;</div><div class="line">try &#123;</div><div class="line">lock.lock();</div><div class="line">System.out.println(&quot;  signalAll_B时间为&quot; + System.currentTimeMillis()</div><div class="line">+ &quot; ThreadName=&quot; + Thread.currentThread().getName());</div><div class="line">conditionB.signalAll();</div><div class="line">&#125; finally &#123;</div><div class="line">lock.unlock();</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">public class ThreadA extends Thread &#123;</div><div class="line"></div><div class="line">private MyService service;</div><div class="line"></div><div class="line">public ThreadA(MyService service) &#123;</div><div class="line">super();</div><div class="line">this.service = service;</div><div class="line">&#125;</div><div class="line">@Override</div><div class="line">public void run() &#123;</div><div class="line">service.awaitA();</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">public class ThreadB extends Thread &#123;</div><div class="line"></div><div class="line">private MyService service;</div><div class="line"></div><div class="line">public ThreadB(MyService service) &#123;</div><div class="line">super();</div><div class="line">this.service = service;</div><div class="line">&#125;</div><div class="line"></div><div class="line">@Override</div><div class="line">public void run() &#123;</div><div class="line">service.awaitB();</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">public class Run &#123;</div><div class="line">public static void main(String[] args) throws InterruptedException &#123;</div><div class="line">MyService service = new MyService();</div><div class="line">ThreadA a = new ThreadA(service);</div><div class="line">a.setName(&quot;A&quot;);</div><div class="line">a.start();</div><div class="line">ThreadB b = new ThreadB(service);</div><div class="line">b.setName(&quot;B&quot;);</div><div class="line">b.start();</div><div class="line">Thread.sleep(3000);</div><div class="line">service.signalAll_A();</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>运行结果如图7所示，只有线程A被唤醒了。使用ReentrantLock对象可以唤醒指定种类的线程，这是控制部分线程行为的方便方式。</p><div align="center"><br><img src="/images/Thread/re7.jpg" alt=""><br>图7 线程B没被唤醒</div><h3 id="实现生产者-消费者模式：一对一交替打印"><a href="#实现生产者-消费者模式：一对一交替打印" class="headerlink" title="实现生产者/消费者模式：一对一交替打印"></a>实现生产者/消费者模式：一对一交替打印</h3><p><strong>代码清单8 一对一交替打印</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div></pre></td><td class="code"><pre><div class="line">public class MyService &#123;</div><div class="line"></div><div class="line">private ReentrantLock lock = new ReentrantLock();</div><div class="line">private Condition condition = lock.newCondition();</div><div class="line">private boolean hasValue = false;</div><div class="line"></div><div class="line">public void set() &#123;</div><div class="line">try &#123;</div><div class="line">lock.lock();</div><div class="line">while (hasValue == true) &#123;</div><div class="line">condition.await();</div><div class="line">&#125;</div><div class="line">System.out.println(&quot;打印★&quot;);</div><div class="line">hasValue = true;</div><div class="line">condition.signal();</div><div class="line">&#125; catch (InterruptedException e) &#123;</div><div class="line">e.printStackTrace();</div><div class="line">&#125; finally &#123;</div><div class="line">lock.unlock();</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">public void get() &#123;</div><div class="line">try &#123;</div><div class="line">lock.lock();</div><div class="line">while (hasValue == false) &#123;</div><div class="line">condition.await();</div><div class="line">&#125;</div><div class="line">System.out.println(&quot;打印☆&quot;);</div><div class="line">hasValue = false;</div><div class="line">condition.signal();</div><div class="line">&#125; catch (InterruptedException e) &#123;</div><div class="line">e.printStackTrace();</div><div class="line">&#125; finally &#123;</div><div class="line">lock.unlock();</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">public class MyThreadA extends Thread &#123;</div><div class="line"></div><div class="line">private MyService myService;</div><div class="line"></div><div class="line">public MyThreadA(MyService myService) &#123;</div><div class="line">super();</div><div class="line">this.myService = myService;</div><div class="line">&#125;</div><div class="line"></div><div class="line">@Override</div><div class="line">public void run() &#123;</div><div class="line">for (int i = 0; i &lt; Integer.MAX_VALUE; i++) &#123;</div><div class="line">myService.set();</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">public class MyThreadB extends Thread &#123;</div><div class="line"></div><div class="line">private MyService myService;</div><div class="line"></div><div class="line">public MyThreadB(MyService myService) &#123;</div><div class="line">super();</div><div class="line">this.myService = myService;</div><div class="line">&#125;</div><div class="line"></div><div class="line">@Override</div><div class="line">public void run() &#123;</div><div class="line">for (int i = 0; i &lt; Integer.MAX_VALUE; i++) &#123;</div><div class="line">myService.get();</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">public class Run &#123;</div><div class="line"></div><div class="line">public static void main(String[] args) throws InterruptedException &#123;</div><div class="line">MyService myService = new MyService();</div><div class="line"></div><div class="line">MyThreadA a = new MyThreadA(myService);</div><div class="line">a.start();</div><div class="line"></div><div class="line">MyThreadB b = new MyThreadB(myService);</div><div class="line">b.start();</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>运行结果如图8所示，通过使用Condition对象，成功实现交替打印的结果。</p><div align="center"><br><img src="/images/Thread/re8.jpg" alt=""><br>图8 交替打印</div><h3 id="实现生产者-消费者模式：多对多交替打印"><a href="#实现生产者-消费者模式：多对多交替打印" class="headerlink" title="实现生产者/消费者模式：多对多交替打印"></a>实现生产者/消费者模式：多对多交替打印</h3><p><strong>代码清单9 多对多交替打印</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div></pre></td><td class="code"><pre><div class="line">public class MyService &#123;</div><div class="line"></div><div class="line">private ReentrantLock lock = new ReentrantLock();</div><div class="line">private Condition condition = lock.newCondition();</div><div class="line">private boolean hasValue = false;</div><div class="line"></div><div class="line">public void set() &#123;</div><div class="line">try &#123;</div><div class="line">lock.lock();</div><div class="line">while (hasValue == true) &#123;</div><div class="line">System.out.println(&quot;有可能★★连续&quot;);</div><div class="line">condition.await();</div><div class="line">&#125;</div><div class="line">System.out.println(&quot;打印★&quot;);</div><div class="line">hasValue = true;</div><div class="line">condition.signal();</div><div class="line">&#125; catch (InterruptedException e) &#123;</div><div class="line">e.printStackTrace();</div><div class="line">&#125; finally &#123;</div><div class="line">lock.unlock();</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">public void get() &#123;</div><div class="line">try &#123;</div><div class="line">lock.lock();</div><div class="line">while (hasValue == false) &#123;</div><div class="line">System.out.println(&quot;有可能☆☆连续&quot;);</div><div class="line">condition.await();</div><div class="line">&#125;</div><div class="line">System.out.println(&quot;打印☆&quot;);</div><div class="line">hasValue = false;</div><div class="line">condition.signal();</div><div class="line">&#125; catch (InterruptedException e) &#123;</div><div class="line">e.printStackTrace();</div><div class="line">&#125; finally &#123;</div><div class="line">lock.unlock();</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">public class MyThreadA extends Thread &#123;</div><div class="line"></div><div class="line">private MyService myService;</div><div class="line"></div><div class="line">public MyThreadA(MyService myService) &#123;</div><div class="line">super();</div><div class="line">this.myService = myService;</div><div class="line">&#125;</div><div class="line"></div><div class="line">@Override</div><div class="line">public void run() &#123;</div><div class="line">for (int i = 0; i &lt; Integer.MAX_VALUE; i++) &#123;</div><div class="line">myService.set();</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">public class MyThreadB extends Thread &#123;</div><div class="line"></div><div class="line">private MyService myService;</div><div class="line"></div><div class="line">public MyThreadB(MyService myService) &#123;</div><div class="line">super();</div><div class="line">this.myService = myService;</div><div class="line">&#125;</div><div class="line">@Override</div><div class="line">public void run() &#123;</div><div class="line">for (int i = 0; i &lt; Integer.MAX_VALUE; i++) &#123;</div><div class="line">myService.get();</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">public class Run &#123;</div><div class="line"></div><div class="line">public static void main(String[] args) throws InterruptedException &#123;</div><div class="line">MyService service = new MyService();</div><div class="line"></div><div class="line">MyThreadA[] threadA = new MyThreadA[10];</div><div class="line">MyThreadB[] threadB = new MyThreadB[10];</div><div class="line"></div><div class="line">for (int i = 0; i &lt; 10; i++) &#123;</div><div class="line">threadA[i] = new MyThreadA(service);</div><div class="line">threadB[i] = new MyThreadB(service);</div><div class="line">threadA[i].start();</div><div class="line">threadB[i].start();</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>运行结果如图9所示，程序运行后出现假死。可以使用signalAll()方法来解决。将MyService.Java类中两处signal()代码改成signalAll()后，运行结果如图10所示，程序正常运行，不再出现假死状态。</p><div align="center"><br><img src="/images/Thread/re9.jpg" alt=""><br>图9 出现假死</div><div align="center"><br><img src="/images/Thread/re10.jpg" alt=""><br>图10 假死的状态解决了</div><p>“打印★”和“打印☆”是交替输出的，但是“有可能★★连续”和“有可能☆☆连续”却不是交替输出的，有时候出现连续打印的情况。原因是程序中使用一个Condition对象，再结合signalAll()方法来唤醒所有的线程，那么唤醒的线程就有可能是同类，所以就出现连续打印“有可能★★连续”和“有可能☆☆连续”的情况了。</p><h3 id="公平锁与非公平锁"><a href="#公平锁与非公平锁" class="headerlink" title="公平锁与非公平锁"></a>公平锁与非公平锁</h3><p>公平与非公平锁：锁lock分为“公平锁”和“非公平锁”，公平锁表示线程获取锁的顺序是按照线程加锁的顺序来分配的，及先来先得的FIFO先进先出的顺序。而非公平锁就是一种获取锁的抢占机制，是随机获得锁的，和公平锁不一样的就是先来的不一定先得到锁，这个方式可能造成某些线程一直拿不到锁，结果也就是不公平的了。<br><strong>代码清单10 公平锁与非公平锁</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div></pre></td><td class="code"><pre><div class="line">public class Service &#123;</div><div class="line">private ReentrantLock lock;</div><div class="line">public Service(boolean isFair) &#123;</div><div class="line">super();</div><div class="line">lock = new ReentrantLock(isFair);</div><div class="line">&#125;</div><div class="line">public void serviceMethod() &#123;</div><div class="line">try &#123;</div><div class="line">lock.lock();</div><div class="line">System.out.println(&quot;ThreadName=&quot; + Thread.currentThread().getName()</div><div class="line">+ &quot;获得锁定&quot;);</div><div class="line">&#125; finally &#123;</div><div class="line">lock.unlock();</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">public class RunNotFair &#123;</div><div class="line">public static void main(String[] args) throws InterruptedException &#123;</div><div class="line">final Service service = new Service(false);</div><div class="line"></div><div class="line">Runnable runnable = new Runnable() &#123;</div><div class="line">public void run() &#123;</div><div class="line">System.out.println(&quot;★线程&quot; + Thread.currentThread().getName()</div><div class="line">+ &quot;运行了&quot;);</div><div class="line">service.serviceMethod();</div><div class="line">&#125;</div><div class="line">&#125;;</div><div class="line">Thread[] threadArray = new Thread[10];</div><div class="line">for (int i = 0; i &lt; 10; i++) &#123;</div><div class="line">threadArray[i] = new Thread(runnable);</div><div class="line">&#125;</div><div class="line">for (int i = 0; i &lt; 10; i++) &#123;</div><div class="line">threadArray[i].start();</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">public class RunFair &#123;</div><div class="line">public static void main(String[] args) throws InterruptedException &#123;</div><div class="line">final Service service = new Service(true);</div><div class="line">Runnable runnable = new Runnable() &#123;</div><div class="line">public void run() &#123;</div><div class="line">System.out.println(&quot;★线程&quot; + Thread.currentThread().getName()</div><div class="line">+ &quot;运行了&quot;);</div><div class="line">service.serviceMethod();</div><div class="line">service.serviceMethod();</div><div class="line">&#125;</div><div class="line">&#125;;</div><div class="line">Thread[] threadArray = new Thread[10];</div><div class="line">for (int i = 0; i &lt; 10; i++) &#123;</div><div class="line">threadArray[i] = new Thread(runnable);</div><div class="line">&#125;</div><div class="line">for (int i = 0; i &lt; 10; i++) &#123;</div><div class="line">threadArray[i].start();</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>公平锁运行结果如图11所示，打印的结果基本是呈有序的状态，这就是公平锁的特点。</p><div align="center"><br><img src="/images/Thread/re11.jpg" alt=""><br>图11 公平锁</div><p>非公平锁运行结果如图12所示，结果基本都是乱序的，说明先start()启动的线程不代表先获得锁。</p><div align="center"><br><img src="/images/Thread/re12.jpg" alt=""><br>图12 非公平锁</div><h3 id="方法getHoldCount-、getQueueLenght-和getWaitQueueLength-的测试"><a href="#方法getHoldCount-、getQueueLenght-和getWaitQueueLength-的测试" class="headerlink" title="方法getHoldCount()、getQueueLenght()和getWaitQueueLength()的测试"></a>方法getHoldCount()、getQueueLenght()和getWaitQueueLength()的测试</h3><p>1)方法int getHoldCount()的作用是查询当前线程保持此锁定的个数，也就是调用lock()方法的次数。<br><strong>代码清单11 getHoldCount()方法</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">public class Service &#123;</div><div class="line">private ReentrantLock lock = new ReentrantLock();</div><div class="line">public void serviceMethod1() &#123;</div><div class="line">try &#123;</div><div class="line">lock.lock();</div><div class="line">System.out.println(&quot;serviceMethod1 getHoldCount=&quot;</div><div class="line">+ lock.getHoldCount());</div><div class="line">serviceMethod2();</div><div class="line">&#125; finally &#123;</div><div class="line">lock.unlock();</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">public void serviceMethod2() &#123;</div><div class="line">try &#123;</div><div class="line">lock.lock();</div><div class="line">System.out.println(&quot;serviceMethod2 getHoldCount=&quot;</div><div class="line">+ lock.getHoldCount());</div><div class="line">&#125; finally &#123;</div><div class="line">lock.unlock();</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">public class Run &#123;</div><div class="line"></div><div class="line">public static void main(String[] args) &#123;</div><div class="line">Service service = new Service();</div><div class="line">service.serviceMethod1();</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>运行结果如图13所示，分别查询当前线程保持此锁定的个数。</p><div align="center"><br><img src="/images/Thread/re13.jpg" alt=""><br>图13 运行结果</div><p>2)方法int getQueueLength()的作用是返回正等待获取此锁定的线程估计数，比如有5个线程，一个线程首先执行await()方法，那么在调用getQueueLength()方法后返回值是4，说明有4个线程同时在等待lock的释放。<br><strong>代码清单12 getQueueLength()方法</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line">public class Service &#123;</div><div class="line"></div><div class="line">public ReentrantLock lock = new ReentrantLock();</div><div class="line"></div><div class="line">public void serviceMethod1() &#123;</div><div class="line">try &#123;</div><div class="line">lock.lock();</div><div class="line">System.out.println(&quot;ThreadName=&quot; + Thread.currentThread().getName()</div><div class="line">+ &quot;杩涘叆鏂规硶锛�&quot;);</div><div class="line">Thread.sleep(Integer.MAX_VALUE);</div><div class="line">&#125; catch (InterruptedException e) &#123;</div><div class="line">// TODO Auto-generated catch block</div><div class="line">e.printStackTrace();</div><div class="line">&#125; finally &#123;</div><div class="line">lock.unlock();</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">public class Run &#123;</div><div class="line"></div><div class="line">public static void main(String[] args) throws InterruptedException &#123;</div><div class="line">final Service service = new Service();</div><div class="line">Runnable runnable = new Runnable() &#123;</div><div class="line"></div><div class="line">public void run() &#123;</div><div class="line">service.serviceMethod1();</div><div class="line">&#125;</div><div class="line">&#125;;</div><div class="line">Thread[] threadArray = new Thread[10];</div><div class="line">for (int i = 0; i &lt; 10; i++) &#123;</div><div class="line">threadArray[i] = new Thread(runnable);</div><div class="line">&#125;</div><div class="line">for (int i = 0; i &lt; 10; i++) &#123;</div><div class="line">threadArray[i].start();</div><div class="line">&#125;</div><div class="line">Thread.sleep(2000);</div><div class="line">System.out.println(&quot;有线程数：&quot; + service.lock.getQueueLength() + &quot;在等待获取锁！&quot;);</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>允许结果如图14所示。</p><div align="center"><br><img src="/images/Thread/re14.jpg" alt=""><br>图14 运行结果</div><p>3)方法int getWaitQueueLength(Condition condition)的作用是返回等待此锁定相关的给定条件Condition的线程估计数，比如5个线程，每个线程都执行了同一个condition对象的await()方法，则调用getWaitQueueLength(Condition condition)方法时返回的int值是5。<br><strong>代码清单13 getWaitQueueLength(Condition condition)</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div></pre></td><td class="code"><pre><div class="line">public class Service &#123;</div><div class="line"></div><div class="line">private ReentrantLock lock = new ReentrantLock();</div><div class="line">private Condition newCondition = lock.newCondition();</div><div class="line"></div><div class="line">public void waitMethod() &#123;</div><div class="line">try &#123;</div><div class="line">lock.lock();</div><div class="line">newCondition.await();</div><div class="line">&#125; catch (InterruptedException e) &#123;</div><div class="line">e.printStackTrace();</div><div class="line">&#125; finally &#123;</div><div class="line">lock.unlock();</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">public void notityMethod() &#123;</div><div class="line">try &#123;</div><div class="line">lock.lock();</div><div class="line">System.out.println(&quot;有&quot; + lock.getWaitQueueLength(newCondition)</div><div class="line">+ &quot;个线程正在等待newCondition&quot;);</div><div class="line">newCondition.signal();</div><div class="line">&#125; finally &#123;</div><div class="line">lock.unlock();</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">public class Run &#123;</div><div class="line"></div><div class="line">public static void main(String[] args) throws InterruptedException &#123;</div><div class="line">final Service service = new Service();</div><div class="line"></div><div class="line">Runnable runnable = new Runnable() &#123;</div><div class="line"></div><div class="line">public void run() &#123;</div><div class="line">service.waitMethod();</div><div class="line">&#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">Thread[] threadArray = new Thread[10];</div><div class="line">for (int i = 0; i &lt; 10; i++) &#123;</div><div class="line">threadArray[i] = new Thread(runnable);</div><div class="line">&#125;</div><div class="line">for (int i = 0; i &lt; 10; i++) &#123;</div><div class="line">threadArray[i].start();</div><div class="line">&#125;</div><div class="line">Thread.sleep(2000);</div><div class="line">service.notityMethod();</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>运行结果如图15所示。</p><div align="center"><br><img src="/images/Thread/re15.jpg" alt=""><br>图15 运行结果</div><h3 id="方法hasQueuedThread-、hasQueueThreads-和hasWaiters-的测试"><a href="#方法hasQueuedThread-、hasQueueThreads-和hasWaiters-的测试" class="headerlink" title="方法hasQueuedThread()、hasQueueThreads()和hasWaiters()的测试"></a>方法hasQueuedThread()、hasQueueThreads()和hasWaiters()的测试</h3><p>1）方法boolean hasQueueThread(Thread thread)的作用是查询指定的线程是否正在等待获取此锁定。<br><strong>代码清单14 hasQueuedThread()方法</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line">public class Service &#123;</div><div class="line"></div><div class="line">public ReentrantLock lock = new ReentrantLock();</div><div class="line">public Condition newCondition = lock.newCondition();</div><div class="line"></div><div class="line">public void waitMethod() &#123;</div><div class="line">try &#123;</div><div class="line">lock.lock();</div><div class="line">Thread.sleep(Integer.MAX_VALUE);</div><div class="line">&#125; catch (InterruptedException e) &#123;</div><div class="line">e.printStackTrace();</div><div class="line">&#125; finally &#123;</div><div class="line">lock.unlock();</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">public class Run &#123;</div><div class="line"></div><div class="line">public static void main(String[] args) throws InterruptedException &#123;</div><div class="line">final Service service = new Service();</div><div class="line">Runnable runnable = new Runnable() &#123;</div><div class="line">public void run() &#123;</div><div class="line">service.waitMethod();</div><div class="line">&#125;</div><div class="line">&#125;;</div><div class="line">Thread threadA = new Thread(runnable);</div><div class="line">threadA.start();</div><div class="line">Thread.sleep(500);</div><div class="line">Thread threadB = new Thread(runnable);</div><div class="line">threadB.start();</div><div class="line">Thread.sleep(500);</div><div class="line">System.out.println(service.lock.hasQueuedThread(threadA));</div><div class="line">System.out.println(service.lock.hasQueuedThread(threadB));</div><div class="line">System.out.println(service.lock.hasQueuedThreads());</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>运行结果如图16所示。</p><div align="center"><br><img src="/images/Thread/re16.jpg" alt=""><br>图16 运行结果</div><p>2)方法boolean hasWaiters(Condition condition)的作用是查询是否有线程正在等待与此锁定有关的condition条件。<br><strong>代码清单15 hasWaiters(Condition condition)方法</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div></pre></td><td class="code"><pre><div class="line">public class Service &#123;</div><div class="line"></div><div class="line">private ReentrantLock lock = new ReentrantLock();</div><div class="line">private Condition newCondition = lock.newCondition();</div><div class="line"></div><div class="line">public void waitMethod() &#123;</div><div class="line">try &#123;</div><div class="line">lock.lock();</div><div class="line">newCondition.await();</div><div class="line">&#125; catch (InterruptedException e) &#123;</div><div class="line">e.printStackTrace();</div><div class="line">&#125; finally &#123;</div><div class="line">lock.unlock();</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">public void notityMethod() &#123;</div><div class="line">try &#123;</div><div class="line">lock.lock();</div><div class="line">System.out.println(&quot;有没有线程正在等待newCondition？&quot;</div><div class="line">+ lock.hasWaiters(newCondition) + &quot; 线程数是多少？&quot;</div><div class="line">+ lock.getWaitQueueLength(newCondition));</div><div class="line">newCondition.signal();</div><div class="line">&#125; finally &#123;</div><div class="line">lock.unlock();</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">public class Run &#123;</div><div class="line"></div><div class="line">public static void main(String[] args) throws InterruptedException &#123;</div><div class="line">final Service service = new Service();</div><div class="line"></div><div class="line">Runnable runnable = new Runnable() &#123;</div><div class="line"></div><div class="line">public void run() &#123;</div><div class="line">service.waitMethod();</div><div class="line">&#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">Thread[] threadArray = new Thread[10];</div><div class="line">for (int i = 0; i &lt; 10; i++) &#123;</div><div class="line">threadArray[i] = new Thread(runnable);</div><div class="line">&#125;</div><div class="line">for (int i = 0; i &lt; 10; i++) &#123;</div><div class="line">threadArray[i].start();</div><div class="line">&#125;</div><div class="line">Thread.sleep(2000);</div><div class="line">service.notityMethod();</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>运行结果如图17所示。</p><div align="center"><br><img src="/images/Thread/re17.jpg" alt=""><br>图17 运行结果</div><h3 id="方法isFair-、isHeldByCurrentThread-和isLocked-的测试"><a href="#方法isFair-、isHeldByCurrentThread-和isLocked-的测试" class="headerlink" title="方法isFair()、isHeldByCurrentThread()和isLocked()的测试"></a>方法isFair()、isHeldByCurrentThread()和isLocked()的测试</h3><p>1)方法boolean isFair()的作用是判断是不是公平锁。<br><strong>代码清单16 isFair()方法</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div></pre></td></tr></table></figure></p><p>运行结果如图18所示,在默认情况下，ReentrantLock类使用的是非公平锁。</p><div align="center"><br><img src="/images/Thread/re18.jpg" alt=""><br>图18 运行结果</div><p>2)方法boolean isHeldByCurrentThread()的作用是查询当前线程是否保持此锁定。<br><strong>代码清单17 isHeldByCurrentThread()方法</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div></pre></td></tr></table></figure></p><p>运行结果如图19所示。</p><div align="center"><br><img src="/images/Thread/re19.jpg" alt=""><br>图19 运行结果</div><p>3)方法boolean isLocked()的作用是查询此锁定是否任意线程保持。<br><strong>代码清单18 isLocked()方法</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div></pre></td></tr></table></figure></p><p>运行结果如图20所示。</p><div align="center"><br><img src="/images/Thread/re20.jpg" alt=""><br>图20 运行结果</div><p><a href="https://github.com/5iyxx/JavaMulti-threadProgramming.git" target="_blank" rel="external">Java多线程编程核心技术源代码</a>。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;使用Java5中Lock对象也能实现同步的效果，而且在使用上也更加方便。&lt;/p&gt;
    
    </summary>
    
      <category term="JavaMulti-threadProgramming" scheme="http://yoursite.com/categories/JavaMulti-threadProgramming/"/>
    
    
      <category term="Thread" scheme="http://yoursite.com/tags/Thread/"/>
    
  </entry>
  
  <entry>
    <title>延迟加载(懒汉模式)</title>
    <link href="http://yoursite.com/2017/11/14/%E5%BB%B6%E8%BF%9F%E5%8A%A0%E8%BD%BD(%E6%87%92%E6%B1%89%E6%A8%A1%E5%BC%8F)/"/>
    <id>http://yoursite.com/2017/11/14/延迟加载(懒汉模式)/</id>
    <published>2017-11-14T12:30:55.000Z</published>
    <updated>2017-11-14T16:28:26.817Z</updated>
    
    <content type="html"><![CDATA[<p>什么是延迟加载？延迟加载就是字啊调用get()方法时实例才被创建，常见的实现方法就是在get()方法中进行new实例化。而延迟加载从中文的语境来看，是“缓慢”、“不急迫”的含义，所以也称为“懒汉模式”。</p><a id="more"></a><h3 id="延迟加载-“懒汉模式”解析"><a href="#延迟加载-“懒汉模式”解析" class="headerlink" title="延迟加载/“懒汉模式”解析"></a>延迟加载/“懒汉模式”解析</h3><p>延迟加载/“懒汉模式”解析是在调用方法时实例才被创建。<br><strong>代码清单1 懒汉模式</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">public class MyObject &#123;</div><div class="line">private static MyObject myObject;</div><div class="line"></div><div class="line">private MyObject() &#123;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line">public static MyObject getInstance() &#123;</div><div class="line">// 延迟加载</div><div class="line">if (myObject != null) &#123;</div><div class="line"></div><div class="line">&#125; else &#123;</div><div class="line">myObject = new MyObject();</div><div class="line">&#125;</div><div class="line">return myObject;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">public class MyThread extends Thread &#123;</div><div class="line"></div><div class="line">@Override</div><div class="line">public void run() &#123;</div><div class="line">System.out.println(MyObject.getInstance().hashCode());</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">public class Run &#123;</div><div class="line"></div><div class="line">public static void main(String[] args) &#123;</div><div class="line">MyThread t1 = new MyThread();</div><div class="line">t1.start();</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>运行结果如图1所示，虽然取得一个对象的实例，但如果是在多线程的环境中，就会出现取出多个实例的情况，与单例模式的初衷是相背离的。</p><div align="center"><br><img src="/images/Thread/lh1.jpg" alt=""><br>图1 “饿汉模式”成功取出一个实例</div><h3 id="延迟加载-”懒汉模式“的缺点"><a href="#延迟加载-”懒汉模式“的缺点" class="headerlink" title="延迟加载/”懒汉模式“的缺点"></a>延迟加载/”懒汉模式“的缺点</h3><p>前面的两个测试虽然使用了“<a href="https://5iyxx.github.io/2017/11/14/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E4%B8%8E%E5%A4%9A%E7%BA%BF%E7%A8%8B/" target="_blank" rel="external">立即加载</a>”和“延迟加载”实现了单例设计模式，但在多线程的环境中，前面“延迟加载”示例中的代码完全就是错误的，根本不能实现保存单例的状态。来看一下如何在多线程环境中结合“错误的单例模式”创建出“多例”。<br><strong>代码清单2 “多例”</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line">public class MyObject &#123;</div><div class="line">private static MyObject myObject;</div><div class="line"></div><div class="line">private MyObject() &#123;</div><div class="line"></div><div class="line">&#125;</div><div class="line">public static MyObject getInstance() &#123;</div><div class="line">try &#123;</div><div class="line">if (myObject != null) &#123;</div><div class="line">&#125; else &#123;</div><div class="line">// 模拟在创建对象之前做一些准备性的工作</div><div class="line">Thread.sleep(3000);</div><div class="line">myObject = new MyObject();</div><div class="line">&#125;</div><div class="line">&#125; catch (InterruptedException e) &#123;</div><div class="line">e.printStackTrace();</div><div class="line">&#125;</div><div class="line">return myObject;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">public class MyThread extends Thread &#123;</div><div class="line"></div><div class="line">@Override</div><div class="line">public void run() &#123;</div><div class="line">System.out.println(MyObject.getInstance().hashCode());</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">public class Run &#123;</div><div class="line"></div><div class="line">public static void main(String[] args) &#123;</div><div class="line">MyThread t1 = new MyThread();</div><div class="line">MyThread t2 = new MyThread();</div><div class="line">MyThread t3= new MyThread();</div><div class="line">t1.start();</div><div class="line">t2.start();</div><div class="line">t3.start();</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>运行结果如图2所示，打印出来了3种hasCode，说明创建出了3个对象，并不是单例的，这就是“错误的单例模式”。</p><div align="center"><br><img src="/images/Thread/lh2.jpg" alt=""><br>图2 非单例设计模式</div><h3 id="延迟加载-“懒汉模式”的解决方案"><a href="#延迟加载-“懒汉模式”的解决方案" class="headerlink" title="延迟加载/“懒汉模式”的解决方案"></a>延迟加载/“懒汉模式”的解决方案</h3><h4 id="声明synchronized关键字"><a href="#声明synchronized关键字" class="headerlink" title="声明synchronized关键字"></a>声明synchronized关键字</h4><p>在代码清单2中<code>public static MyObject getInstance()</code>前加上synchronized。运行结果如图3所示。</p><div align="center"><br><img src="/images/Thread/lh3.jpg" alt=""><br>图3 运行结果</div><p>此方法加入同步synchronized关键字得到相同实例的对象，但此方法的运行效率非常低下，是同步运行的，下一个线程想要取得对象，则必须等上一个线程释放锁之后，才可以继续运行。</p><h4 id="尝试同步方法块"><a href="#尝试同步方法块" class="headerlink" title="尝试同步方法块"></a>尝试同步方法块</h4><p>同步方法是对方法的整体进行持锁，这对运行效率来讲是不利的。改成同步代码块能解决吗？<br><strong>代码清单3 代码块</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line">public class MyObject &#123;</div><div class="line">private static MyObject myObject;</div><div class="line"></div><div class="line">private MyObject() &#123;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line">public static MyObject getInstance() &#123;</div><div class="line">try &#123;</div><div class="line">synchronized (MyObject.class) &#123;</div><div class="line">if (myObject != null) &#123;</div><div class="line">&#125; else &#123;</div><div class="line">// 模拟在创建对象之前做一些准备性的工作</div><div class="line">Thread.sleep(3000);</div><div class="line">myObject = new MyObject();</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125; catch (InterruptedException e) &#123;</div><div class="line">e.printStackTrace();</div><div class="line">&#125;</div><div class="line">return myObject;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">public class MyThread extends Thread &#123;</div><div class="line"></div><div class="line">@Override</div><div class="line">public void run() &#123;</div><div class="line">System.out.println(MyObject.getInstance().hashCode());</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">public class Run &#123;</div><div class="line"></div><div class="line">public static void main(String[] args) &#123;</div><div class="line">MyThread t1 = new MyThread();</div><div class="line">MyThread t2 = new MyThread();</div><div class="line">MyThread t3= new MyThread();</div><div class="line">t1.start();</div><div class="line">t2.start();</div><div class="line">t3.start();</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>运行结果如图4所示，此方法加入同步synchronized语句块得带相同实例的对象，但此方法的运行效率也是非常低的，和synchronized同步方法一样是同步运行的。继续更改代码尝试解决这个缺点。</p><div align="center"><br><img src="/images/Thread/lh4.jpg" alt=""><br>图4 运行结果</div><h4 id="针对某些重要的代码进行单独的同步"><a href="#针对某些重要的代码进行单独的同步" class="headerlink" title="针对某些重要的代码进行单独的同步"></a>针对某些重要的代码进行单独的同步</h4><p>同步代码块可以针对某些重要的代码进行单独的同步，而其他的代码则不需要同步。这样在运行时，效率完全可以得到大幅提升，对代码清单4中的代码进行修改。<br><strong>代码清单5 修改MyObject类</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">public class MyObject &#123;</div><div class="line">private static MyObject myObject;</div><div class="line"></div><div class="line">private MyObject() &#123;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line">public static MyObject getInstance() &#123;</div><div class="line">try &#123;</div><div class="line">if (myObject != null) &#123;</div><div class="line">&#125; else &#123;</div><div class="line">// 模拟在创建对象之前做一些准备性的工作</div><div class="line">Thread.sleep(3000);</div><div class="line">                    //使用synchronized (MyObject.class)</div><div class="line">                    //虽然部分代码被上锁</div><div class="line">                    //但还是有非线性安全问题</div><div class="line">synchronized (MyObject.class) &#123;</div><div class="line">myObject = new MyObject();</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125; catch (InterruptedException e) &#123;</div><div class="line">e.printStackTrace();</div><div class="line">&#125;</div><div class="line">return myObject;</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>运行结果如图5所示，此方法使用同步synchronized语句块，只对实例化对象的关键代码进行同步，从语句的结构来讲，运行的效率的确得到了提升。但如果是遇到多线程的情况下还是无法解决得到同一个实例对象的结果。到底如何解决“懒汉模式”遇到多线程的情况呢？</p><div align="center"><br><img src="/images/Thread/lh5.jpg" alt=""><br>图5 运行结果</div><h4 id="使用DCL双检查锁机制"><a href="#使用DCL双检查锁机制" class="headerlink" title="使用DCL双检查锁机制"></a>使用DCL双检查锁机制</h4><p>在最后的步骤中，使用的是DCL双检查锁机制来实现多线程环境中的延迟加载单例设计模式。对代码清单4中的代码进行修改。<br><strong>代码清单6 修改MyObject类</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">public class MyObject &#123;</div><div class="line">private static MyObject myObject;</div><div class="line"></div><div class="line">private MyObject() &#123;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line">public static MyObject getInstance() &#123;</div><div class="line">try &#123;</div><div class="line"></div><div class="line">if (myObject != null) &#123;</div><div class="line">&#125; else &#123;</div><div class="line">// 模拟在创建对象之前做一些准备性的工作</div><div class="line">Thread.sleep(3000);</div><div class="line">synchronized (MyObject.class) &#123;</div><div class="line">if (myObject == null) &#123;</div><div class="line">myObject = new MyObject();</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125; catch (InterruptedException e) &#123;</div><div class="line">e.printStackTrace();</div><div class="line">&#125;</div><div class="line">return myObject;</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>运行结果如图6所示，使用双重检查锁功能，成功地解决了“懒汉模式”遇到多线程的问题。<strong>DCL也是大多数线程结合单例模式使用的解决方案</strong>。</p><div align="center"><br><img src="/images/Thread/lh6.jpg" alt=""><br>图6 运行结果</div><p><a href="https://github.com/5iyxx/JavaMulti-threadProgramming.git" target="_blank" rel="external">Java多线程编程核心技术源代码</a>。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;什么是延迟加载？延迟加载就是字啊调用get()方法时实例才被创建，常见的实现方法就是在get()方法中进行new实例化。而延迟加载从中文的语境来看，是“缓慢”、“不急迫”的含义，所以也称为“懒汉模式”。&lt;/p&gt;
    
    </summary>
    
      <category term="JavaMulti-threadProgramming" scheme="http://yoursite.com/categories/JavaMulti-threadProgramming/"/>
    
    
      <category term="Thread" scheme="http://yoursite.com/tags/Thread/"/>
    
  </entry>
  
  <entry>
    <title>单例模式与多线程</title>
    <link href="http://yoursite.com/2017/11/14/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E4%B8%8E%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    <id>http://yoursite.com/2017/11/14/单例模式与多线程/</id>
    <published>2017-11-14T07:41:55.000Z</published>
    <updated>2017-11-14T10:31:42.428Z</updated>
    
    <content type="html"><![CDATA[<p>如何使单例模式遇到多线程是安全的、正确的。</p><a id="more"></a><h3 id="立即加载-“饿汗模式”"><a href="#立即加载-“饿汗模式”" class="headerlink" title="立即加载/“饿汗模式”"></a>立即加载/“饿汗模式”</h3><p>什么是立即加载？立即加载就是使用类的时候已经将对象创建完毕，常见的实现办法就是直接new实例化。而立即加载从中文的语境来看，有“着急”、”急迫”的含义，所以也称为“饿汉模式”。<br>立即加载/“饿汉模式”是在调用方法前，实例已经被创建了。<br><strong>代码清单1 饿汉模式</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">public class MyObject &#123;</div><div class="line">//立即加载方式==饿汉模式</div><div class="line">private  static MyObject myObject=new MyObject();</div><div class="line">private MyObject()&#123;</div><div class="line"></div><div class="line">&#125;</div><div class="line">public static MyObject getInstance()&#123;</div><div class="line">//此版本代码为立即加载</div><div class="line">//此版本代码的缺点是不能有其他实例变量</div><div class="line">//因为getInstance()方法没有同步</div><div class="line">//所以有可能出现非线性安全问题</div><div class="line">return myObject;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">public class MyThread extends Thread &#123;</div><div class="line"></div><div class="line">@Override</div><div class="line">public void run() &#123;</div><div class="line">System.out.println(MyObject.getInstance().hashCode());</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">public class Run &#123;</div><div class="line"></div><div class="line">public static void main(String[] args) &#123;</div><div class="line">MyThread t1 = new MyThread();</div><div class="line">MyThread t2 = new MyThread();</div><div class="line">MyThread t3= new MyThread();</div><div class="line">t1.start();</div><div class="line">t2.start();</div><div class="line">t3.start();</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>运行结果如图1所示，打印的hashCode是同一个值，说明对象是同一个，也就实现了立即加载型单例设计模式。</p><div align="center"><br><img src="/images/Thread/si1.jpg" alt=""><br>图1 “饿汉模式”的运行结果</div><h3 id="延迟加载-“懒汉模式”"><a href="#延迟加载-“懒汉模式”" class="headerlink" title="延迟加载/“懒汉模式”"></a>延迟加载/“懒汉模式”</h3><p>什么是延迟加载？延迟加载就是字啊调用get()方法时实例才被创建，常见的实现方法就是在get()方法中进行new实例化。而延迟加载从中文的语境来看，是“缓慢”、“不急迫”的含义，所以也称为“懒汉模式”。</p><p><a href="https://github.com/5iyxx/JavaMulti-threadProgramming.git" target="_blank" rel="external">Java多线程编程核心技术源代码</a>。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;如何使单例模式遇到多线程是安全的、正确的。&lt;/p&gt;
    
    </summary>
    
      <category term="JavaMulti-threadProgramming" scheme="http://yoursite.com/categories/JavaMulti-threadProgramming/"/>
    
    
      <category term="Thread" scheme="http://yoursite.com/tags/Thread/"/>
    
  </entry>
  
  <entry>
    <title>定时器Timer</title>
    <link href="http://yoursite.com/2017/11/13/%E5%AE%9A%E6%97%B6%E5%99%A8Timer/"/>
    <id>http://yoursite.com/2017/11/13/定时器Timer/</id>
    <published>2017-11-13T14:50:15.000Z</published>
    <updated>2017-11-14T07:53:14.138Z</updated>
    
    <content type="html"><![CDATA[<p>定时计划任务功能在Java中主要使用的就是Timer对象，它在内部使用多线程的方式进行处理，所以它和其它线程技术上还是有非常大的关联的。</p><a id="more"></a><h3 id="定时器Timer的使用"><a href="#定时器Timer的使用" class="headerlink" title="定时器Timer的使用"></a>定时器Timer的使用</h3><p>在JDK库中Timer类主要负责计划任务的功能，也就是在指定的时间开始执行某一个任务。Timer类的方法列表如图1所示。<br>Timer类的主要作用就是设置计划任务，但封装任务的类却是TimerTask类，类结构如图2所示。执行计划任务的代码要放入TimerTask的子类中，因为因为TimerTask是一个抽象类。</p><div align="center"><br><img src="/images/Thread/ti1.jpg" alt=""><br>图1 类Timer的方法列表</div><div align="center"><br><img src="/images/Thread/ti2.jpg" alt=""><br>图2 类TimerTask类相关的信息</div><h3 id="方法schedule-TimerTask-task，Date-time-的测试"><a href="#方法schedule-TimerTask-task，Date-time-的测试" class="headerlink" title="方法schedule(TimerTask task，Date time)的测试"></a>方法schedule(TimerTask task，Date time)的测试</h3><p>该方法的作用是在指定的日期执行一次某一任务。<br>1 执行任务的时间晚于当前的时间：在未来执行的效果</p><p><strong>代码清单1 在未来执行的效果</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">public class Run1 &#123;</div><div class="line"></div><div class="line">private static Timer timer = new Timer();</div><div class="line"></div><div class="line">static public class MyTask extends TimerTask &#123;</div><div class="line">@Override</div><div class="line">public void run() &#123;</div><div class="line">System.out.println(&quot;运行了！时间为：&quot; + new Date());</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">public static void main(String[] args) &#123;</div><div class="line">try &#123;</div><div class="line">MyTask task = new MyTask();</div><div class="line">SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);</div><div class="line">String dateString = &quot;2017-11-13 23:46:38&quot;;</div><div class="line"></div><div class="line">Date dateRef = sdf.parse(dateString);</div><div class="line">System.out.println(&quot;字符串时间&quot; + dateRef.toLocaleString() + &quot; 当前时间&quot;</div><div class="line">+ new Date().toLocaleString());</div><div class="line">timer.schedule(task, dateRef);</div><div class="line">&#125; catch (ParseException e) &#123;</div><div class="line">e.printStackTrace();</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>程序运行后的结果如图3所示。任务虽然执行完了，但进程还未销毁，为什么会出现这样的情况？</p><div align="center"><br><img src="/images/Thread/ti3.jpg" alt=""><br>图3 运行结果</div><p>在创建Timer对象时，JDK源码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">public Timer()&#123;</div><div class="line">this(&quot;Timer-&quot;+serialNumber());</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>此构造方法调用的是如下构造方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">public Timer(String name)&#123;</div><div class="line">thread.setName(name);</div><div class="line">thread.start();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>查看构造方法可以得知，创建一个Timer就是启动一个新的线程，这个新启动的线程并不是守护线程，它一直在运行。<br>查看构造方法可以得知，创建一个Timer就是启动一个新的线程，这个新启动的线程并不是守护线程，它一直在运行。<br><strong>代码清单2 Timer的守护线程</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">public class Run1TimerIsDaemon &#123;</div><div class="line"></div><div class="line">private static Timer timer = new Timer(true);</div><div class="line"></div><div class="line">static public class MyTask extends TimerTask &#123;</div><div class="line">@Override</div><div class="line">public void run() &#123;</div><div class="line">System.out.println(&quot;运行了！时间为：&quot; + new Date());</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">public static void main(String[] args) &#123;</div><div class="line">try &#123;</div><div class="line">MyTask task = new MyTask();</div><div class="line">SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);</div><div class="line">String dateString = &quot;2017-11-13 22:07:16&quot;;</div><div class="line">//Timer timer=new Timer();</div><div class="line">Date dateRef = sdf.parse(dateString);</div><div class="line">System.out.println(&quot;字符串时间：&quot; + dateRef.toLocaleString() + &quot; 当前时间：&quot; + new Date().toLocaleString());</div><div class="line">timer.schedule(task, dateRef);</div><div class="line">&#125; catch (ParseException e) &#123;</div><div class="line">e.printStackTrace();</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>程序运行后迅速结束当前的进程，并且TimerTask中的任务不再被运行，因为线程已经结束了。</p><div align="center"><br><img src="/images/Thread/ti4.jpg" alt=""><br>图4 守护线程创建成功进程退出</div><p>2 计划时间早于当前时间：提前运行的效果</p><p>如果执行任务的时间早于当前时间，则立即执行task任务。将代码清单2中<code>//Timer timer=new Timer();</code>注释去掉。</p><div align="center"><br><img src="/images/Thread/ti5.jpg" alt=""><br>图5 立即执行task任务</div><p>3 多个TimerTask任务及延时的测试</p><p>Timer中允许有多个TimerTask任务。<br><strong>代码清单3 多个TimerTask任务</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line">public class Run2 &#123;</div><div class="line"></div><div class="line">private static Timer timer = new Timer();</div><div class="line"></div><div class="line">static public class MyTask1 extends TimerTask &#123;</div><div class="line">@Override</div><div class="line">public void run() &#123;</div><div class="line">System.out.println(&quot;运行了！时间为：&quot; + new Date());</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">static public class MyTask2 extends TimerTask &#123;</div><div class="line">@Override</div><div class="line">public void run() &#123;</div><div class="line">System.out.println(&quot;运行了！时间为：&quot; + new Date());</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">public static void main(String[] args) &#123;</div><div class="line">try &#123;</div><div class="line">MyTask1 task1 = new MyTask1();</div><div class="line">MyTask2 task2 = new MyTask2();</div><div class="line"></div><div class="line">SimpleDateFormat sdf1 = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);</div><div class="line">SimpleDateFormat sdf2 = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);</div><div class="line"></div><div class="line">String dateString1 = &quot;2017-11-14 10:21:48&quot;;</div><div class="line">String dateString2 = &quot;2017-11-14 10:21:49&quot;;</div><div class="line"></div><div class="line">Date dateRef1 = sdf1.parse(dateString1);</div><div class="line">Date dateRef2 = sdf2.parse(dateString2);</div><div class="line"></div><div class="line">System.out.println(&quot;字符串1时间&quot; + dateRef1.toLocaleString() + &quot; 当前时间：&quot;</div><div class="line">+ new Date().toLocaleString());</div><div class="line">System.out.println(&quot;字符串2时间&quot; + dateRef2.toLocaleString() + &quot; 当前时间：&quot;</div><div class="line">+ new Date().toLocaleString());</div><div class="line"></div><div class="line">timer.schedule(task1, dateRef1);</div><div class="line">timer.schedule(task2, dateRef2);</div><div class="line">&#125; catch (ParseException e) &#123;</div><div class="line">e.printStackTrace();</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>程序运行结果如图6所示。</p><div align="center"><br><img src="/images/Thread/ti6.jpg" alt=""><br>图6 一个Timer中可以运行多个TimerTask</div><p>TimerTask是以队列的方式一个一个被顺序执行的，所以执行的时间有可能和预期的时间不一致，因为前面的任务有可能消耗的时间较长，则后面的任务运行的时间也会被延迟。<br><strong>代码清单4 任务运行被延迟</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div></pre></td><td class="code"><pre><div class="line">public class Run2Later &#123;</div><div class="line"></div><div class="line">private static Timer timer = new Timer();</div><div class="line"></div><div class="line">static public class MyTask1 extends TimerTask &#123;</div><div class="line">@Override</div><div class="line">public void run() &#123;</div><div class="line">try &#123;</div><div class="line">System.out.println(&quot;1 begin 运行了！时间为：&quot; + new Date());</div><div class="line">Thread.sleep(20000);</div><div class="line">System.out.println(&quot;1   end 运行了！时间为：&quot; + new Date());</div><div class="line">&#125; catch (InterruptedException e) &#123;</div><div class="line">e.printStackTrace();</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">static public class MyTask2 extends TimerTask &#123;</div><div class="line">@Override</div><div class="line">public void run() &#123;</div><div class="line">System.out.println(&quot;2 begin 运行了！时间为：&quot; + new Date());</div><div class="line">System.out.println(&quot;运行了！时间为：&quot; + new Date());</div><div class="line">System.out.println(&quot;2   end 运行了！时间为：&quot; + new Date());</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">public static void main(String[] args) &#123;</div><div class="line">try &#123;</div><div class="line">MyTask1 task1 = new MyTask1();</div><div class="line">MyTask2 task2 = new MyTask2();</div><div class="line"></div><div class="line">SimpleDateFormat sdf1 = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);</div><div class="line">SimpleDateFormat sdf2 = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);</div><div class="line"></div><div class="line">String dateString1 = &quot;2017-11-14 10:30:18&quot;;</div><div class="line">String dateString2 = &quot;2017-11-14 10:30:28&quot;;</div><div class="line"></div><div class="line">Date dateRef1 = sdf1.parse(dateString1);</div><div class="line">Date dateRef2 = sdf2.parse(dateString2);</div><div class="line"></div><div class="line">System.out.println(&quot;字符串1时间：&quot; + dateRef1.toLocaleString() + &quot; 当前时间：&quot;</div><div class="line">+ new Date().toLocaleString());</div><div class="line">System.out.println(&quot;字符串2时间：&quot; + dateRef2.toLocaleString() + &quot; 当前时间：&quot;</div><div class="line">+ new Date().toLocaleString());</div><div class="line"></div><div class="line">timer.schedule(task1, dateRef1);</div><div class="line">timer.schedule(task2, dateRef2);</div><div class="line">&#125; catch (ParseException e) &#123;</div><div class="line">e.printStackTrace();</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>由于task1需要用时20秒执行完成任务，task1开始的时间是2017-11-14 10:30:18，那么将要影响task2的计划任务的时间，task2以此时间为基准，向后延迟20秒，task2在11:33:20执行任务。<strong>因为Task是被放入队列中的，得一个一个顺序运行</strong>。</p><p>程序运行结果如图6所示。</p><div align="center"><br><img src="/images/Thread/ti7.jpg" alt=""><br>图7 任务2的运行时间被延迟了</div><h3 id="方法schedule-TimerTask-task，Date-time，long-period-的测试"><a href="#方法schedule-TimerTask-task，Date-time，long-period-的测试" class="headerlink" title="方法schedule(TimerTask task，Date time，long period)的测试"></a>方法schedule(TimerTask task，Date time，long period)的测试</h3><p>该方法的作用是指在指定日期之后，按指定的间隔周期性地无限循环执行某一任务。<br>1 计划时间晚于当前时间：在未来执行的效果。</p><p><strong>代码清单5 在未来的时间开始循环执行</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">public class Run &#123;</div><div class="line">static public class MyTask extends TimerTask &#123;</div><div class="line">@Override</div><div class="line">public void run() &#123;</div><div class="line">System.out.println(&quot;运行了！时间为：&quot; + new Date());</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">public static void main(String[] args) &#123;</div><div class="line">try &#123;</div><div class="line">MyTask task = new MyTask();</div><div class="line">SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);</div><div class="line">String dateString = &quot;2017-11-14 10:46:11&quot;;</div><div class="line">Timer timer = new Timer();</div><div class="line">Date dateRef = sdf.parse(dateString);</div><div class="line">System.out.println(&quot;字符串时间：&quot; + dateRef.toLocaleString() + &quot; 当前时间：&quot;</div><div class="line">+ new Date().toLocaleString());</div><div class="line">timer.schedule(task, dateRef, 4000);</div><div class="line">&#125; catch (ParseException e) &#123;</div><div class="line">e.printStackTrace();</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>运行结果如图8所示，每隔4秒运行一次TimerTask，并且无限期地重复执行。</p><div align="center"><br><img src="/images/Thread/ti8.jpg" alt=""><br>图8 运行结果</div><p>2 计划时间早于当前时间：提前运行的效果</p><p>如果计划时间早于当前时间，则立即执行task。<br>运行代码清单5中程序，运行结果如图9所示。</p><div align="center"><br><img src="/images/Thread/ti9.jpg" alt=""><br>图9 立即执行task任务</div><p>3 任务执行时间被延迟时</p><p><strong>代码清单6 任务执行时间被延迟</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">public class Run2_1 &#123;</div><div class="line">static public class MyTaskA extends TimerTask &#123;</div><div class="line">@Override</div><div class="line">public void run() &#123;</div><div class="line">try &#123;</div><div class="line">System.out.println(&quot;A运行了！时间为：&quot; + new Date());</div><div class="line">Thread.sleep(5000);</div><div class="line">System.out.println(&quot;A结束了！时间为：&quot; + new Date());</div><div class="line">&#125; catch (InterruptedException e) &#123;</div><div class="line">e.printStackTrace();</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">public static void main(String[] args) &#123;</div><div class="line">try &#123;</div><div class="line">MyTaskA taskA = new MyTaskA();</div><div class="line">SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);</div><div class="line">String dateString = &quot;2015-3-19 14:14:00&quot;;</div><div class="line">Timer timer = new Timer();</div><div class="line">Date dateRef = sdf.parse(dateString);</div><div class="line">System.out.println(&quot;字符串时间：&quot; + dateRef.toLocaleString() + &quot; 当前时间：&quot;</div><div class="line">+ new Date().toLocaleString());</div><div class="line">timer.schedule(taskA, dateRef, 4000);</div><div class="line">&#125; catch (ParseException e) &#123;</div><div class="line">e.printStackTrace();</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>运行结果如图10所示，任务被延时了但还是一个一个顺序运行。</p><div align="center"><br><img src="/images/Thread/ti10.jpg" alt=""><br>图10 运行结果</div><p>4 TimerTask类的cancel()方法</p><p>TimerTask类中的cancel()方法的作用是将自身从任何队列中清楚。<br><strong>代码清单7 TimerTask类的cancel()方法</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">public class Run2 &#123;</div><div class="line">static public class MyTaskA extends TimerTask &#123;</div><div class="line">@Override</div><div class="line">public void run() &#123;</div><div class="line">System.out.println(&quot;A运行了！时间为：&quot; + new Date());</div><div class="line">this.cancel();</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">static public class MyTaskB extends TimerTask &#123;</div><div class="line">@Override</div><div class="line">public void run() &#123;</div><div class="line">System.out.println(&quot;B运行了！时间为：&quot; + new Date());</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">public static void main(String[] args) &#123;</div><div class="line">try &#123;</div><div class="line">MyTaskA taskA = new MyTaskA();</div><div class="line">MyTaskB taskB = new MyTaskB();</div><div class="line">SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);</div><div class="line">String dateString = &quot;2014-10-12 09:12:00&quot;;</div><div class="line">Timer timer = new Timer();</div><div class="line">Date dateRef = sdf.parse(dateString);</div><div class="line">System.out.println(&quot;字符串时间：&quot; + dateRef.toLocaleString() + &quot; 当前时间：&quot;</div><div class="line">+ new Date().toLocaleString());</div><div class="line">timer.schedule(taskA, dateRef, 4000);</div><div class="line">timer.schedule(taskB, dateRef, 4000);</div><div class="line">&#125; catch (ParseException e) &#123;</div><div class="line">e.printStackTrace();</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>TimerTask类的cancel()方法是将自身从任务队列中被移除，其他任务不受影响。</p><div align="center"><br><img src="/images/Thread/ti11.jpg" alt=""><br>图11 TimerTaskA仅运行一次后被清楚了</div><p>5 Timer类的cancel()方法</p><p>和TimerTask类中的cancel()方法清楚自身不同，Timer类中的cancel()方法的作用是将任务队列中的全部任务清空。<br><strong>代码清单8 Timer类的cancel()方法</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line">public class Run3 &#123;</div><div class="line">private static Timer timer = new Timer();</div><div class="line"></div><div class="line">static public class MyTaskA extends TimerTask &#123;</div><div class="line">@Override</div><div class="line">public void run() &#123;</div><div class="line">System.out.println(&quot;A运行了！时间为：&quot; + new Date());</div><div class="line">timer.cancel();</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">static public class MyTaskB extends TimerTask &#123;</div><div class="line">@Override</div><div class="line">public void run() &#123;</div><div class="line">System.out.println(&quot;B运行了！时间为：&quot; + new Date());</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">public static void main(String[] args) &#123;</div><div class="line">try &#123;</div><div class="line">MyTaskA taskA = new MyTaskA();</div><div class="line">MyTaskB taskB = new MyTaskB();</div><div class="line">SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);</div><div class="line">String dateString = &quot;2017-11-14 11:38:23&quot;;</div><div class="line">Date dateRef = sdf.parse(dateString);</div><div class="line">System.out.println(&quot;字符串时间：&quot; + dateRef.toLocaleString() + &quot; 当前时间：&quot;</div><div class="line">+ new Date().toLocaleString());</div><div class="line">timer.schedule(taskA, dateRef, 4000);</div><div class="line">timer.schedule(taskB, dateRef, 4000);</div><div class="line">&#125; catch (ParseException e) &#123;</div><div class="line">e.printStackTrace();</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>运行结果如图12所示，全部任务被清除，并且进程被销毁，按钮有红色变为灰色。</p><div align="center"><br><img src="/images/Thread/ti12.jpg" alt=""><br>图12 进程被清空</div><p>6 Timer的cancel()方法注意事项</p><p>Timer类中的cancel()方法有时并不一定会停止执行计划任务，而是正常执行。<br><strong>代码清单9 cancel不一定能停止执行计划</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">public class Run4 &#123;</div><div class="line">static int i = 0;</div><div class="line"></div><div class="line">static public class MyTask extends TimerTask &#123;</div><div class="line">@Override</div><div class="line">public void run() &#123;</div><div class="line">System.out.println(&quot;正常执行了&quot; + i);</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">public static void main(String[] args) &#123;</div><div class="line">while (true) &#123;</div><div class="line">try &#123;</div><div class="line">i++;</div><div class="line">Timer timer = new Timer();</div><div class="line">MyTask task = new MyTask();</div><div class="line">SimpleDateFormat sdf = new SimpleDateFormat(</div><div class="line">&quot;yyyy-MM-dd HH:mm:ss&quot;);</div><div class="line">String dateString = &quot;2017-11-14 11:54:12&quot;;</div><div class="line"></div><div class="line">Date dateRef = sdf.parse(dateString);</div><div class="line">timer.schedule(task, dateRef);</div><div class="line">timer.cancel();</div><div class="line">&#125; catch (ParseException e) &#123;</div><div class="line">e.printStackTrace();</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>运行结果如图13所示。这是因为Timer类中的cancel()方法有时并没有争抢到queue锁，所以TimerTask 正常运行。</p><div align="center"><br><img src="/images/Thread/ti13.jpg" alt=""><br>图13 并没有停止</div><h3 id="方法schedule-TimerTask-task-long-delay-的测试"><a href="#方法schedule-TimerTask-task-long-delay-的测试" class="headerlink" title="方法schedule(TimerTask task,long delay)的测试"></a>方法schedule(TimerTask task,long delay)的测试</h3><p>该方法的作用是以执行schedule(TimerTask task,long delay)方法当前的时间为参考时间，在此时间基础上延迟指定的毫秒数后执行一次TimerTask任务。<br><strong>代码清单10 延迟执行一次</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">public class Run &#123;</div><div class="line">static public class MyTask extends TimerTask &#123;</div><div class="line">@Override</div><div class="line">public void run() &#123;</div><div class="line">System.out.println(&quot;运行了！时间为：&quot; + new Date());</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">public static void main(String[] args) &#123;</div><div class="line">MyTask task = new MyTask();</div><div class="line">Timer timer = new Timer();</div><div class="line">System.out.println(&quot;当前时间?&quot; + new Date().toLocaleString());</div><div class="line">timer.schedule(task, 7000);</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>任务task被延迟7秒执行，如图14所示。</p><div align="center"><br><img src="/images/Thread/ti14.jpg" alt=""><br>图14 运行结果</div><h3 id="方法schedule-TimerTask-task-long-delay，long-period-的测试"><a href="#方法schedule-TimerTask-task-long-delay，long-period-的测试" class="headerlink" title="方法schedule(TimerTask task,long delay，long period)的测试"></a>方法schedule(TimerTask task,long delay，long period)的测试</h3><p>该方法的作用是以执行schedule(TimerTask task,long delay,long period)方法当前的时间Wie参考时间，在此时间基础上延迟指定的毫秒数，再以某一间隔时间无限次数地执行某一任务。<br><strong>代码清单11  无限循环</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">public class Run &#123;</div><div class="line">static public class MyTask extends TimerTask &#123;</div><div class="line">@Override</div><div class="line">public void run() &#123;</div><div class="line">System.out.println(&quot;运行了！时间为：&quot; + new Date());</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">public static void main(String[] args) &#123;</div><div class="line">MyTask task = new MyTask();</div><div class="line">Timer timer = new Timer();</div><div class="line">System.out.println(&quot;当前时间&quot;+new Date().toLocaleString());</div><div class="line">timer.schedule(task, 3000,5000);</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>凡是使用方法带有period参数的，都是无限循环执行TimerTask中的任务。</p><div align="center"><br><img src="/images/Thread/ti15.jpg" alt=""><br>图15 循环运行</div><h3 id="方法scheduleAtFixedRate-TimerTask-task-Date-firstTime-long-period-的测试"><a href="#方法scheduleAtFixedRate-TimerTask-task-Date-firstTime-long-period-的测试" class="headerlink" title="方法scheduleAtFixedRate(TimerTask task,Date firstTime,long period)的测试"></a>方法scheduleAtFixedRate(TimerTask task,Date firstTime,long period)的测试</h3><p>方法schedule和方法scheduleAtFixedRate都会按顺序执行，所以不要考虑非线程安全的情况。<br>方法schedule和scheduleAtFixedRate主要的区别只在于不延时的情况。<br>使用schedule方法：如果执行任务的时间没有被延迟时，那么下一次任务的执行时间参考的是上一次任务的“开始”时的时间来计算。<br>使用scheduleAtFixedRate方法：如果执行任务的时间没有被延迟时，那么下一次任务的执行时间参考的是上一次任务的“结束”时的时间来计算。<br>延时的情况则没有区别，也就是使用schedule或scheduleAtFixedRate方法都是如果执行任务的时间被延迟时，那么下一次任务的执行时间参考的是上一次任务“结束”时的时间来计算。</p><p>1 测试schedule方法任务不延时</p><p><strong>代码清单12 测试schedule方法任务不延时</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line">public class Run1 &#123;</div><div class="line"></div><div class="line">private static Timer timer = new Timer();</div><div class="line">private static int runCount = 0;</div><div class="line"></div><div class="line">static public class MyTask1 extends TimerTask &#123;</div><div class="line">@Override</div><div class="line">public void run() &#123;</div><div class="line">try &#123;</div><div class="line">System.out.println(&quot;1 begin 运行了！时间为：&quot; + new Date());</div><div class="line">Thread.sleep(1000);</div><div class="line">System.out.println(&quot;1   end 运行了！时间为：&quot; + new Date());</div><div class="line">runCount++;</div><div class="line">if (runCount == 5) &#123;</div><div class="line">timer.cancel();</div><div class="line">&#125;</div><div class="line">&#125; catch (InterruptedException e) &#123;</div><div class="line">e.printStackTrace();</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">public static void main(String[] args) &#123;</div><div class="line">try &#123;</div><div class="line">MyTask1 task1 = new MyTask1();</div><div class="line">SimpleDateFormat sdf1 = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);</div><div class="line">String dateString1 = &quot;2017-11-14 13:43:16&quot;;</div><div class="line">Date dateRef1 = sdf1.parse(dateString1);</div><div class="line">System.out.println(&quot;字符串1时间：&quot; + dateRef1.toLocaleString() + &quot; 当前时间：&quot;</div><div class="line">+ new Date().toLocaleString());</div><div class="line">timer.schedule(task1, dateRef1, 3000);</div><div class="line">&#125; catch (ParseException e) &#123;</div><div class="line">e.printStackTrace();</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>控制台打印的结果证明，在不延时的情况下，如果执行任务的时间没有被延迟时，则下一次执行任务的时间是上一次任务的开始时间加上delay时间。</p><div align="center"><br><img src="/images/Thread/ti16.jpg" alt=""><br>图16 没有延时的运行效果</div><p>2 测试schedule方法任务超时</p><p><strong>代码清单13 schedule方法任务超时</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line">public class Run2 &#123;</div><div class="line"></div><div class="line">private static Timer timer = new Timer();</div><div class="line">private static int runCount = 0;</div><div class="line"></div><div class="line">static public class MyTask1 extends TimerTask &#123;</div><div class="line">@Override</div><div class="line">public void run() &#123;</div><div class="line">try &#123;</div><div class="line">System.out.println(&quot;1 begin 运行了！时间为：&quot; + new Date());</div><div class="line">Thread.sleep(5000);</div><div class="line">System.out.println(&quot;1   end 运行了！时间为：&quot; + new Date());</div><div class="line">runCount++;</div><div class="line">if (runCount == 5) &#123;</div><div class="line">timer.cancel();</div><div class="line">&#125;</div><div class="line">&#125; catch (InterruptedException e) &#123;</div><div class="line">e.printStackTrace();</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">public static void main(String[] args) &#123;</div><div class="line">try &#123;</div><div class="line">MyTask1 task1 = new MyTask1();</div><div class="line">SimpleDateFormat sdf1 = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);</div><div class="line">String dateString1 = &quot;2017-11-14 14:42:10&quot;;</div><div class="line">Date dateRef1 = sdf1.parse(dateString1);</div><div class="line">System.out.println(&quot;字符串1时间：&quot; + dateRef1.toLocaleString() + &quot; 当前时间：&quot;</div><div class="line">+ new Date().toLocaleString());</div><div class="line">timer.schedule(task1, dateRef1, 2000);</div><div class="line">&#125; catch (ParseException e) &#123;</div><div class="line">e.printStackTrace();</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>程序运行结果如图17所示，从控制台打印的结果来看，如果执行任务的时间被延迟时，那么下一次的执行时间以上一次“结束”时的时间为参数来计算。</p><div align="center"><br><img src="/images/Thread/ti17.jpg" alt=""><br>图17 任务延时的效果</div><p>3 测试scheduleAtFixedRate方法任务不延时</p><p><strong>代码清单14 scheduleAtFixedRate方法任务不延时</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line">public class Run3 &#123;</div><div class="line"></div><div class="line">private static Timer timer = new Timer();</div><div class="line">private static int runCount = 0;</div><div class="line"></div><div class="line">static public class MyTask1 extends TimerTask &#123;</div><div class="line">@Override</div><div class="line">public void run() &#123;</div><div class="line">try &#123;</div><div class="line">System.out.println(&quot;1 begin 运行了！时间为：&quot; + new Date());</div><div class="line">Thread.sleep(2000);</div><div class="line">System.out.println(&quot;1   end 运行了！时间为：&quot; + new Date());</div><div class="line">runCount++;</div><div class="line">if (runCount == 5) &#123;</div><div class="line">timer.cancel();</div><div class="line">&#125;</div><div class="line">&#125; catch (InterruptedException e) &#123;</div><div class="line">e.printStackTrace();</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">public static void main(String[] args) &#123;</div><div class="line">try &#123;</div><div class="line">MyTask1 task1 = new MyTask1();</div><div class="line">SimpleDateFormat sdf1 = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);</div><div class="line">String dateString1 = &quot;2017-11-14 14:48:21&quot;;</div><div class="line">Date dateRef1 = sdf1.parse(dateString1);</div><div class="line">System.out.println(&quot;字符串1时间：&quot; + dateRef1.toLocaleString() + &quot; 当前时间：&quot;</div><div class="line">+ new Date().toLocaleString());</div><div class="line">timer.scheduleAtFixedRate(task1, dateRef1, 3000);</div><div class="line">&#125; catch (ParseException e) &#123;</div><div class="line">e.printStackTrace();</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>运行结果如图18所示，控制台打印的结果证明，如果执行任务的时间没有被延迟，则下一次执行任务的时间是上一次任务的开始时间加上delay时间。</p><div align="center"><br><img src="/images/Thread/ti18.jpg" alt=""><br>图18 没有被延时的运行效果</div><p>4 测试scheduleAtFixedRate方法任务超时</p><p><strong>代码清单15 scheduleAtFixedRate方法任务超时</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line">public class Run4 &#123;</div><div class="line"></div><div class="line">private static Timer timer = new Timer();</div><div class="line">private static int runCount = 0;</div><div class="line"></div><div class="line">static public class MyTask1 extends TimerTask &#123;</div><div class="line">@Override</div><div class="line">public void run() &#123;</div><div class="line">try &#123;</div><div class="line">System.out.println(&quot;1 begin 运行了！时间为：&quot; + new Date());</div><div class="line">Thread.sleep(5000);</div><div class="line">System.out.println(&quot;1   end 运行了！时间为：&quot; + new Date());</div><div class="line">runCount++;</div><div class="line">if (runCount == 5) &#123;</div><div class="line">timer.cancel();</div><div class="line">&#125;</div><div class="line">&#125; catch (InterruptedException e) &#123;</div><div class="line">e.printStackTrace();</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">public static void main(String[] args) &#123;</div><div class="line">try &#123;</div><div class="line">MyTask1 task1 = new MyTask1();</div><div class="line">SimpleDateFormat sdf1 = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);</div><div class="line">String dateString1 = &quot;2017-11-14 15:01:06&quot;;</div><div class="line">Date dateRef1 = sdf1.parse(dateString1);</div><div class="line">System.out.println(&quot;字符串1时间：&quot; + dateRef1.toLocaleString() + &quot; 当前时间：&quot;</div><div class="line">+ new Date().toLocaleString());</div><div class="line">timer.scheduleAtFixedRate(task1, dateRef1, 2000);</div><div class="line">&#125; catch (ParseException e) &#123;</div><div class="line">e.printStackTrace();</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>运行结果如图19所示，如果执行任务的时间被延迟，那么下一次任务的执行时间以上一次任务“结束”时的时间为参考来计算。</p><div align="center"><br><img src="/images/Thread/ti19.jpg" alt=""><br>图19 任务延时的运行效果</div><p>5 验证schedule方法不具有追赶执行性</p><p><strong>代码清单16 schedule方法不具有追赶执行性</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">public class Run5 &#123;</div><div class="line"></div><div class="line">private static Timer timer = new Timer();</div><div class="line"></div><div class="line">static public class MyTask1 extends TimerTask &#123;</div><div class="line">@Override</div><div class="line">public void run() &#123;</div><div class="line">System.out.println(&quot;1 begin 运行了！时间为：&quot; + new Date());</div><div class="line">System.out.println(&quot;1   end 运行了！时间为：&quot; + new Date());</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">public static void main(String[] args) &#123;</div><div class="line">try &#123;</div><div class="line">MyTask1 task1 = new MyTask1();</div><div class="line">SimpleDateFormat sdf1 = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);</div><div class="line">String dateString1 = &quot;2017-11-14 15:13:43&quot;;</div><div class="line">Date dateRef1 = sdf1.parse(dateString1);</div><div class="line">System.out.println(&quot;字符串1时间：&quot; + dateRef1.toLocaleString() + &quot; 当前时间：&quot;</div><div class="line">+ new Date().toLocaleString());</div><div class="line">timer.schedule(task1, dateRef1, 5000);</div><div class="line">&#125; catch (ParseException e) &#123;</div><div class="line">e.printStackTrace();</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>运行结果如图20所示，时间“2017-11-14 15:13:43”到“2017-11-14 15:16:06”之间的时间所对应的Task任务被取消了，不执行了。这就是Task不追赶的情况。</p><div align="center"><br><img src="/images/Thread/ti20.jpg" alt=""><br>图20 不追赶的情况</div><p>6 验证scheduleAtFixedRate方法具有追赶执行性<br><strong>代码清单17 scheduleAtFixedRate方法具有追赶执行性</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">public class Run6 &#123;</div><div class="line">private static Timer timer = new Timer();</div><div class="line"></div><div class="line">static public class MyTask1 extends TimerTask &#123;</div><div class="line">@Override</div><div class="line">public void run() &#123;</div><div class="line">System.out.println(&quot;1 begin 运行了！时间为：&quot; + new Date());</div><div class="line">System.out.println(&quot;1   end 运行了！时间为：&quot; + new Date());</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">public static void main(String[] args) &#123;</div><div class="line">try &#123;</div><div class="line">MyTask1 task1 = new MyTask1();</div><div class="line">SimpleDateFormat sdf1 = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);</div><div class="line">String dateString1 = &quot;2017-11-14 15:20:59&quot;;</div><div class="line">Date dateRef1 = sdf1.parse(dateString1);</div><div class="line">System.out.println(&quot;字符串1时间：&quot; + dateRef1.toLocaleString() + &quot; 当前时间：&quot;</div><div class="line">+ new Date().toLocaleString());</div><div class="line">timer.scheduleAtFixedRate(task1, dateRef1, 5000);</div><div class="line">&#125; catch (ParseException e) &#123;</div><div class="line">e.printStackTrace();</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>运行结果如图21所示，两个时间段内所对应的Task被“补充性”执行了，这就是Task任务追赶执行的特性。</p><div align="center"><br><img src="/images/Thread/ti21.jpg" alt=""><br>图21 追赶的情况</div><p><a href="https://github.com/5iyxx/JavaMulti-threadProgramming.git" target="_blank" rel="external">Java多线程编程核心技术源代码</a>。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;定时计划任务功能在Java中主要使用的就是Timer对象，它在内部使用多线程的方式进行处理，所以它和其它线程技术上还是有非常大的关联的。&lt;/p&gt;
    
    </summary>
    
      <category term="JavaMulti-threadProgramming" scheme="http://yoursite.com/categories/JavaMulti-threadProgramming/"/>
    
    
      <category term="Thread" scheme="http://yoursite.com/tags/Thread/"/>
    
  </entry>
  
  <entry>
    <title>线程间通信</title>
    <link href="http://yoursite.com/2017/11/11/%E7%BA%BF%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/"/>
    <id>http://yoursite.com/2017/11/11/线程间通信/</id>
    <published>2017-11-11T07:15:15.000Z</published>
    <updated>2017-11-13T05:47:13.176Z</updated>
    
    <content type="html"><![CDATA[<p>线程是操作系统中独立的个体，但这些个体如果不经过特殊的处理就不能成为一个整体。线程间的通信就是成为整体的必用方案之一，可以说，线程间进行通信后，系统之间的交互性会更强大，在大大提高CPU利用率的同时还会使程序员对各线程在处理的过程中进行有效的把控与监督。<br><a id="more"></a></p><h2 id="等待-通知机制"><a href="#等待-通知机制" class="headerlink" title="等待/通知机制"></a>等待/通知机制</h2><p>线程与线程之间不是独立的个体，它们彼此之间可以相互通信和协作。</p><h3 id="不使用等待-通知机制实现线程间通信"><a href="#不使用等待-通知机制实现线程间通信" class="headerlink" title="不使用等待/通知机制实现线程间通信"></a>不使用等待/通知机制实现线程间通信</h3><p>使用sleep()结合while(true)死循环法来实现多线程间通信。<br><strong>代码清单1 sleep()结合while(true)实现通信</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div></pre></td><td class="code"><pre><div class="line">public class MyList &#123;</div><div class="line"></div><div class="line">private List list = new ArrayList();</div><div class="line"></div><div class="line">public void add() &#123;</div><div class="line">list.add(&quot;高洪岩&quot;);</div><div class="line">&#125;</div><div class="line"></div><div class="line">public int size() &#123;</div><div class="line">return list.size();</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">public class ThreadA extends Thread &#123;</div><div class="line"></div><div class="line">private MyList list;</div><div class="line"></div><div class="line">public ThreadA(MyList list) &#123;</div><div class="line">super();</div><div class="line">this.list = list;</div><div class="line">&#125;</div><div class="line"></div><div class="line">@Override</div><div class="line">public void run() &#123;</div><div class="line">try &#123;</div><div class="line">for (int i = 0; i &lt; 10; i++) &#123;</div><div class="line">list.add();</div><div class="line">System.out.println(&quot;添加了&quot; + (i + 1) + &quot;个元素&quot;);</div><div class="line">Thread.sleep(2000);</div><div class="line">&#125;</div><div class="line">&#125; catch (InterruptedException e) &#123;</div><div class="line">e.printStackTrace();</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">public class ThreadB extends Thread &#123;</div><div class="line"></div><div class="line">private MyList list;</div><div class="line"></div><div class="line">public ThreadB(MyList list) &#123;</div><div class="line">super();</div><div class="line">this.list = list;</div><div class="line">&#125;</div><div class="line"></div><div class="line">@Override</div><div class="line">public void run() &#123;</div><div class="line">try &#123;</div><div class="line">while (true) &#123;</div><div class="line">System.out.println(list.size() );</div><div class="line">if (list.size() ==5) &#123;</div><div class="line">System.out.println(&quot;==5了，线程b要退出了！&quot;);</div><div class="line">throw new InterruptedException();</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125; catch (InterruptedException e) &#123;</div><div class="line">e.printStackTrace();</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">public class Test &#123;</div><div class="line"></div><div class="line">public static void main(String[] args) &#123;</div><div class="line">MyList service = new MyList();</div><div class="line"></div><div class="line">ThreadA a = new ThreadA(service);</div><div class="line">a.setName(&quot;A&quot;);</div><div class="line">a.start();</div><div class="line"></div><div class="line">ThreadB b = new ThreadB(service);</div><div class="line">b.setName(&quot;B&quot;);</div><div class="line">b.start();</div><div class="line"></div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>运行结果如图1所示。虽然两个线程之间实现了通信，但有一个弊端就是，线程ThreadB.java不停地通过while语句轮询机制来检测某一个条件，这样会浪费CPU资源。<br>如果轮询的时间间隔很小，更浪费CPU资源；如果轮询的时间间隔很大，有可能会取不到想要得到的数据。所以就需要有一种机制来实现减少CPU的资源浪费，而且还可以实现多个线程间通信，它就是“wait/notify”机制。</p><div align="center"><br><img src="/images/Thread/wn1.jpg" alt=""><br>图1 两个线程互相通信成功</div><h3 id="什么是等待-通知机制"><a href="#什么是等待-通知机制" class="headerlink" title="什么是等待/通知机制"></a>什么是等待/通知机制</h3><p>对于通过多个线程共同访问同一个变量，可以实现多个线程之间通信，但这种通信机制不是“等待/通知”，两个线程完全会主动式地读取一个共享变量，在花费时间的基础上，读到的值是不是想要的，并不能完全确定。所以现在迫切需要一种“等待/通知”机制来满足的需求。</p><h3 id="等待-通知机制的实现"><a href="#等待-通知机制的实现" class="headerlink" title="等待/通知机制的实现"></a>等待/通知机制的实现</h3><p>方法wait()的作用是使当前执行代码的线程进行等待，wait()方法是Object类的方法，该方法用来将当前线程置入“预执行队列”中，并且在wait()所在的代码行处停止执行，直到接到通知或被中断为止。在调用wait()之前，线程必须或得该对象的对象级别锁，即只能在同步方法或同步块中调用wait()方法。在执行wait()方法后，当前线程释放锁。在从wait()返回前，线程与其它线程竞争重新或得锁。如果调用wait()时没有持有适当的锁，则抛出IllegalMonitorStateException,它是RuntimeException的一个子类，因此，不需要try-catch语句进行辅捉异常。<br>方法notify()也要在同步方法或同步块中调用，即在调用前，线程也必须获得该对象的对象级别锁。如果调用notify()时没有持有适当的锁，也会抛出IllegalMonitorStateException。该方法用来通知那些可能等待该对象的对象锁的其他线程，如果有多个线程等待，则由线程规划器随机挑选其中一个呈wait状体的线程，对其发出通知notify，并使它等待获取该对象的对象锁。需要说明的是，在执行notify()方法后，当前线程不会马上释放该对象锁，呈wait状体的线程也并不能马上获取该对象锁，要等待到执行notify()方法的线程将程序执行完毕，也就是退出synchronized代码块后，当前线程才会释放锁，而呈wait状态所在的线程才可以获取该对象锁。当第一个锁得到该对象锁的wait线程执行完毕以后，它会释放该对象锁，此时如果该对象没有再次使用notify语句，则即便该对象已经空闲，其他wait状态等待的线程才可以获取该对象锁。当第一个获得了该对象的wait线程运行完毕后，它会释放掉该对象锁，此时如果该对象没有再次使用notify语句，则即便该对象已经空闲，其他wait状态等待的线程由于没有得到该对象的通知，还会继续阻塞在wait状态，直到这个对象发出一个notify或notifyAll。<br>用一句话总结一下wait和notify：wait使线程停止运行，而notify使停止的线程继续运行。</p><p><a href="https://github.com/5iyxx/JavaMulti-threadProgramming.git" target="_blank" rel="external">Java多线程编程核心技术源代码</a>。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;线程是操作系统中独立的个体，但这些个体如果不经过特殊的处理就不能成为一个整体。线程间的通信就是成为整体的必用方案之一，可以说，线程间进行通信后，系统之间的交互性会更强大，在大大提高CPU利用率的同时还会使程序员对各线程在处理的过程中进行有效的把控与监督。&lt;br&gt;
    
    </summary>
    
      <category term="JavaMulti-threadProgramming" scheme="http://yoursite.com/categories/JavaMulti-threadProgramming/"/>
    
    
      <category term="Thread" scheme="http://yoursite.com/tags/Thread/"/>
    
  </entry>
  
  <entry>
    <title>Hibernate中@Temporal的使用</title>
    <link href="http://yoursite.com/2017/11/11/Hibernate%E4%B8%AD@Temporal%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>http://yoursite.com/2017/11/11/Hibernate中@Temporal的使用/</id>
    <published>2017-11-11T03:53:00.000Z</published>
    <updated>2017-11-24T01:19:15.520Z</updated>
    
    <content type="html"><![CDATA[<p>  @Temporal标签的作用。<br><a id="more"></a></p><ol><li><p>如果在某类中有Date类型的属性，数据库中存储可能是’yyyy-MM-dd hh:MM:ss’要在查询时获得年月日，在该属性上标注@Temporal(TemporalType.DATE) 会得到形如’yyyy-MM-dd’ 格式的日期。</p></li><li><p>如果在某类中有Date类型的属性，数据库中存储可能是’yyyy-MM-dd hh:MM:ss’要获得时分秒，在该属性上标注 @Temporal(TemporalType.TIME) 会得到形如’HH:MM:SS’ 格式的日期。</p></li><li><p>如果在某类中有Date类型的属性，数据库中存储可能是’yyyy-MM-dd hh:MM:ss’要获得’是’yyyy-MM-dd hh:MM:ss’，在该属性上标注 @Temporal(TemporalType.TIMESTAMP) 会得到形如’HH:MM:SS’ 格式的日期</p></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;  @Temporal标签的作用。&lt;br&gt;
    
    </summary>
    
      <category term="The Basic Of Hibernate" scheme="http://yoursite.com/categories/The-Basic-Of-Hibernate/"/>
    
    
      <category term="Hibernate" scheme="http://yoursite.com/tags/Hibernate/"/>
    
  </entry>
  
  <entry>
    <title>volatile关键字</title>
    <link href="http://yoursite.com/2017/11/11/Volatile%E5%85%B3%E9%94%AE%E5%AD%97/"/>
    <id>http://yoursite.com/2017/11/11/Volatile关键字/</id>
    <published>2017-11-10T19:41:55.000Z</published>
    <updated>2017-11-14T09:32:34.601Z</updated>
    
    <content type="html"><![CDATA[<p>关键字volatile的主要作用是使变量在多个线程间可见。<br><a id="more"></a></p><h3 id="volatile关键字与死循环"><a href="#volatile关键字与死循环" class="headerlink" title="volatile关键字与死循环"></a>volatile关键字与死循环</h3><p>如果不是在多继承的情况下，使用继承Thread类和实现Runnable接口在取得程序运行的结果上并没有什么太大的区别。如果一旦出现“多继承”的情况，则用实现Runnable接口的方式来处理多线程的问题就是很有必要的。</p><p><strong>代码清单1 死循环</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">public class PrintString &#123;</div><div class="line">private boolean isContinuePrint = true;</div><div class="line"></div><div class="line">public boolean isContinuePrint() &#123;</div><div class="line">return isContinuePrint;</div><div class="line">&#125;</div><div class="line"></div><div class="line">public void setContinuePrint(boolean isContinuePrint) &#123;</div><div class="line">this.isContinuePrint = isContinuePrint;</div><div class="line">&#125;</div><div class="line"></div><div class="line">public void printStringMethod() &#123;</div><div class="line">try &#123;</div><div class="line">while (isContinuePrint == true)</div><div class="line">System.out.println(&quot;run printStringMethod threadName=&quot; + Thread.currentThread().getName());</div><div class="line">Thread.sleep(1000);</div><div class="line">&#125; catch (InterruptedException e) &#123;</div><div class="line">// TODO Auto-generated catch block</div><div class="line">e.printStackTrace();</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">public class Run &#123;</div><div class="line"></div><div class="line">public static void main(String[] args) &#123;</div><div class="line">PrintString printStringService=new PrintString();</div><div class="line">printStringService.printStringMethod();</div><div class="line">System.out.println(&quot;我要停止它！ stopThread=&quot;+Thread.currentThread().getName());</div><div class="line">  printStringService.setContinuePrint(false);</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>程序开始运行后，根本停不下来，结果如图1所示。<br>停不下来的原因主要就是main线程一直在处理while()循环，导致程序不能运行后面的代码。</p><div align="center"><br><img src="/images/Thread/vo1.jpg" alt=""><br>图1 停不下来的程序</div><h3 id="解决同步死循环"><a href="#解决同步死循环" class="headerlink" title="解决同步死循环"></a>解决同步死循环</h3><p>采用多线程，解决死循环。<br><strong>代码清单2 解决死循环</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line">public class PrintString implements Runnable&#123;</div><div class="line">private boolean isContinuePrint = true;</div><div class="line"></div><div class="line">public boolean isContinuePrint() &#123;</div><div class="line">return isContinuePrint;</div><div class="line">&#125;</div><div class="line"></div><div class="line">public void setContinuePrint(boolean isContinuePrint) &#123;</div><div class="line">this.isContinuePrint = isContinuePrint;</div><div class="line">&#125;</div><div class="line"></div><div class="line">public void printStringMethod() &#123;</div><div class="line">try &#123;</div><div class="line">while (isContinuePrint == true)</div><div class="line">System.out.println(&quot;run printStringMethod threadName=&quot; + Thread.currentThread().getName());</div><div class="line">Thread.sleep(1000);</div><div class="line">&#125; catch (InterruptedException e) &#123;</div><div class="line">// TODO Auto-generated catch block</div><div class="line">e.printStackTrace();</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">public void run() &#123;</div><div class="line">printStringMethod();</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">public class Run &#123;</div><div class="line"></div><div class="line">public static void main(String[] args) &#123;</div><div class="line">PrintString printStringService=new PrintString();</div><div class="line">new Thread(printStringService).start();</div><div class="line">System.out.println(&quot;我要停止它！ stopThread=&quot;+Thread.currentThread().getName());</div><div class="line">  printStringService.setContinuePrint(false);</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">`</div></pre></td></tr></table></figure></p><p>运行结果如图2，但当上面的代码运行在-server服务器模式中64bit的JVM时，会出现死循环。解决的办法是使用volatile关键字。<br>关键字volatile的作用是强制从公共堆栈中取得变量的值，而不是从线程私有数据栈中取得变量的值。</p><div align="center"><br><img src="/images/Thread/vo1.jpg" alt=""><br>图2 程序被停止了</div><h3 id="解决异步死循环"><a href="#解决异步死循环" class="headerlink" title="解决异步死循环"></a>解决异步死循环</h3><p>在探讨volatile之前先做一个测试。<br><strong>代码清单3 JVM设置为 -Server</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line">public class RunThread extends Thread&#123;</div><div class="line">    //volatile private boolean isRunning = true;</div><div class="line">private boolean isRunning = true;</div><div class="line"></div><div class="line">public boolean isRunning() &#123;</div><div class="line">return isRunning;</div><div class="line">&#125;</div><div class="line"></div><div class="line">public void setRunning(boolean isRunning) &#123;</div><div class="line">this.isRunning = isRunning;</div><div class="line">&#125;</div><div class="line"></div><div class="line">@Override</div><div class="line">public void run() &#123;</div><div class="line">   System.out.println(&quot;进入run了&quot;);</div><div class="line">while (isRunning==true)&#123;</div><div class="line">   </div><div class="line">   &#125;</div><div class="line">   System.out.println(&quot;线程被停止了！&quot;);</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">public class Run &#123;</div><div class="line"></div><div class="line">public static void main(String[] args) &#123;</div><div class="line">try &#123;</div><div class="line">RunThread thread = new RunThread();</div><div class="line">thread.start();</div><div class="line">Thread.sleep(1000);</div><div class="line">thread.setRunning(false);</div><div class="line">System.out.println(&quot;已经赋值为false&quot;);</div><div class="line">&#125; catch (InterruptedException e) &#123;</div><div class="line">e.printStackTrace();</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>在win10结合JDK64bit的环境中，使用Eclipse开发环境运行后的结果如图3所示。</p><div align="center"><br><img src="/images/Thread/vo3.jpg" alt=""><br>图3 打印结果</div><p>但是如果使用同样的代码，让他们运行在JVM设置为Server服务器的环境中，设置如图4所示。</p><div align="center"><br><img src="/images/Thread/vo4.jpg" alt=""><br>图4 配置JVM为-server模式</div><p>运行结果如图5所示，代码<code>System.out.println(&quot;线程被停止了！&quot;);</code> 从未被执行。</p><div align="center"><br><img src="/images/Thread/vo5.jpg" alt=""><br>图5 出现了死循环</div><p>是什么样的原因造成将JVM设置为-server使出现死循环呢？在启动RunThread.java线程时，变量<code>private boolean isRunning = true;</code>存在于公共堆栈及线程的私有堆栈中。在JVM被设置为-server模式时为了线程运行的效率，线程一直在私有堆栈中取得isRunning的值为true。而代码<code>thread.setRunning(false);</code>虽然被执行，更新的却是公共堆栈中的isRunning变量值false，所以一直就是死循环的状态。内存结果如图6所示。</p><div align="center"><br><img src="/images/Thread/vo6.jpg" alt=""><br>图6 线程的私有堆栈</div><p>这个问题其实就是私有堆栈中的值和公共堆栈中的值不同步造成的。解决这样的问题就要使用volatile关键字，它主要的作用就是当线程访问isRunning这个变量时，强制性从公共堆栈中进行取值。<br>在代码清单3中，定义变量isRunning前加上volatile，运行结果如图7.</p><div align="center"><br><img src="/images/Thread/vo7.jpg" alt=""><br>图7 在-server服务器模式不再出现死循环</div><p>通过使用volatile关键字，强制的从公共内存中读取变量的值，内存结构如图8所示。</p><div align="center"><br><img src="/images/Thread/vo8.jpg" alt=""><br>图8 读取公共内存</div><p>使用volatile关键字增加了实例变量在多个线程之间的可见性。但volatile关键字最致命的缺点是不支持原子性。<br>下面将关键字synchronized和volatile进行一下比较：</p><ol><li>关键字volatile是线程同步的轻量级实现，所以volatile性能肯定比synchronized要好，并且volatile只能修饰变量，而synchronized可以修饰方法，以及代码块。随着JDK新版本的发布，synchronized关键字在执行效率上得到了很大提升，在开发中使用synchronized关键字的比率还是比较大。</li><li>多线程访问volatile不会发生阻塞，而synchronized会出现阻塞。</li><li>volatile能保证数据的可见性，但不能保证原子性；而synchronized可以保证原子性，也可以间接保证可见性，因为它会将私有内存和公共内存中的数据做同步。</li><li>再次重申一下，关键字volatile解决的是变量在多个线程之间的可见性；而synchronized关键字解决的是多个线程之间访问资源的同步性。</li></ol><p><strong>线程安全包含原子性和可见性两个方面，Java的同步机制都是围绕这两个方向来确保线程安全的。</strong></p><h3 id="volatile非原子的特性"><a href="#volatile非原子的特性" class="headerlink" title="volatile非原子的特性"></a>volatile非原子的特性</h3><p>关键字volatile虽然增加了实例变量在多个线程之间的可见性，但它却不具备同步性，那么也就不具备原子性。</p><p><a href="https://github.com/5iyxx/JavaMulti-threadProgramming.git" target="_blank" rel="external">Java多线程编程核心技术源代码</a>。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;关键字volatile的主要作用是使变量在多个线程间可见。&lt;br&gt;
    
    </summary>
    
      <category term="JavaMulti-threadProgramming" scheme="http://yoursite.com/categories/JavaMulti-threadProgramming/"/>
    
    
      <category term="Thread" scheme="http://yoursite.com/tags/Thread/"/>
    
  </entry>
  
  <entry>
    <title>POJO与JavaBean的区别</title>
    <link href="http://yoursite.com/2017/10/01/POJO%E4%B8%8EJavaBean%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>http://yoursite.com/2017/10/01/POJO与JavaBean的区别/</id>
    <published>2017-10-01T01:43:50.000Z</published>
    <updated>2017-10-20T02:23:46.253Z</updated>
    
    <content type="html"><![CDATA[<p>POJO往往被称为Data对象，而JavaBean更是一个组件技术。</p><a id="more"></a><p>POJO（Plain Ordinary Java Object）简单的Java对象，实际就是普通JavaBeans，是为了避免和EJB混淆所创造的简称。</p><p>使用POJO名称是为了避免和EJB混淆起来, 而且简称比较直接. 其中有一些属性及其getter、setter方法的类,没有业务逻辑，有时可以作为VO(value -object)或dto(Data Transform Object)来使用.当然,如果你有一个简单的运算属性也是可以的,但不允许有业务方法,也不能携带有connection之类的方法。</p><p>POJO对象有时也被称为Data对象，大量应用于表现现实中的对象。如果项目中使用了Hibernate框架，有一个关联的xml文件，使对象与数据库中的表对应，对象的属性与表中的字段相对应。</p><p>POJO 和JavaBean是我们常见的两个关键字，一般容易混淆，POJO全称是Plain Ordinary Java Object / Pure Old Java Object，中文可以翻译成：普通Java类，具有一部分getter/setter方法的那种类就可以称作POJO，但是JavaBean则比 POJO复杂很多， Java Bean 是可复用的组件，对 Java Bean 并没有严格的规范，理论上讲，任何一个 Java 类都可以是一个 Bean 。但通常情况下，由于 Java Bean 是被容器所创建（如 Tomcat) 的，所以 Java Bean 应具有一个无参的构造器，另外，通常 Java Bean 还要实现 Serializable 接口用于实现 Bean 的持久性。 Java Bean 是不能被跨进程访问的。</p><p>JavaBean是一种组件技术，就好像你做了一个扳子，而这个扳子会在很多地方被拿去用，这个扳子也提供多种功能(你可以拿这个扳子扳、锤、撬等等)，而这个扳子就是一个组件。一般在web应用程序中建立一个数据库的映射对象时，我们只能称它为POJO。POJO(Plain Old Java Object)这个名字用来强调它是一个普通java对象，而不是一个特殊的对象，其主要用来指代那些没有遵从特定的Java对象模型、约定或框架（如EJB）的Java对象。理想地讲，一个POJO是一个不受任何限制的Java对象（除了Java语言规范）。</p><p>POJO是一个简单的普通的Java对象，它不包含业务逻辑或持久逻辑等，但不是JavaBean、EntityBean等，不具有任何特殊角色和不继承或不实现任何其它Java框架的类或接口。</p><p>转载于：<a href="http://www.cnblogs.com/Nickzerui/p/4596956.html" target="_blank" rel="external">http://www.cnblogs.com/Nickzerui/p/4596956.html</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;POJO往往被称为Data对象，而JavaBean更是一个组件技术。&lt;/p&gt;
    
    </summary>
    
      <category term="The Basic Of Java" scheme="http://yoursite.com/categories/The-Basic-Of-Java/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Red Hat 7 安装后环境配置</title>
    <link href="http://yoursite.com/2017/06/22/Red%20Hat%207%20%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"/>
    <id>http://yoursite.com/2017/06/22/Red Hat 7 环境配置/</id>
    <published>2017-06-22T12:04:50.000Z</published>
    <updated>2017-09-29T01:49:19.192Z</updated>
    
    <content type="html"><![CDATA[<p>Red Hat 7 安装后环境配置<br><a id="more"></a></p><h3 id="配置静态的ip地址"><a href="#配置静态的ip地址" class="headerlink" title="配置静态的ip地址"></a>配置静态的ip地址</h3><ul><li>查看系统的使用的网卡<br><code>ifconfig</code> 我本地网卡为eno16777736</li><li>打开配置文件<br><code>vi /etc/sysconfig/network-scripts/ifcfg-eno16777736</code></li><li>静态ip设置，需要根据自己的网络参数修改配置文件<br><code>BOOTPROTO=static</code> 指定地址的获取方式<br><code>IPADDR=192.168.0.225</code> ip地址<br><code>NETMASK=255.255.255.0</code> 子网掩码<br><code>GATEWAY=192.168.0.1</code> 网关</li><li>重启服务<br><code>systemctl  restart network</code></li><li>ping测试<br><code>ping 8.8.8.8</code><br><code>PING 8.8.8.8 (8.8.8.8) 56(84) bytes of data.</code><br><code>64 bytes from 8.8.8.8: icmp_seq=1 ttl=45 time=241 ms</code><br>测试如上结果，成功！</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Red Hat 7 安装后环境配置&lt;br&gt;
    
    </summary>
    
      <category term="Operations" scheme="http://yoursite.com/categories/Operations/"/>
    
    
      <category term="Linux" scheme="http://yoursite.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>在Maven中Tomcat热部署</title>
    <link href="http://yoursite.com/2017/05/11/%E5%9C%A8maven%E4%B8%ADTomcat%E7%83%AD%E9%83%A8%E7%BD%B2/"/>
    <id>http://yoursite.com/2017/05/11/在maven中Tomcat热部署/</id>
    <published>2017-05-11T01:43:50.000Z</published>
    <updated>2017-10-14T02:46:07.787Z</updated>
    
    <content type="html"><![CDATA[<p> 在Maven中Tomcat热部署，下面为一个简单做法流程，一共有三步。<br><a id="more"></a><br>第一步：修改tomcat-users.xml配置文件，配置用户、密码和权限。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;role rolename=&quot;manager-gui&quot; /&gt;</div><div class="line">&lt;role rolename=&quot;manager-script&quot; /&gt;</div><div class="line">&lt;user username=&quot;tomcat&quot; password=&quot;tomcat&quot; roles=&quot;manager-gui, manager-script&quot;/&gt;</div></pre></td></tr></table></figure></p><p>启动tomcat后，可以进入后台,如图1.</p><div align="center"><br><img src="/images/Operations/t1.jpg" alt=""><br>图1 后台页面</div><p>第二步：修改ip访问权限<br>对于IP访问权限在设置在/tomcat/webapps/manager/META-INF/context.xml中。<br>早期版本Tomcat默认是没有限制的，如图2所示。</p><div align="center"><br><img src="/images/Operations/t4.jpg" alt=""><br>图2 早期IP限制默认配置</div><p>现在Tomcat对于默认是对IP进行限制的，如果不需要进行限制可以模仿早期Tomcat默认配置，去掉IP限制，<br>默认如图3所示。</p><div align="center"><br><img src="/images/Operations/t5.jpg" alt=""><br>图3 现在IP限制默认配置</div><p>第三步：在pom文件中配置tomcat插件。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">&lt;!-- 配置Tomcat插件 --&gt;</div><div class="line">&lt;plugin&gt;</div><div class="line">&lt;groupId&gt;org.apache.tomcat.maven&lt;/groupId&gt;</div><div class="line">&lt;artifactId&gt;tomcat7-maven-plugin&lt;/artifactId&gt;</div><div class="line">&lt;version&gt;2.2&lt;/version&gt;</div><div class="line">&lt;configuration&gt;</div><div class="line">&lt;port&gt;8080&lt;/port&gt;</div><div class="line">&lt;path&gt;/&lt;/path&gt;</div><div class="line">&lt;url&gt;http://119.29.160.64/manager/text&lt;/url&gt;</div><div class="line">&lt;username&gt;tomcat&lt;/username&gt;</div><div class="line">&lt;password&gt;tomcat20170928&lt;/password&gt;</div><div class="line">&lt;/configuration&gt;</div><div class="line">&lt;/plugin&gt;</div></pre></td></tr></table></figure></p><p>第四步：部署<br>初次部署可以使用 “tomcat7:deploy” 命令<br>如果已经部署过使用 “tomcat7:redeploy” 命令<br>（如果第一次部署到根目录，可以直接用“tomcat7:redeploy”）<br>启动过程如图4、图5.</p><div align="center"><br><img src="/images/Operations/t2.jpg" alt=""><br>图4 Maven build…<br><img src="/images/Operations/t3.jpg" alt=""><br>图5 运行插件</div>]]></content>
    
    <summary type="html">
    
      &lt;p&gt; 在Maven中Tomcat热部署，下面为一个简单做法流程，一共有三步。&lt;br&gt;
    
    </summary>
    
      <category term="Operations" scheme="http://yoursite.com/categories/Operations/"/>
    
    
      <category term="Tomcat" scheme="http://yoursite.com/tags/Tomcat/"/>
    
      <category term="Maven" scheme="http://yoursite.com/tags/Maven/"/>
    
  </entry>
  
  <entry>
    <title>为什么要使用SocketAddress来管理网络地址</title>
    <link href="http://yoursite.com/2017/05/10/%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E4%BD%BF%E7%94%A8SocketAddress%E6%9D%A5%E7%AE%A1%E7%90%86%E7%BD%91%E7%BB%9C%E5%9C%B0%E5%9D%80/"/>
    <id>http://yoursite.com/2017/05/10/为什么要使用SocketAddress来管理网络地址/</id>
    <published>2017-05-10T01:43:50.000Z</published>
    <updated>2017-10-23T03:17:25.622Z</updated>
    
    <content type="html"><![CDATA[<p>在使用Socket来连接服务器时最简单的方式就是直接使用IP和端口，但Socket类中的connect方法并未提供这种方式，而是使用SocketAddress类来向connect方法传递服务器的IP和端口。虽然这种方式从表面上看要麻烦一些，但它会给我们带来另外一个好处，那就是网络地址的重用。<br><a id="more"></a></p><p><strong>所谓网络地址的重用表现在两个方面：</strong></p><ul><li>通过建立一个SocketAddress对象，可以在多次连接同一个服务器时使用这个SocketAddress对象。</li><li>在Socket类中提供了两个方法：getRemoteSocketAddress和getLocalSocketAddress，通过这两个方法可以得到服务器和本机的网络地址。而且所得到的网络地址在相应的Socket对象关闭后任然可以使用。下面是这两个方法的声明：</li><li><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">public SocketAddress getRemoteSocketAddress()</div><div class="line">public SocketAddress getLocalSocketAddress()</div></pre></td></tr></table></figure><p> 不管在使用Socket类连接服务器时是直接使用IP和端口，还是使用SocketAddress，这两个方法都返回SocketAddress形式的网络地址。当Socket对象未连接时这两个方法返回null，但要注意的是只有在Socket对象未连接时这两个方法才返回null，而当已经连接成功的Socket对象关闭后仍可使用这两个方法得到相应的网络地址。<br> 虽然上面曾多次提到SocketAddress，但SocketAddress只是个抽象类，它除了有一个默认的构造方法外，其它的方法都是abstract的，因此，我们必须使用SocketAddress的子类来建立SocketAddress对象。在JDK1.4中J只为我们提供了IP网络地址的实现类：java.net.InetSocketAddress。这个类是从SocketAddress继承的，我们可以通过如下的方法来建立SocketAddress对象。</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">SocketAddress socketAddress = new InetSocketAddress(host, ip);</div></pre></td></tr></table></figure><p>下面的代码演示了如何通过SocketAddress来共享网络地址：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line">package mynet;</div><div class="line"></div><div class="line">import java.net.*;</div><div class="line"></div><div class="line">public class MySocketAddress</div><div class="line">&#123;</div><div class="line">    public static void main(String[] args)</div><div class="line">    &#123;</div><div class="line">        try</div><div class="line">        &#123;</div><div class="line">            Socket socket1 = new Socket(&quot;www.ptpress.com.cn&quot;, 80);</div><div class="line">            SocketAddress socketAddress = socket1.getRemoteSocketAddress();</div><div class="line">            socket1.close();</div><div class="line">            Socket socket2 = new Socket();</div><div class="line">            // socket2.bind(new InetSocketAddress(&quot;192.168.18.252&quot;, 0));</div><div class="line">            socket2.connect(socketAddress);</div><div class="line">            socket2.close();</div><div class="line">            InetSocketAddress inetSocketAddress1 = (InetSocketAddress) socketAddress;</div><div class="line">            System.out.println(&quot;服务器域名:&quot;</div><div class="line">                            + inetSocketAddress1.getAddress().getHostName());</div><div class="line">            System.out.println(&quot;服务器IP:&quot;</div><div class="line">                            + inetSocketAddress1.getAddress().getHostAddress());</div><div class="line">            System.out.println(&quot;服务器端口:&quot; + inetSocketAddress1.getPort());</div><div class="line">            InetSocketAddress inetSocketAddress2 = (InetSocketAddress) socket2</div><div class="line">                            .getLocalSocketAddress();</div><div class="line">            System.out.println(&quot;本地IP:&quot;</div><div class="line">                            + inetSocketAddress2.getAddress().getLocalHost()</div><div class="line">                                            .getHostAddress());</div><div class="line">            System.out.println(&quot;本地端口:&quot; + inetSocketAddress2.getPort());</div><div class="line">        &#125;</div><div class="line">        catch (Exception e)</div><div class="line">        &#123;</div><div class="line">            System.out.println(e.getMessage());</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>输出结果：</p><p>服务器域名:www.ptpress.com.cn<br>服务器IP:219.238.168.74<br>服务器端口:80<br>本地IP:192.168.18.253<br>本地端口:4250</p><p>如果多次运行后，本地端口的值可能在每次都不一样。这是因为在socket2在连接时并未使用bind来绑定本地的端口，而这个本地端口是由系统在1024至65，535中随机选取的，因此，在每次运行程序时这个本地端口不一定相同。</p><p>本文出自 “<a href="http://androidguy.blog.51cto.com/974126/214448" target="_blank" rel="external">李宁的极客世界</a>”博客， <a href="http://androidguy.blog.51cto.com/974126/214448" target="_blank" rel="external">http://androidguy.blog.51cto.com/974126/214448</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在使用Socket来连接服务器时最简单的方式就是直接使用IP和端口，但Socket类中的connect方法并未提供这种方式，而是使用SocketAddress类来向connect方法传递服务器的IP和端口。虽然这种方式从表面上看要麻烦一些，但它会给我们带来另外一个好处，那就是网络地址的重用。&lt;br&gt;
    
    </summary>
    
      <category term="Netty:The Definitive Guide 2th" scheme="http://yoursite.com/categories/Netty-The-Definitive-Guide-2th/"/>
    
    
      <category term="NIO" scheme="http://yoursite.com/tags/NIO/"/>
    
      <category term="Socket" scheme="http://yoursite.com/tags/Socket/"/>
    
  </entry>
  
  <entry>
    <title>JavaBean总结</title>
    <link href="http://yoursite.com/2017/04/01/JavaBean%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2017/04/01/JavaBean总结/</id>
    <published>2017-04-01T01:43:50.000Z</published>
    <updated>2017-10-20T02:05:16.813Z</updated>
    
    <content type="html"><![CDATA[<p>符合一定规范编写的Java类，不是一种技术，而是一种规范。大家针对这种规范，总结了很多开发技巧、工具函数。符合这种规范的类，可以被其它的程序员或者框架使用。</p><a id="more"></a><h4 id="javabean-是什么？"><a href="#javabean-是什么？" class="headerlink" title="javabean 是什么？"></a>javabean 是什么？</h4><p>Bean的中文含义是“豆子”，顾名思义，JavaBean是指一段特殊的Java类，<br>就是有默然构造方法,只有get,set的方法的java类的对象.</p><p>专业点解释是：</p><p>JavaBean定义了一组规则<br>JavaBean就是遵循此规则的平常的Java对象 </p><p>满足这三个条件:<br>1.实现序列化接口<br>2.提供无参数的构造器<br>3.提供getter 和 setter方法访问它的属性.</p><p>简单地说，JavaBean是用Java语言描述的软件组件模型，其实际上是一个类。这些类遵循一个接口格式，以便于使函数命名、底层行为以及继承或实现的行为，可以把类看作标准的JavaBean组件进行构造和应用。<br>JavaBean一般分为可视化组件和非可视化组件两种。可视化组件可以是简单的GUI元素，如按钮或文本框，也可以是复杂的，如报表组件；非可视化组件没有GUI表现形式，用于封装业务逻辑、数据库操作等。其最大的优点在于可以实现代码的可重用性。JavaBean又同时具有以下特性。</p><ul><li>易于维护、使用、编写。</li><li>可实现代码的重用性。</li><li>可移植性强，但仅限于Java工作平台。</li><li>便于传输，不限于本地还是网络。</li><li>可以以其他部件的模式进行工作。</li></ul><p>对于有过其他语言编程经验的读者，可以将其看作类似微软的ActiveX的编程组件。但是区别在于JavaBean是跨平台的，而ActiveX组件则仅局限于Windows系统。总之，JavaBean比较适合于那些需要跨平台的、并具有可视化操作和定制特性的软件组件。</p><p>JavaBean组件与EJB（Enterprise JavaBean，企业级JavaBean）组件完全不同。EJB 是J2EE的核心，是一个用来创建分布式应用、服务器端以及基于Java应用的功能强大的组件模型。JavaBean组件主要用于存储状态信息，而EJB组件可以存储业务逻辑。</p><h4 id="使用JavaBean的原因"><a href="#使用JavaBean的原因" class="headerlink" title="使用JavaBean的原因"></a>使用JavaBean的原因</h4><p>程序中往往有重复使用的段落，JavaBean就是为了能够重复使用而设计的程序段落，而且这些段落并不只服务于某一个程序，而且每个JavaBean都具有特定功能，当需要这个功能的时候就可以调用相应的JavaBean。从这个意义上来讲，JavaBean大大简化了程序的设计过程，也方便了其他程序的重复使用。<br>JavaBean传统应用于可视化领域，如AWT（窗口工具集）下的应用。而现在，JavaBean更多地应用于非可视化领域，同时，JavaBean在服务器端的应用也表现出强大的优势。非可视化的JavaBean可以很好地实现业务逻辑、控制逻辑和显示页面的分离，现在多用于后台处理，使得系统具有更好的健壮性和灵活性。JSP + JavaBean和JSP + JavaBean + Servlet成为当前开发Web应用的主流模式。</p><h4 id="JavaBean的开发"><a href="#JavaBean的开发" class="headerlink" title="JavaBean的开发"></a>JavaBean的开发</h4><p>在程序设计的过程中，JavaBean不是独立的。为了能够更好地封装事务逻辑、数据库操作而便于实现业务逻辑和前台程序的分离，操作的过程往往是先开发需要的JavaBean，再在适当的时候进行调用。但一个完整有效的JavaBean必然会包含一个属性，伴随若干个get/set（只读/只写）函数的变量来设计和运行的。JavaBean作为一个特殊的类，具有自己独有的特性。应该注意以下3个方面。</p><ul><li>JavaBean类必须有一个没有参数的构造函数。</li><li>JavaBean类所有的属性最好定义为私有的。</li><li>JavaBean类中定义函数setXxx() 和getXxx()来对属性进行操作。其中Xxx是首字母大写的私有变量名称。</li></ul><p>转载于：<a href="http://blog.csdn.net/zdwzzu2006/article/details/5151788/" target="_blank" rel="external">http://blog.csdn.net/zdwzzu2006/article/details/5151788/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;符合一定规范编写的Java类，不是一种技术，而是一种规范。大家针对这种规范，总结了很多开发技巧、工具函数。符合这种规范的类，可以被其它的程序员或者框架使用。&lt;/p&gt;
    
    </summary>
    
      <category term="The Basic Of Java" scheme="http://yoursite.com/categories/The-Basic-Of-Java/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Spring中每个jar包的作用</title>
    <link href="http://yoursite.com/2017/03/10/Spring%E4%B8%AD%E6%AF%8F%E4%B8%AAjar%E5%8C%85%E7%9A%84%E4%BD%9C%E7%94%A8/"/>
    <id>http://yoursite.com/2017/03/10/Spring中每个jar包的作用/</id>
    <published>2017-03-10T01:43:50.000Z</published>
    <updated>2017-10-20T02:35:54.588Z</updated>
    
    <content type="html"><![CDATA[<p>一个工程需要很多个关于spring的jar包，下面详细说明每个jar的作用。</p><a id="more"></a><p><strong>spring.jar</strong><br>包含有完整发布模块的单个jar 包。但是不包括mock.jar, aspects.jar, spring-portlet.jar, and spring-hibernate2.jar。</p><p><strong>spring-src.zip就是所有的源代码压缩包。</strong></p><p>除了spring.jar 文件，Spring 还包括有其它21 个独立的jar 包，各自包含着对应的Spring组件，用户可以根据自己的需要来选择组合自己的jar 包，而不必引入整个spring.jar 的所有类文件。</p><h4 id="spring-core-jar"><a href="#spring-core-jar" class="headerlink" title="spring-core.jar"></a>spring-core.jar</h4><p>这个jar 文件包含Spring 框架基本的核心工具类。Spring 其它组件要都要使用到这个包里的类，是其它组件的基本核心，当然你也可以在自己的应用系统中使用这些工具类。<br>外部依赖Commons Logging， (Log4J)。</p><h4 id="spring-beans-jar"><a href="#spring-beans-jar" class="headerlink" title="spring-beans.jar"></a>spring-beans.jar</h4><p>这个jar 文件是所有应用都要用到的，它包含访问配置文件、创建和管理bean 以及进行Inversion of Control / Dependency Injection（IoC/DI）操作相关的所有类。如果应用只需基本的IoC/DI 支持，引入spring-core.jar 及spring-beans.jar 文件就可以了。<br>外部依赖spring-core，(CGLIB)。</p><h4 id="spring-aop-jar"><a href="#spring-aop-jar" class="headerlink" title="spring-aop.jar"></a>spring-aop.jar</h4><p>这个jar 文件包含在应用中使用Spring 的AOP 特性时所需的类和源码级元数据支持。使用基于AOP 的Spring特性，如声明型事务管理（Declarative Transaction Management），也要在应用里包含这个jar包。<br>外部依赖spring-core， (spring-beans，AOP Alliance， CGLIB，Commons Attributes)。</p><h4 id="spring-context-jar"><a href="#spring-context-jar" class="headerlink" title="spring-context.jar"></a>spring-context.jar</h4><p>这个jar 文件为Spring 核心提供了大量扩展。可以找到使用Spring ApplicationContext特性时所需的全部类，JDNI 所需的全部类，instrumentation组件以及校验Validation 方面的相关类。<br>外部依赖spring-beans, (spring-aop)。</p><h4 id="spring-dao-jar"><a href="#spring-dao-jar" class="headerlink" title="spring-dao.jar"></a>spring-dao.jar</h4><p>这个jar 文件包含Spring DAO、Spring Transaction 进行数据访问的所有类。为了使用声明型事务支持，还需在自己的应用里包含spring-aop.jar。<br>外部依赖spring-core，(spring-aop， spring-context， JTA API)。</p><h4 id="spring-jdbc-jar"><a href="#spring-jdbc-jar" class="headerlink" title="spring-jdbc.jar"></a>spring-jdbc.jar</h4><p>这个jar 文件包含对Spring 对JDBC 数据访问进行封装的所有类。<br>外部依赖spring-beans，spring-dao。</p><h4 id="spring-support-jar"><a href="#spring-support-jar" class="headerlink" title="spring-support.jar"></a>spring-support.jar</h4><p>这个jar 文件包含支持UI模版（Velocity，FreeMarker，JasperReports），邮件服务，脚本服务(JRuby)，缓存Cache（EHCache），任务计划Scheduling（uartz）方面的类。<br>外部依赖spring-context, (spring-jdbc, Velocity, FreeMarker, JasperReports, BSH, Groovy, JRuby, Quartz, EHCache)</p><h4 id="spring-web-jar"><a href="#spring-web-jar" class="headerlink" title="spring-web.jar"></a>spring-web.jar</h4><p>这个jar 文件包含Web 应用开发时，用到Spring 框架时所需的核心类，包括自动载入Web Application Context 特性的类、Struts 与JSF 集成类、文件上传的支持类、Filter 类和大量工具辅助类。<br>外部依赖spring-context, Servlet API, (JSP API, JSTL, Commons FileUpload, COS)。</p><h4 id="spring-webmvc-jar"><a href="#spring-webmvc-jar" class="headerlink" title="spring-webmvc.jar"></a>spring-webmvc.jar</h4><p>这个jar 文件包含Spring MVC 框架相关的所有类。包括框架的Servlets，Web MVC框架，控制器和视图支持。当然，如果你的应用使用了独立的MVC 框架，则无需这个JAR 文件里的任何类。<br>外部依赖spring-web, (spring-support，Tiles，iText，POI)。</p><h4 id="spring-portlet-jar"><a href="#spring-portlet-jar" class="headerlink" title="spring-portlet.jar"></a>spring-portlet.jar</h4><p>spring自己实现的一个类似Spring MVC的框架。包括一个MVC框架和控制器。<br>外部依赖spring-web， Portlet API，(spring-webmvc)。</p><h4 id="spring-struts-jar"><a href="#spring-struts-jar" class="headerlink" title="spring-struts.jar"></a>spring-struts.jar</h4><p>Struts框架支持，可以更方便更容易的集成Struts框架。<br>外部依赖spring-web，Struts。</p><h4 id="spring-remoting-jar"><a href="#spring-remoting-jar" class="headerlink" title="spring-remoting.jar"></a>spring-remoting.jar</h4><p>这个jar 文件包含支持EJB、远程调用Remoting（RMI、Hessian、Burlap、Http Invoker、JAX-RPC）方面的类。<br>外部依赖spring-aop， (spring-context，spring-web，Hessian，Burlap，JAX-RPC，EJB API)。</p><h4 id="spring-jmx-jar"><a href="#spring-jmx-jar" class="headerlink" title="spring-jmx.jar"></a>spring-jmx.jar</h4><p>这个jar包提供了对JMX 1.0/1.2的支持类。<br>外部依赖spring-beans，spring-aop， JMX API。</p><h4 id="spring-jms-jar"><a href="#spring-jms-jar" class="headerlink" title="spring-jms.jar"></a>spring-jms.jar</h4><p>这个jar包提供了对JMS 1.0.2/1.1的支持类。<br>外部依赖spring-beans，spring-dao，JMS API。</p><h4 id="spring-jca-jar"><a href="#spring-jca-jar" class="headerlink" title="spring-jca.jar"></a>spring-jca.jar</h4><p>对JCA 1.0的支持。<br>外部依赖spring-beans，spring-dao， JCA API。</p><h4 id="spring-jdo-jar"><a href="#spring-jdo-jar" class="headerlink" title="spring-jdo.jar"></a>spring-jdo.jar</h4><p>对JDO 1.0/2.0的支持。<br>外部依赖spring-jdbc， JDO API， (spring-web)。</p><h4 id="spring-jpa-jar"><a href="#spring-jpa-jar" class="headerlink" title="spring-jpa.jar"></a>spring-jpa.jar</h4><p>对JPA 1.0的支持。<br>外部依赖spring-jdbc， JPA API， (spring-web)。</p><h4 id="spring-hibernate2-jar"><a href="#spring-hibernate2-jar" class="headerlink" title="spring-hibernate2.jar"></a>spring-hibernate2.jar</h4><p>对Hibernate 2.1的支持，已经不建议使用。<br>外部依赖spring-jdbc，Hibernate2，(spring-web)。</p><h4 id="spring-hibernate3-jar"><a href="#spring-hibernate3-jar" class="headerlink" title="spring-hibernate3.jar"></a>spring-hibernate3.jar</h4><p>对Hibernate 3.0/3.1/3.2的支持。<br>外部依赖spring-jdbc，Hibernate3，(spring-web)。</p><h4 id="spring-toplink-jar"><a href="#spring-toplink-jar" class="headerlink" title="spring-toplink.jar"></a>spring-toplink.jar</h4><p>对TopLink框架的支持。<br>外部依赖spring-jdbc，TopLink。</p><h4 id="spring-ibatis-jar"><a href="#spring-ibatis-jar" class="headerlink" title="spring-ibatis.jar"></a>spring-ibatis.jar</h4><p>对iBATIS SQL Maps的支持。<br>外部依赖spring-jdbc，iBATIS SQL Maps。</p><p>另外的两个包。</p><h4 id="spring-mock-jar"><a href="#spring-mock-jar" class="headerlink" title="spring-mock.jar"></a>spring-mock.jar</h4><p>这个jar 文件包含Spring 一整套mock 类来辅助应用的测试。Spring 测试套件使用了其中大量mock 类，这样测试就更加简单。模拟HttpServletRequest 和HttpServletResponse 类在Web 应用单元测试是很方便的。并且提供了对JUnit的支持。<br>外部依赖spring-core。</p><h4 id="spring-aspects-jar"><a href="#spring-aspects-jar" class="headerlink" title="spring-aspects.jar"></a>spring-aspects.jar</h4><p>提供对AspectJ的支持，以便可以方便的将面向方面的功能集成进IDE中，比如Eclipse AJDT。<br>外部依赖。</p><p>WEAVER JARS (dist/weavers)说明。</p><h4 id="spring-agent-jar"><a href="#spring-agent-jar" class="headerlink" title="spring-agent.jar"></a>spring-agent.jar</h4><p>Spring的InstrumentationSavingAgent (为InstrumentationLoadTimeWeaver)，一个设备代理包，可以参考JDK1.5的Instrumentation功能获得更多信息。<br>外部依赖none (for use at JVM startup: “-javaagent:spring-agent.jar”)。</p><h4 id="spring-tomcat-weaver-jar"><a href="#spring-tomcat-weaver-jar" class="headerlink" title="spring-tomcat-weaver.jar"></a>spring-tomcat-weaver.jar</h4><p>扩展Tomcat的ClassLoader，使其可以使用instrumentation（设备）类。<br>外部依赖none (for deployment into Tomcat’s “server/lib” directory)。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一个工程需要很多个关于spring的jar包，下面详细说明每个jar的作用。&lt;/p&gt;
    
    </summary>
    
      <category term="Spring In Action" scheme="http://yoursite.com/categories/Spring-In-Action/"/>
    
    
      <category term="Spring" scheme="http://yoursite.com/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>Maven中pom标签详解</title>
    <link href="http://yoursite.com/2017/03/08/Maven%E4%B8%ADpom%E6%A0%87%E7%AD%BE%E8%AF%A6%E8%A7%A3/"/>
    <id>http://yoursite.com/2017/03/08/Maven中pom标签详解/</id>
    <published>2017-03-08T15:02:25.000Z</published>
    <updated>2017-09-28T06:46:28.515Z</updated>
    
    <content type="html"><![CDATA[<p> pom作为项目对象模型。通过xml表示maven项目，使用pom.xml来实现。主要描述了项目：包括配置文件；开发者需要遵循的规则，缺陷管理系统，组织和licenses，项目的url，项目的依赖性，以及其他所有的项目相关因素。<br><a id="more"></a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div><div class="line">178</div><div class="line">179</div><div class="line">180</div><div class="line">181</div><div class="line">182</div><div class="line">183</div><div class="line">184</div><div class="line">185</div><div class="line">186</div><div class="line">187</div><div class="line">188</div><div class="line">189</div><div class="line">190</div><div class="line">191</div><div class="line">192</div><div class="line">193</div><div class="line">194</div><div class="line">195</div><div class="line">196</div><div class="line">197</div><div class="line">198</div><div class="line">199</div><div class="line">200</div><div class="line">201</div><div class="line">202</div><div class="line">203</div><div class="line">204</div><div class="line">205</div><div class="line">206</div><div class="line">207</div><div class="line">208</div><div class="line">209</div><div class="line">210</div><div class="line">211</div><div class="line">212</div><div class="line">213</div><div class="line">214</div><div class="line">215</div><div class="line">216</div><div class="line">217</div><div class="line">218</div><div class="line">219</div><div class="line">220</div><div class="line">221</div><div class="line">222</div><div class="line">223</div><div class="line">224</div><div class="line">225</div><div class="line">226</div><div class="line">227</div><div class="line">228</div><div class="line">229</div><div class="line">230</div><div class="line">231</div><div class="line">232</div><div class="line">233</div><div class="line">234</div><div class="line">235</div><div class="line">236</div><div class="line">237</div><div class="line">238</div><div class="line">239</div><div class="line">240</div><div class="line">241</div><div class="line">242</div><div class="line">243</div><div class="line">244</div><div class="line">245</div><div class="line">246</div><div class="line">247</div><div class="line">248</div><div class="line">249</div><div class="line">250</div><div class="line">251</div><div class="line">252</div><div class="line">253</div><div class="line">254</div><div class="line">255</div><div class="line">256</div><div class="line">257</div><div class="line">258</div><div class="line">259</div><div class="line">260</div><div class="line">261</div><div class="line">262</div><div class="line">263</div><div class="line">264</div><div class="line">265</div><div class="line">266</div><div class="line">267</div><div class="line">268</div><div class="line">269</div><div class="line">270</div><div class="line">271</div><div class="line">272</div><div class="line">273</div><div class="line">274</div><div class="line">275</div><div class="line">276</div><div class="line">277</div><div class="line">278</div><div class="line">279</div><div class="line">280</div><div class="line">281</div><div class="line">282</div><div class="line">283</div><div class="line">284</div><div class="line">285</div><div class="line">286</div><div class="line">287</div><div class="line">288</div><div class="line">289</div><div class="line">290</div><div class="line">291</div><div class="line">292</div><div class="line">293</div><div class="line">294</div><div class="line">295</div><div class="line">296</div><div class="line">297</div><div class="line">298</div><div class="line">299</div><div class="line">300</div><div class="line">301</div><div class="line">302</div><div class="line">303</div><div class="line">304</div><div class="line">305</div><div class="line">306</div><div class="line">307</div><div class="line">308</div><div class="line">309</div><div class="line">310</div><div class="line">311</div><div class="line">312</div><div class="line">313</div><div class="line">314</div><div class="line">315</div><div class="line">316</div><div class="line">317</div><div class="line">318</div><div class="line">319</div><div class="line">320</div><div class="line">321</div><div class="line">322</div><div class="line">323</div><div class="line">324</div><div class="line">325</div><div class="line">326</div><div class="line">327</div><div class="line">328</div><div class="line">329</div><div class="line">330</div><div class="line">331</div><div class="line">332</div><div class="line">333</div><div class="line">334</div><div class="line">335</div><div class="line">336</div><div class="line">337</div><div class="line">338</div><div class="line">339</div><div class="line">340</div><div class="line">341</div><div class="line">342</div><div class="line">343</div><div class="line">344</div><div class="line">345</div><div class="line">346</div><div class="line">347</div><div class="line">348</div><div class="line">349</div><div class="line">350</div><div class="line">351</div><div class="line">352</div><div class="line">353</div><div class="line">354</div><div class="line">355</div><div class="line">356</div><div class="line">357</div><div class="line">358</div><div class="line">359</div><div class="line">360</div><div class="line">361</div><div class="line">362</div><div class="line">363</div><div class="line">364</div><div class="line">365</div><div class="line">366</div><div class="line">367</div><div class="line">368</div><div class="line">369</div><div class="line">370</div><div class="line">371</div><div class="line">372</div><div class="line">373</div><div class="line">374</div><div class="line">375</div><div class="line">376</div><div class="line">377</div><div class="line">378</div><div class="line">379</div><div class="line">380</div><div class="line">381</div><div class="line">382</div><div class="line">383</div><div class="line">384</div><div class="line">385</div><div class="line">386</div><div class="line">387</div><div class="line">388</div><div class="line">389</div><div class="line">390</div><div class="line">391</div><div class="line">392</div><div class="line">393</div><div class="line">394</div><div class="line">395</div><div class="line">396</div><div class="line">397</div><div class="line">398</div><div class="line">399</div><div class="line">400</div><div class="line">401</div><div class="line">402</div><div class="line">403</div><div class="line">404</div><div class="line">405</div><div class="line">406</div><div class="line">407</div><div class="line">408</div><div class="line">409</div><div class="line">410</div><div class="line">411</div><div class="line">412</div><div class="line">413</div><div class="line">414</div><div class="line">415</div><div class="line">416</div><div class="line">417</div><div class="line">418</div><div class="line">419</div><div class="line">420</div><div class="line">421</div><div class="line">422</div><div class="line">423</div><div class="line">424</div><div class="line">425</div><div class="line">426</div><div class="line">427</div><div class="line">428</div><div class="line">429</div><div class="line">430</div><div class="line">431</div><div class="line">432</div><div class="line">433</div><div class="line">434</div><div class="line">435</div><div class="line">436</div><div class="line">437</div><div class="line">438</div><div class="line">439</div><div class="line">440</div><div class="line">441</div><div class="line">442</div><div class="line">443</div><div class="line">444</div><div class="line">445</div><div class="line">446</div><div class="line">447</div><div class="line">448</div><div class="line">449</div><div class="line">450</div><div class="line">451</div><div class="line">452</div><div class="line">453</div><div class="line">454</div><div class="line">455</div><div class="line">456</div><div class="line">457</div><div class="line">458</div><div class="line">459</div><div class="line">460</div><div class="line">461</div><div class="line">462</div><div class="line">463</div><div class="line">464</div><div class="line">465</div><div class="line">466</div><div class="line">467</div><div class="line">468</div><div class="line">469</div><div class="line">470</div><div class="line">471</div><div class="line">472</div><div class="line">473</div><div class="line">474</div><div class="line">475</div><div class="line">476</div><div class="line">477</div><div class="line">478</div><div class="line">479</div><div class="line">480</div><div class="line">481</div><div class="line">482</div><div class="line">483</div><div class="line">484</div><div class="line">485</div><div class="line">486</div><div class="line">487</div><div class="line">488</div><div class="line">489</div><div class="line">490</div><div class="line">491</div><div class="line">492</div><div class="line">493</div><div class="line">494</div><div class="line">495</div><div class="line">496</div><div class="line">497</div><div class="line">498</div><div class="line">499</div><div class="line">500</div><div class="line">501</div><div class="line">502</div><div class="line">503</div><div class="line">504</div><div class="line">505</div><div class="line">506</div><div class="line">507</div><div class="line">508</div><div class="line">509</div><div class="line">510</div><div class="line">511</div><div class="line">512</div><div class="line">513</div><div class="line">514</div><div class="line">515</div><div class="line">516</div><div class="line">517</div><div class="line">518</div><div class="line">519</div><div class="line">520</div><div class="line">521</div><div class="line">522</div><div class="line">523</div><div class="line">524</div><div class="line">525</div><div class="line">526</div><div class="line">527</div><div class="line">528</div><div class="line">529</div><div class="line">530</div><div class="line">531</div><div class="line">532</div><div class="line">533</div><div class="line">534</div><div class="line">535</div><div class="line">536</div><div class="line">537</div><div class="line">538</div><div class="line">539</div><div class="line">540</div><div class="line">541</div><div class="line">542</div><div class="line">543</div><div class="line">544</div><div class="line">545</div><div class="line">546</div><div class="line">547</div><div class="line">548</div><div class="line">549</div><div class="line">550</div><div class="line">551</div><div class="line">552</div><div class="line">553</div><div class="line">554</div><div class="line">555</div><div class="line">556</div><div class="line">557</div><div class="line">558</div><div class="line">559</div><div class="line">560</div><div class="line">561</div><div class="line">562</div><div class="line">563</div><div class="line">564</div><div class="line">565</div><div class="line">566</div><div class="line">567</div><div class="line">568</div><div class="line">569</div><div class="line">570</div><div class="line">571</div><div class="line">572</div><div class="line">573</div><div class="line">574</div><div class="line">575</div><div class="line">576</div><div class="line">577</div><div class="line">578</div><div class="line">579</div><div class="line">580</div><div class="line">581</div><div class="line">582</div><div class="line">583</div><div class="line">584</div><div class="line">585</div><div class="line">586</div><div class="line">587</div><div class="line">588</div><div class="line">589</div><div class="line">590</div><div class="line">591</div><div class="line">592</div><div class="line">593</div><div class="line">594</div><div class="line">595</div><div class="line">596</div><div class="line">597</div><div class="line">598</div><div class="line">599</div><div class="line">600</div><div class="line">601</div></pre></td><td class="code"><pre><div class="line">&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;     </div><div class="line">    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;     </div><div class="line">xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0http://maven.apache.org/maven-v4_0_0.xsd&quot;&gt;     </div><div class="line">    &lt;!--父项目的坐标。如果项目中没有规定某个元素的值，那么父项目中的对应值即为项目的默认值。 坐标包括group ID，artifact ID和 version。--&gt;    </div><div class="line">    &lt;parent&gt;    </div><div class="line">     &lt;!--被继承的父项目的构件标识符--&gt;    </div><div class="line">     &lt;artifactId/&gt;    </div><div class="line">     &lt;!--被继承的父项目的全球唯一标识符--&gt;    </div><div class="line">     &lt;groupId/&gt;    </div><div class="line">     &lt;!--被继承的父项目的版本--&gt;    </div><div class="line">     &lt;version/&gt;    </div><div class="line">     &lt;!-- 父项目的pom.xml文件的相对路径。相对路径允许你选择一个不同的路径。默认值是../pom.xml。Maven首先在构建当前项目的地方寻找父项 目的pom，其次在文件系统的这个位置（relativePath位置），然后在本地仓库，最后在远程仓库寻找父项目的pom。--&gt;    </div><div class="line">     &lt;relativePath/&gt;    </div><div class="line"> &lt;/parent&gt;    </div><div class="line"> &lt;!--声明项目描述符遵循哪一个POM模型版本。模型本身的版本很少改变，虽然如此，但它仍然是必不可少的，这是为了当Maven引入了新的特性或者其他模型变更的时候，确保稳定性。--&gt;       </div><div class="line">    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;     </div><div class="line">    &lt;!--项目的全球唯一标识符，通常使用全限定的包名区分该项目和其他项目。并且构建时生成的路径也是由此生成， 如com.mycompany.app生成的相对路径为：/com/mycompany/app--&gt;     </div><div class="line">    &lt;groupId&gt;asia.banseon&lt;/groupId&gt;     </div><div class="line">    &lt;!-- 构件的标识符，它和group ID一起唯一标识一个构件。换句话说，你不能有两个不同的项目拥有同样的artifact ID和groupID；在某个 特定的group ID下，artifact ID也必须是唯一的。构件是项目产生的或使用的一个东西，Maven为项目产生的构件包括：JARs，源 码，二进制发布和WARs等。--&gt;     </div><div class="line">    &lt;artifactId&gt;banseon-maven2&lt;/artifactId&gt;     </div><div class="line">    &lt;!--项目产生的构件类型，例如jar、war、ear、pom。插件可以创建他们自己的构件类型，所以前面列的不是全部构件类型--&gt;     </div><div class="line">    &lt;packaging&gt;jar&lt;/packaging&gt;     </div><div class="line">    &lt;!--项目当前版本，格式为:主版本.次版本.增量版本-限定版本号--&gt;     </div><div class="line">    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;     </div><div class="line">    &lt;!--项目的名称, Maven产生的文档用--&gt;     </div><div class="line">    &lt;name&gt;banseon-maven&lt;/name&gt;     </div><div class="line">    &lt;!--项目主页的URL, Maven产生的文档用--&gt;     </div><div class="line">    &lt;url&gt;http://www.baidu.com/banseon&lt;/url&gt;     </div><div class="line">    &lt;!-- 项目的详细描述, Maven 产生的文档用。  当这个元素能够用HTML格式描述时（例如，CDATA中的文本会被解析器忽略，就可以包含HTML标 签）， 不鼓励使用纯文本描述。如果你需要修改产生的web站点的索引页面，你应该修改你自己的索引页文件，而不是调整这里的文档。--&gt;     </div><div class="line">    &lt;description&gt;A maven project to study maven.&lt;/description&gt;     </div><div class="line">    &lt;!--描述了这个项目构建环境中的前提条件。--&gt;    </div><div class="line"> &lt;prerequisites&gt;    </div><div class="line">  &lt;!--构建该项目或使用该插件所需要的Maven的最低版本--&gt;    </div><div class="line">    &lt;maven/&gt;    </div><div class="line"> &lt;/prerequisites&gt;    </div><div class="line"> &lt;!--项目的问题管理系统(Bugzilla, Jira, Scarab,或任何你喜欢的问题管理系统)的名称和URL，本例为 jira--&gt;     </div><div class="line">    &lt;issueManagement&gt;    </div><div class="line">     &lt;!--问题管理系统（例如jira）的名字，--&gt;     </div><div class="line">        &lt;system&gt;jira&lt;/system&gt;     </div><div class="line">        &lt;!--该项目使用的问题管理系统的URL--&gt;    </div><div class="line">        &lt;url&gt;http://jira.baidu.com/banseon&lt;/url&gt;     </div><div class="line">    &lt;/issueManagement&gt;     </div><div class="line">    &lt;!--项目持续集成信息--&gt;    </div><div class="line"> &lt;ciManagement&gt;    </div><div class="line">  &lt;!--持续集成系统的名字，例如continuum--&gt;    </div><div class="line">  &lt;system/&gt;    </div><div class="line">  &lt;!--该项目使用的持续集成系统的URL（如果持续集成系统有web接口的话）。--&gt;    </div><div class="line">  &lt;url/&gt;    </div><div class="line">  &lt;!--构建完成时，需要通知的开发者/用户的配置项。包括被通知者信息和通知条件（错误，失败，成功，警告）--&gt;    </div><div class="line">  &lt;notifiers&gt;    </div><div class="line">   &lt;!--配置一种方式，当构建中断时，以该方式通知用户/开发者--&gt;    </div><div class="line">   &lt;notifier&gt;    </div><div class="line">    &lt;!--传送通知的途径--&gt;    </div><div class="line">    &lt;type/&gt;    </div><div class="line">    &lt;!--发生错误时是否通知--&gt;    </div><div class="line">    &lt;sendOnError/&gt;    </div><div class="line">    &lt;!--构建失败时是否通知--&gt;    </div><div class="line">    &lt;sendOnFailure/&gt;    </div><div class="line">    &lt;!--构建成功时是否通知--&gt;    </div><div class="line">    &lt;sendOnSuccess/&gt;    </div><div class="line">    &lt;!--发生警告时是否通知--&gt;    </div><div class="line">    &lt;sendOnWarning/&gt;    </div><div class="line">    &lt;!--不赞成使用。通知发送到哪里--&gt;    </div><div class="line">    &lt;address/&gt;    </div><div class="line">    &lt;!--扩展配置项--&gt;    </div><div class="line">    &lt;configuration/&gt;    </div><div class="line">   &lt;/notifier&gt;    </div><div class="line">  &lt;/notifiers&gt;    </div><div class="line"> &lt;/ciManagement&gt;    </div><div class="line"> &lt;!--项目创建年份，4位数字。当产生版权信息时需要使用这个值。--&gt;    </div><div class="line">    &lt;inceptionYear/&gt;    </div><div class="line">    &lt;!--项目相关邮件列表信息--&gt;     </div><div class="line">    &lt;mailingLists&gt;    </div><div class="line">     &lt;!--该元素描述了项目相关的所有邮件列表。自动产生的网站引用这些信息。--&gt;     </div><div class="line">        &lt;mailingList&gt;     </div><div class="line">         &lt;!--邮件的名称--&gt;    </div><div class="line">            &lt;name&gt;Demo&lt;/name&gt;     </div><div class="line">            &lt;!--发送邮件的地址或链接，如果是邮件地址，创建文档时，mailto: 链接会被自动创建--&gt;     </div><div class="line">            &lt;post&gt;banseon@126.com&lt;/post&gt;     </div><div class="line">            &lt;!--订阅邮件的地址或链接，如果是邮件地址，创建文档时，mailto: 链接会被自动创建--&gt;     </div><div class="line">            &lt;subscribe&gt;banseon@126.com&lt;/subscribe&gt;     </div><div class="line">            &lt;!--取消订阅邮件的地址或链接，如果是邮件地址，创建文档时，mailto: 链接会被自动创建--&gt;     </div><div class="line">            &lt;unsubscribe&gt;banseon@126.com&lt;/unsubscribe&gt;     </div><div class="line">            &lt;!--你可以浏览邮件信息的URL--&gt;    </div><div class="line">            &lt;archive&gt;http:/hi.baidu.com/banseon/demo/dev/&lt;/archive&gt;     </div><div class="line">        &lt;/mailingList&gt;     </div><div class="line">    &lt;/mailingLists&gt;     </div><div class="line">    &lt;!--项目开发者列表--&gt;     </div><div class="line">    &lt;developers&gt;     </div><div class="line">     &lt;!--某个项目开发者的信息--&gt;    </div><div class="line">        &lt;developer&gt;     </div><div class="line">         &lt;!--SCM里项目开发者的唯一标识符--&gt;    </div><div class="line">            &lt;id&gt;HELLO WORLD&lt;/id&gt;     </div><div class="line">            &lt;!--项目开发者的全名--&gt;    </div><div class="line">            &lt;name&gt;banseon&lt;/name&gt;     </div><div class="line">            &lt;!--项目开发者的email--&gt;    </div><div class="line">            &lt;email&gt;banseon@126.com&lt;/email&gt;     </div><div class="line">            &lt;!--项目开发者的主页的URL--&gt;    </div><div class="line">            &lt;url/&gt;    </div><div class="line">            &lt;!--项目开发者在项目中扮演的角色，角色元素描述了各种角色--&gt;    </div><div class="line">            &lt;roles&gt;     </div><div class="line">                &lt;role&gt;Project Manager&lt;/role&gt;     </div><div class="line">                &lt;role&gt;Architect&lt;/role&gt;     </div><div class="line">            &lt;/roles&gt;    </div><div class="line">            &lt;!--项目开发者所属组织--&gt;    </div><div class="line">            &lt;organization&gt;demo&lt;/organization&gt;     </div><div class="line">            &lt;!--项目开发者所属组织的URL--&gt;    </div><div class="line">            &lt;organizationUrl&gt;http://hi.baidu.com/banseon&lt;/organizationUrl&gt;     </div><div class="line">            &lt;!--项目开发者属性，如即时消息如何处理等--&gt;    </div><div class="line">            &lt;properties&gt;     </div><div class="line">                &lt;dept&gt;No&lt;/dept&gt;     </div><div class="line">            &lt;/properties&gt;    </div><div class="line">            &lt;!--项目开发者所在时区， -11到12范围内的整数。--&gt;    </div><div class="line">            &lt;timezone&gt;-5&lt;/timezone&gt;     </div><div class="line">        &lt;/developer&gt;     </div><div class="line">    &lt;/developers&gt;     </div><div class="line">    &lt;!--项目的其他贡献者列表--&gt;     </div><div class="line">    &lt;contributors&gt;    </div><div class="line">     &lt;!--项目的其他贡献者。参见developers/developer元素--&gt;    </div><div class="line">     &lt;contributor&gt;    </div><div class="line">   &lt;name/&gt;&lt;email/&gt;&lt;url/&gt;&lt;organization/&gt;&lt;organizationUrl/&gt;&lt;roles/&gt;&lt;timezone/&gt;&lt;properties/&gt;    </div><div class="line">     &lt;/contributor&gt;         </div><div class="line">    &lt;/contributors&gt;       </div><div class="line">    &lt;!--该元素描述了项目所有License列表。 应该只列出该项目的license列表，不要列出依赖项目的 license列表。如果列出多个license，用户可以选择它们中的一个而不是接受所有license。--&gt;     </div><div class="line">    &lt;licenses&gt;    </div><div class="line">     &lt;!--描述了项目的license，用于生成项目的web站点的license页面，其他一些报表和validation也会用到该元素。--&gt;     </div><div class="line">        &lt;license&gt;    </div><div class="line">         &lt;!--license用于法律上的名称--&gt;    </div><div class="line">            &lt;name&gt;Apache 2&lt;/name&gt;     </div><div class="line">            &lt;!--官方的license正文页面的URL--&gt;    </div><div class="line">            &lt;url&gt;http://www.baidu.com/banseon/LICENSE-2.0.txt&lt;/url&gt;     </div><div class="line">            &lt;!--项目分发的主要方式：    </div><div class="line">              repo，可以从Maven库下载    </div><div class="line">              manual， 用户必须手动下载和安装依赖--&gt;    </div><div class="line">            &lt;distribution&gt;repo&lt;/distribution&gt;     </div><div class="line">            &lt;!--关于license的补充信息--&gt;    </div><div class="line">            &lt;comments&gt;A business-friendly OSS license&lt;/comments&gt;</div><div class="line">        &lt;/license&gt;     </div><div class="line">    &lt;/licenses&gt;     </div><div class="line">    &lt;!--SCM(Source Control Management)标签允许你配置你的代码库，供Maven web站点和其它插件使用。--&gt;     </div><div class="line">    &lt;scm&gt;     </div><div class="line">        &lt;!--SCM的URL,该URL描述了版本库和如何连接到版本库。欲知详情，请看SCMs提供的URL格式和列表。该连接只读。--&gt;     </div><div class="line">        &lt;connection&gt;     </div><div class="line">            scm:svn:http://svn.baidu.com/banseon/maven/banseon/banseon-maven2-trunk(dao-trunk)      </div><div class="line">        &lt;/connection&gt;     </div><div class="line">        &lt;!--给开发者使用的，类似connection元素。即该连接不仅仅只读--&gt;    </div><div class="line">        &lt;developerConnection&gt;     </div><div class="line">            scm:svn:http://svn.baidu.com/banseon/maven/banseon/dao-trunk      </div><div class="line">        &lt;/developerConnection&gt;    </div><div class="line">        &lt;!--当前代码的标签，在开发阶段默认为HEAD--&gt;    </div><div class="line">        &lt;tag/&gt;           </div><div class="line">        &lt;!--指向项目的可浏览SCM库（例如ViewVC或者Fisheye）的URL。--&gt;     </div><div class="line">        &lt;url&gt;http://svn.baidu.com/banseon&lt;/url&gt;     </div><div class="line">    &lt;/scm&gt;     </div><div class="line">    &lt;!--描述项目所属组织的各种属性。Maven产生的文档用--&gt;     </div><div class="line">    &lt;organization&gt;     </div><div class="line">     &lt;!--组织的全名--&gt;    </div><div class="line">        &lt;name&gt;demo&lt;/name&gt;     </div><div class="line">        &lt;!--组织主页的URL--&gt;    </div><div class="line">        &lt;url&gt;http://www.baidu.com/banseon&lt;/url&gt;     </div><div class="line">    &lt;/organization&gt;    </div><div class="line">    &lt;!--构建项目需要的信息--&gt;    </div><div class="line">    &lt;build&gt;    </div><div class="line">     &lt;!--该元素设置了项目源码目录，当构建项目的时候，构建系统会编译目录里的源码。该路径是相对于pom.xml的相对路径。--&gt;    </div><div class="line">  &lt;sourceDirectory/&gt;    </div><div class="line">  &lt;!--该元素设置了项目脚本源码目录，该目录和源码目录不同：绝大多数情况下，该目录下的内容 会被拷贝到输出目录(因为脚本是被解释的，而不是被编译的)。--&gt;    </div><div class="line">  &lt;scriptSourceDirectory/&gt;    </div><div class="line">  &lt;!--该元素设置了项目单元测试使用的源码目录，当测试项目的时候，构建系统会编译目录里的源码。该路径是相对于pom.xml的相对路径。--&gt;    </div><div class="line">  &lt;testSourceDirectory/&gt;    </div><div class="line">  &lt;!--被编译过的应用程序class文件存放的目录。--&gt;    </div><div class="line">  &lt;outputDirectory/&gt;    </div><div class="line">  &lt;!--被编译过的测试class文件存放的目录。--&gt;    </div><div class="line">  &lt;testOutputDirectory/&gt;    </div><div class="line">  &lt;!--使用来自该项目的一系列构建扩展--&gt;    </div><div class="line">  &lt;extensions&gt;    </div><div class="line">   &lt;!--描述使用到的构建扩展。--&gt;    </div><div class="line">   &lt;extension&gt;    </div><div class="line">    &lt;!--构建扩展的groupId--&gt;    </div><div class="line">    &lt;groupId/&gt;    </div><div class="line">    &lt;!--构建扩展的artifactId--&gt;    </div><div class="line">    &lt;artifactId/&gt;    </div><div class="line">    &lt;!--构建扩展的版本--&gt;    </div><div class="line">    &lt;version/&gt;    </div><div class="line">   &lt;/extension&gt;    </div><div class="line">  &lt;/extensions&gt;    </div><div class="line">  &lt;!--当项目没有规定目标（Maven2 叫做阶段）时的默认值--&gt;    </div><div class="line">  &lt;defaultGoal/&gt;    </div><div class="line">  &lt;!--这个元素描述了项目相关的所有资源路径列表，例如和项目相关的属性文件，这些资源被包含在最终的打包文件里。--&gt;    </div><div class="line">  &lt;resources&gt;    </div><div class="line">   &lt;!--这个元素描述了项目相关或测试相关的所有资源路径--&gt;    </div><div class="line">   &lt;resource&gt;    </div><div class="line">    &lt;!-- 描述了资源的目标路径。该路径相对target/classes目录（例如$&#123;project.build.outputDirectory&#125;）。举个例 子，如果你想资源在特定的包里(org.apache.maven.messages)，你就必须该元素设置为org/apache/maven /messages。然而，如果你只是想把资源放到源码目录结构里，就不需要该配置。--&gt;    </div><div class="line">    &lt;targetPath/&gt;    </div><div class="line">    &lt;!--是否使用参数值代替参数名。参数值取自properties元素或者文件里配置的属性，文件在filters元素里列出。--&gt;    </div><div class="line">    &lt;filtering/&gt;    </div><div class="line">    &lt;!--描述存放资源的目录，该路径相对POM路径--&gt;    </div><div class="line">    &lt;directory/&gt;    </div><div class="line">    &lt;!--包含的模式列表，例如**/*.xml.--&gt;    </div><div class="line">    &lt;includes/&gt;    </div><div class="line">    &lt;!--排除的模式列表，例如**/*.xml--&gt;    </div><div class="line">    &lt;excludes/&gt;    </div><div class="line">   &lt;/resource&gt;    </div><div class="line">  &lt;/resources&gt;    </div><div class="line">  &lt;!--这个元素描述了单元测试相关的所有资源路径，例如和单元测试相关的属性文件。--&gt;    </div><div class="line">  &lt;testResources&gt;    </div><div class="line">   &lt;!--这个元素描述了测试相关的所有资源路径，参见build/resources/resource元素的说明--&gt;    </div><div class="line">   &lt;testResource&gt;    </div><div class="line">    &lt;targetPath/&gt;&lt;filtering/&gt;&lt;directory/&gt;&lt;includes/&gt;&lt;excludes/&gt;    </div><div class="line">   &lt;/testResource&gt;    </div><div class="line">  &lt;/testResources&gt;    </div><div class="line">  &lt;!--构建产生的所有文件存放的目录--&gt;    </div><div class="line">  &lt;directory/&gt;    </div><div class="line">  &lt;!--产生的构件的文件名，默认值是$&#123;artifactId&#125;-$&#123;version&#125;。--&gt;    </div><div class="line">  &lt;finalName/&gt;    </div><div class="line">  &lt;!--当filtering开关打开时，使用到的过滤器属性文件列表--&gt;    </div><div class="line">  &lt;filters/&gt;    </div><div class="line">  &lt;!--子项目可以引用的默认插件信息。该插件配置项直到被引用时才会被解析或绑定到生命周期。给定插件的任何本地配置都会覆盖这里的配置--&gt;    </div><div class="line">  &lt;pluginManagement&gt;    </div><div class="line">   &lt;!--使用的插件列表 。--&gt;    </div><div class="line">   &lt;plugins&gt;    </div><div class="line">    &lt;!--plugin元素包含描述插件所需要的信息。--&gt;    </div><div class="line">    &lt;plugin&gt;    </div><div class="line">     &lt;!--插件在仓库里的group ID--&gt;    </div><div class="line">     &lt;groupId/&gt;    </div><div class="line">     &lt;!--插件在仓库里的artifact ID--&gt;    </div><div class="line">     &lt;artifactId/&gt;    </div><div class="line">     &lt;!--被使用的插件的版本（或版本范围）--&gt;    </div><div class="line">     &lt;version/&gt;    </div><div class="line">     &lt;!--是否从该插件下载Maven扩展（例如打包和类型处理器），由于性能原因，只有在真需要下载时，该元素才被设置成enabled。--&gt;    </div><div class="line">     &lt;extensions/&gt;    </div><div class="line">     &lt;!--在构建生命周期中执行一组目标的配置。每个目标可能有不同的配置。--&gt;    </div><div class="line">     &lt;executions&gt;    </div><div class="line">      &lt;!--execution元素包含了插件执行需要的信息--&gt;    </div><div class="line">      &lt;execution&gt;    </div><div class="line">       &lt;!--执行目标的标识符，用于标识构建过程中的目标，或者匹配继承过程中需要合并的执行目标--&gt;    </div><div class="line">       &lt;id/&gt;    </div><div class="line">       &lt;!--绑定了目标的构建生命周期阶段，如果省略，目标会被绑定到源数据里配置的默认阶段--&gt;    </div><div class="line">       &lt;phase/&gt;    </div><div class="line">       &lt;!--配置的执行目标--&gt;    </div><div class="line">       &lt;goals/&gt;    </div><div class="line">       &lt;!--配置是否被传播到子POM--&gt;    </div><div class="line">       &lt;inherited/&gt;    </div><div class="line">       &lt;!--作为DOM对象的配置--&gt;    </div><div class="line">       &lt;configuration/&gt;    </div><div class="line">      &lt;/execution&gt;    </div><div class="line">     &lt;/executions&gt;    </div><div class="line">     &lt;!--项目引入插件所需要的额外依赖--&gt;    </div><div class="line">     &lt;dependencies&gt;    </div><div class="line">      &lt;!--参见dependencies/dependency元素--&gt;    </div><div class="line">      &lt;dependency&gt;    </div><div class="line">       ......    </div><div class="line">      &lt;/dependency&gt;    </div><div class="line">     &lt;/dependencies&gt;         </div><div class="line">     &lt;!--任何配置是否被传播到子项目--&gt;    </div><div class="line">     &lt;inherited/&gt;    </div><div class="line">     &lt;!--作为DOM对象的配置--&gt;    </div><div class="line">     &lt;configuration/&gt;    </div><div class="line">    &lt;/plugin&gt;    </div><div class="line">   &lt;/plugins&gt;    </div><div class="line">  &lt;/pluginManagement&gt;    </div><div class="line">  &lt;!--使用的插件列表--&gt;    </div><div class="line">  &lt;plugins&gt;    </div><div class="line">   &lt;!--参见build/pluginManagement/plugins/plugin元素--&gt;    </div><div class="line">   &lt;plugin&gt;    </div><div class="line">    &lt;groupId/&gt;&lt;artifactId/&gt;&lt;version/&gt;&lt;extensions/&gt;    </div><div class="line">    &lt;executions&gt;    </div><div class="line">     &lt;execution&gt;    </div><div class="line">      &lt;id/&gt;&lt;phase/&gt;&lt;goals/&gt;&lt;inherited/&gt;&lt;configuration/&gt;    </div><div class="line">     &lt;/execution&gt;    </div><div class="line">    &lt;/executions&gt;    </div><div class="line">    &lt;dependencies&gt;    </div><div class="line">     &lt;!--参见dependencies/dependency元素--&gt;    </div><div class="line">     &lt;dependency&gt;    </div><div class="line">      ......    </div><div class="line">     &lt;/dependency&gt;    </div><div class="line">    &lt;/dependencies&gt;    </div><div class="line">    &lt;goals/&gt;&lt;inherited/&gt;&lt;configuration/&gt;    </div><div class="line">   &lt;/plugin&gt;    </div><div class="line">  &lt;/plugins&gt;    </div><div class="line"> &lt;/build&gt;    </div><div class="line"> &lt;!--在列的项目构建profile，如果被激活，会修改构建处理--&gt;    </div><div class="line"> &lt;profiles&gt;    </div><div class="line">  &lt;!--根据环境参数或命令行参数激活某个构建处理--&gt;    </div><div class="line">  &lt;profile&gt;    </div><div class="line">   &lt;!--构建配置的唯一标识符。即用于命令行激活，也用于在继承时合并具有相同标识符的profile。--&gt;    </div><div class="line">   &lt;id/&gt;    </div><div class="line">   &lt;!--自动触发profile的条件逻辑。Activation是profile的开启钥匙。profile的力量来自于它    </div><div class="line">   能够在某些特定的环境中自动使用某些特定的值；这些环境通过activation元素指定。activation元素并不是激活profile的唯一方式。--&gt;    </div><div class="line">   &lt;activation&gt;    </div><div class="line">    &lt;!--profile默认是否激活的标志--&gt;    </div><div class="line">    &lt;activeByDefault/&gt;    </div><div class="line">    &lt;!--当匹配的jdk被检测到，profile被激活。例如，1.4激活JDK1.4，1.4.0_2，而!1.4激活所有版本不是以1.4开头的JDK。--&gt;    </div><div class="line">    &lt;jdk/&gt;    </div><div class="line">    &lt;!--当匹配的操作系统属性被检测到，profile被激活。os元素可以定义一些操作系统相关的属性。--&gt;    </div><div class="line">    &lt;os&gt;    </div><div class="line">     &lt;!--激活profile的操作系统的名字--&gt;    </div><div class="line">     &lt;name&gt;Windows XP&lt;/name&gt;    </div><div class="line">     &lt;!--激活profile的操作系统所属家族(如 &apos;windows&apos;)--&gt;    </div><div class="line">     &lt;family&gt;Windows&lt;/family&gt;    </div><div class="line">     &lt;!--激活profile的操作系统体系结构 --&gt;    </div><div class="line">     &lt;arch&gt;x86&lt;/arch&gt;    </div><div class="line">     &lt;!--激活profile的操作系统版本--&gt;    </div><div class="line">     &lt;version&gt;5.1.2600&lt;/version&gt;    </div><div class="line">    &lt;/os&gt;    </div><div class="line">    &lt;!--如果Maven检测到某一个属性（其值可以在POM中通过$&#123;名称&#125;引用），其拥有对应的名称和值，Profile就会被激活。如果值    </div><div class="line">    字段是空的，那么存在属性名称字段就会激活profile，否则按区分大小写方式匹配属性值字段--&gt;    </div><div class="line">    &lt;property&gt;    </div><div class="line">     &lt;!--激活profile的属性的名称--&gt;    </div><div class="line">     &lt;name&gt;mavenVersion&lt;/name&gt;    </div><div class="line">     &lt;!--激活profile的属性的值--&gt;    </div><div class="line">     &lt;value&gt;2.0.3&lt;/value&gt;    </div><div class="line">    &lt;/property&gt;    </div><div class="line">    &lt;!--提供一个文件名，通过检测该文件的存在或不存在来激活profile。missing检查文件是否存在，如果不存在则激活    </div><div class="line">    profile。另一方面，exists则会检查文件是否存在，如果存在则激活profile。--&gt;    </div><div class="line">    &lt;file&gt;    </div><div class="line">     &lt;!--如果指定的文件存在，则激活profile。--&gt;    </div><div class="line">     &lt;exists&gt;/usr/local/hudson/hudson-home/jobs/maven-guide-zh-to-production/workspace/&lt;/exists&gt;    </div><div class="line">     &lt;!--如果指定的文件不存在，则激活profile。--&gt;    </div><div class="line">     &lt;missing&gt;/usr/local/hudson/hudson-home/jobs/maven-guide-zh-to-production/workspace/&lt;/missing&gt;    </div><div class="line">    &lt;/file&gt;    </div><div class="line">   &lt;/activation&gt;    </div><div class="line">   &lt;!--构建项目所需要的信息。参见build元素--&gt;    </div><div class="line">   &lt;build&gt;    </div><div class="line">    &lt;defaultGoal/&gt;    </div><div class="line">    &lt;resources&gt;    </div><div class="line">     &lt;resource&gt;    </div><div class="line">      &lt;targetPath/&gt;&lt;filtering/&gt;&lt;directory/&gt;&lt;includes/&gt;&lt;excludes/&gt;    </div><div class="line">     &lt;/resource&gt;    </div><div class="line">    &lt;/resources&gt;    </div><div class="line">    &lt;testResources&gt;    </div><div class="line">     &lt;testResource&gt;    </div><div class="line">      &lt;targetPath/&gt;&lt;filtering/&gt;&lt;directory/&gt;&lt;includes/&gt;&lt;excludes/&gt;    </div><div class="line">     &lt;/testResource&gt;    </div><div class="line">    &lt;/testResources&gt;    </div><div class="line">    &lt;directory/&gt;&lt;finalName/&gt;&lt;filters/&gt;    </div><div class="line">    &lt;pluginManagement&gt;    </div><div class="line">     &lt;plugins&gt;    </div><div class="line">      &lt;!--参见build/pluginManagement/plugins/plugin元素--&gt;    </div><div class="line">      &lt;plugin&gt;    </div><div class="line">       &lt;groupId/&gt;&lt;artifactId/&gt;&lt;version/&gt;&lt;extensions/&gt;    </div><div class="line">       &lt;executions&gt;    </div><div class="line">        &lt;execution&gt;    </div><div class="line">         &lt;id/&gt;&lt;phase/&gt;&lt;goals/&gt;&lt;inherited/&gt;&lt;configuration/&gt;    </div><div class="line">        &lt;/execution&gt;    </div><div class="line">       &lt;/executions&gt;    </div><div class="line">       &lt;dependencies&gt;    </div><div class="line">        &lt;!--参见dependencies/dependency元素--&gt;    </div><div class="line">        &lt;dependency&gt;    </div><div class="line">         ......    </div><div class="line">        &lt;/dependency&gt;    </div><div class="line">       &lt;/dependencies&gt;    </div><div class="line">       &lt;goals/&gt;&lt;inherited/&gt;&lt;configuration/&gt;    </div><div class="line">      &lt;/plugin&gt;    </div><div class="line">     &lt;/plugins&gt;    </div><div class="line">    &lt;/pluginManagement&gt;    </div><div class="line">    &lt;plugins&gt;    </div><div class="line">     &lt;!--参见build/pluginManagement/plugins/plugin元素--&gt;    </div><div class="line">     &lt;plugin&gt;    </div><div class="line">      &lt;groupId/&gt;&lt;artifactId/&gt;&lt;version/&gt;&lt;extensions/&gt;    </div><div class="line">      &lt;executions&gt;    </div><div class="line">       &lt;execution&gt;    </div><div class="line">        &lt;id/&gt;&lt;phase/&gt;&lt;goals/&gt;&lt;inherited/&gt;&lt;configuration/&gt;    </div><div class="line">       &lt;/execution&gt;    </div><div class="line">      &lt;/executions&gt;    </div><div class="line">      &lt;dependencies&gt;    </div><div class="line">       &lt;!--参见dependencies/dependency元素--&gt;    </div><div class="line">       &lt;dependency&gt;    </div><div class="line">        ......    </div><div class="line">       &lt;/dependency&gt;    </div><div class="line">      &lt;/dependencies&gt;    </div><div class="line">      &lt;goals/&gt;&lt;inherited/&gt;&lt;configuration/&gt;    </div><div class="line">     &lt;/plugin&gt;    </div><div class="line">    &lt;/plugins&gt;    </div><div class="line">   &lt;/build&gt;    </div><div class="line">   &lt;!--模块（有时称作子项目） 被构建成项目的一部分。列出的每个模块元素是指向该模块的目录的相对路径--&gt;    </div><div class="line">   &lt;modules/&gt;    </div><div class="line">   &lt;!--发现依赖和扩展的远程仓库列表。--&gt;    </div><div class="line">   &lt;repositories&gt;    </div><div class="line">    &lt;!--参见repositories/repository元素--&gt;    </div><div class="line">    &lt;repository&gt;    </div><div class="line">     &lt;releases&gt;    </div><div class="line">      &lt;enabled/&gt;&lt;updatePolicy/&gt;&lt;checksumPolicy/&gt;    </div><div class="line">     &lt;/releases&gt;    </div><div class="line">     &lt;snapshots&gt;    </div><div class="line">      &lt;enabled/&gt;&lt;updatePolicy/&gt;&lt;checksumPolicy/&gt;    </div><div class="line">     &lt;/snapshots&gt;    </div><div class="line">     &lt;id/&gt;&lt;name/&gt;&lt;url/&gt;&lt;layout/&gt;    </div><div class="line">    &lt;/repository&gt;    </div><div class="line">   &lt;/repositories&gt;    </div><div class="line">   &lt;!--发现插件的远程仓库列表，这些插件用于构建和报表--&gt;    </div><div class="line">   &lt;pluginRepositories&gt;    </div><div class="line">    &lt;!--包含需要连接到远程插件仓库的信息.参见repositories/repository元素--&gt;        </div><div class="line">    &lt;pluginRepository&gt;    </div><div class="line">     &lt;releases&gt;    </div><div class="line">      &lt;enabled/&gt;&lt;updatePolicy/&gt;&lt;checksumPolicy/&gt;    </div><div class="line">     &lt;/releases&gt;    </div><div class="line">     &lt;snapshots&gt;    </div><div class="line">      &lt;enabled/&gt;&lt;updatePolicy/&gt;&lt;checksumPolicy/&gt;    </div><div class="line">     &lt;/snapshots&gt;    </div><div class="line">     &lt;id/&gt;&lt;name/&gt;&lt;url/&gt;&lt;layout/&gt;    </div><div class="line">    &lt;/pluginRepository&gt;    </div><div class="line">   &lt;/pluginRepositories&gt;    </div><div class="line">   &lt;!--该元素描述了项目相关的所有依赖。 这些依赖组成了项目构建过程中的一个个环节。它们自动从项目定义的仓库中下载。要获取更多信息，请看项目依赖机制。--&gt;    </div><div class="line">   &lt;dependencies&gt;    </div><div class="line">    &lt;!--参见dependencies/dependency元素--&gt;    </div><div class="line">    &lt;dependency&gt;    </div><div class="line">     ......    </div><div class="line">    &lt;/dependency&gt;    </div><div class="line">   &lt;/dependencies&gt;    </div><div class="line">   &lt;!--不赞成使用. 现在Maven忽略该元素.--&gt;    </div><div class="line">   &lt;reports/&gt;       </div><div class="line">   &lt;!--该元素包括使用报表插件产生报表的规范。当用户执行“mvn site”，这些报表就会运行。 在页面导航栏能看到所有报表的链接。参见reporting元素--&gt;    </div><div class="line">   &lt;reporting&gt;    </div><div class="line">    ......    </div><div class="line">   &lt;/reporting&gt;    </div><div class="line">   &lt;!--参见dependencyManagement元素--&gt;    </div><div class="line">   &lt;dependencyManagement&gt;    </div><div class="line">    &lt;dependencies&gt;    </div><div class="line">     &lt;!--参见dependencies/dependency元素--&gt;    </div><div class="line">     &lt;dependency&gt;    </div><div class="line">      ......    </div><div class="line">     &lt;/dependency&gt;    </div><div class="line">    &lt;/dependencies&gt;    </div><div class="line">   &lt;/dependencyManagement&gt;    </div><div class="line">   &lt;!--参见distributionManagement元素--&gt;    </div><div class="line">   &lt;distributionManagement&gt;    </div><div class="line">    ......    </div><div class="line">   &lt;/distributionManagement&gt;    </div><div class="line">   &lt;!--参见properties元素--&gt;    </div><div class="line">   &lt;properties/&gt;    </div><div class="line">  &lt;/profile&gt;    </div><div class="line"> &lt;/profiles&gt;    </div><div class="line"> &lt;!--模块（有时称作子项目） 被构建成项目的一部分。列出的每个模块元素是指向该模块的目录的相对路径--&gt;    </div><div class="line"> &lt;modules/&gt;    </div><div class="line">    &lt;!--发现依赖和扩展的远程仓库列表。--&gt;     </div><div class="line">    &lt;repositories&gt;     </div><div class="line">     &lt;!--包含需要连接到远程仓库的信息--&gt;    </div><div class="line">        &lt;repository&gt;    </div><div class="line">         &lt;!--如何处理远程仓库里发布版本的下载--&gt;    </div><div class="line">         &lt;releases&gt;    </div><div class="line">          &lt;!--true或者false表示该仓库是否为下载某种类型构件（发布版，快照版）开启。 --&gt;    </div><div class="line">    &lt;enabled/&gt;    </div><div class="line">    &lt;!--该元素指定更新发生的频率。Maven会比较本地POM和远程POM的时间戳。这里的选项是：always（一直），daily（默认，每日），interval：X（这里X是以分钟为单位的时间间隔），或者never（从不）。--&gt;    </div><div class="line">    &lt;updatePolicy/&gt;    </div><div class="line">    &lt;!--当Maven验证构件校验文件失败时该怎么做：ignore（忽略），fail（失败），或者warn（警告）。--&gt;    </div><div class="line">    &lt;checksumPolicy/&gt;    </div><div class="line">   &lt;/releases&gt;    </div><div class="line">   &lt;!-- 如何处理远程仓库里快照版本的下载。有了releases和snapshots这两组配置，POM就可以在每个单独的仓库中，为每种类型的构件采取不同的 策略。例如，可能有人会决定只为开发目的开启对快照版本下载的支持。参见repositories/repository/releases元素 --&gt;    </div><div class="line">   &lt;snapshots&gt;    </div><div class="line">    &lt;enabled/&gt;&lt;updatePolicy/&gt;&lt;checksumPolicy/&gt;    </div><div class="line">   &lt;/snapshots&gt;    </div><div class="line">   &lt;!--远程仓库唯一标识符。可以用来匹配在settings.xml文件里配置的远程仓库--&gt;    </div><div class="line">   &lt;id&gt;banseon-repository-proxy&lt;/id&gt;     </div><div class="line">   &lt;!--远程仓库名称--&gt;    </div><div class="line">            &lt;name&gt;banseon-repository-proxy&lt;/name&gt;     </div><div class="line">            &lt;!--远程仓库URL，按protocol://hostname/path形式--&gt;    </div><div class="line">            &lt;url&gt;http://192.168.1.169:9999/repository/&lt;/url&gt;     </div><div class="line">            &lt;!-- 用于定位和排序构件的仓库布局类型-可以是default（默认）或者legacy（遗留）。Maven 2为其仓库提供了一个默认的布局；然 而，Maven 1.x有一种不同的布局。我们可以使用该元素指定布局是default（默认）还是legacy（遗留）。--&gt;    </div><div class="line">            &lt;layout&gt;default&lt;/layout&gt;               </div><div class="line">        &lt;/repository&gt;     </div><div class="line">    &lt;/repositories&gt;    </div><div class="line">    &lt;!--发现插件的远程仓库列表，这些插件用于构建和报表--&gt;    </div><div class="line">    &lt;pluginRepositories&gt;    </div><div class="line">     &lt;!--包含需要连接到远程插件仓库的信息.参见repositories/repository元素--&gt;    </div><div class="line">  &lt;pluginRepository&gt;    </div><div class="line">   ......    </div><div class="line">  &lt;/pluginRepository&gt;    </div><div class="line"> &lt;/pluginRepositories&gt;    </div><div class="line">       </div><div class="line">    &lt;!--该元素描述了项目相关的所有依赖。 这些依赖组成了项目构建过程中的一个个环节。它们自动从项目定义的仓库中下载。要获取更多信息，请看项目依赖机制。--&gt;     </div><div class="line">    &lt;dependencies&gt;     </div><div class="line">        &lt;dependency&gt;    </div><div class="line">   &lt;!--依赖的group ID--&gt;    </div><div class="line">            &lt;groupId&gt;org.apache.maven&lt;/groupId&gt;     </div><div class="line">            &lt;!--依赖的artifact ID--&gt;    </div><div class="line">            &lt;artifactId&gt;maven-artifact&lt;/artifactId&gt;     </div><div class="line">            &lt;!--依赖的版本号。 在Maven 2里, 也可以配置成版本号的范围。--&gt;    </div><div class="line">            &lt;version&gt;3.8.1&lt;/version&gt;     </div><div class="line">            &lt;!-- 依赖类型，默认类型是jar。它通常表示依赖的文件的扩展名，但也有例外。一个类型可以被映射成另外一个扩展名或分类器。类型经常和使用的打包方式对应， 尽管这也有例外。一些类型的例子：jar，war，ejb-client和test-jar。如果设置extensions为 true，就可以在 plugin里定义新的类型。所以前面的类型的例子不完整。--&gt;    </div><div class="line">            &lt;type&gt;jar&lt;/type&gt;    </div><div class="line">            &lt;!-- 依赖的分类器。分类器可以区分属于同一个POM，但不同构建方式的构件。分类器名被附加到文件名的版本号后面。例如，如果你想要构建两个单独的构件成 JAR，一个使用Java 1.4编译器，另一个使用Java 6编译器，你就可以使用分类器来生成两个单独的JAR构件。--&gt;    </div><div class="line">            &lt;classifier&gt;&lt;/classifier&gt;    </div><div class="line">            &lt;!--依赖范围。在项目发布过程中，帮助决定哪些构件被包括进来。欲知详情请参考依赖机制。    </div><div class="line">                - compile ：默认范围，用于编译      </div><div class="line">                - provided：类似于编译，但支持你期待jdk或者容器提供，类似于classpath      </div><div class="line">                - runtime: 在执行时需要使用      </div><div class="line">                - test:    用于test任务时使用      </div><div class="line">                - system: 需要外在提供相应的元素。通过systemPath来取得      </div><div class="line">                - systemPath: 仅用于范围为system。提供相应的路径      </div><div class="line">                - optional:   当项目自身被依赖时，标注依赖是否传递。用于连续依赖时使用--&gt;     </div><div class="line">            &lt;scope&gt;test&lt;/scope&gt;       </div><div class="line">            &lt;!--仅供system范围使用。注意，不鼓励使用这个元素，并且在新的版本中该元素可能被覆盖掉。该元素为依赖规定了文件系统上的路径。需要绝对路径而不是相对路径。推荐使用属性匹配绝对路径，例如$&#123;java.home&#125;。--&gt;    </div><div class="line">            &lt;systemPath&gt;&lt;/systemPath&gt;     </div><div class="line">            &lt;!--当计算传递依赖时， 从依赖构件列表里，列出被排除的依赖构件集。即告诉maven你只依赖指定的项目，不依赖项目的依赖。此元素主要用于解决版本冲突问题--&gt;    </div><div class="line">            &lt;exclusions&gt;    </div><div class="line">             &lt;exclusion&gt;     </div><div class="line">                    &lt;artifactId&gt;spring-core&lt;/artifactId&gt;     </div><div class="line">                    &lt;groupId&gt;org.springframework&lt;/groupId&gt;     </div><div class="line">                &lt;/exclusion&gt;     </div><div class="line">            &lt;/exclusions&gt;       </div><div class="line">            &lt;!--可选依赖，如果你在项目B中把C依赖声明为可选，你就需要在依赖于B的项目（例如项目A）中显式的引用对C的依赖。可选依赖阻断依赖的传递性。--&gt;     </div><div class="line">            &lt;optional&gt;true&lt;/optional&gt;    </div><div class="line">        &lt;/dependency&gt;    </div><div class="line">    &lt;/dependencies&gt;    </div><div class="line">    &lt;!--不赞成使用. 现在Maven忽略该元素.--&gt;    </div><div class="line">    &lt;reports&gt;&lt;/reports&gt;    </div><div class="line">    &lt;!--该元素描述使用报表插件产生报表的规范。当用户执行“mvn site”，这些报表就会运行。 在页面导航栏能看到所有报表的链接。--&gt;    </div><div class="line"> &lt;reporting&gt;    </div><div class="line">  &lt;!--true，则，网站不包括默认的报表。这包括“项目信息”菜单中的报表。--&gt;    </div><div class="line">  &lt;excludeDefaults/&gt;    </div><div class="line">  &lt;!--所有产生的报表存放到哪里。默认值是$&#123;project.build.directory&#125;/site。--&gt;    </div><div class="line">  &lt;outputDirectory/&gt;    </div><div class="line">  &lt;!--使用的报表插件和他们的配置。--&gt;    </div><div class="line">  &lt;plugins&gt;    </div><div class="line">   &lt;!--plugin元素包含描述报表插件需要的信息--&gt;    </div><div class="line">   &lt;plugin&gt;    </div><div class="line">    &lt;!--报表插件在仓库里的group ID--&gt;    </div><div class="line">    &lt;groupId/&gt;    </div><div class="line">    &lt;!--报表插件在仓库里的artifact ID--&gt;    </div><div class="line">    &lt;artifactId/&gt;    </div><div class="line">    &lt;!--被使用的报表插件的版本（或版本范围）--&gt;    </div><div class="line">    &lt;version/&gt;    </div><div class="line">    &lt;!--任何配置是否被传播到子项目--&gt;    </div><div class="line">    &lt;inherited/&gt;    </div><div class="line">    &lt;!--报表插件的配置--&gt;    </div><div class="line">    &lt;configuration/&gt;    </div><div class="line">    &lt;!--一组报表的多重规范，每个规范可能有不同的配置。一个规范（报表集）对应一个执行目标 。例如，有1，2，3，4，5，6，7，8，9个报表。1，2，5构成A报表集，对应一个执行目标。2，5，8构成B报表集，对应另一个执行目标--&gt;    </div><div class="line">    &lt;reportSets&gt;    </div><div class="line">     &lt;!--表示报表的一个集合，以及产生该集合的配置--&gt;    </div><div class="line">     &lt;reportSet&gt;    </div><div class="line">      &lt;!--报表集合的唯一标识符，POM继承时用到--&gt;    </div><div class="line">      &lt;id/&gt;    </div><div class="line">      &lt;!--产生报表集合时，被使用的报表的配置--&gt;    </div><div class="line">      &lt;configuration/&gt;    </div><div class="line">      &lt;!--配置是否被继承到子POMs--&gt;    </div><div class="line">      &lt;inherited/&gt;    </div><div class="line">      &lt;!--这个集合里使用到哪些报表--&gt;    </div><div class="line">      &lt;reports/&gt;    </div><div class="line">     &lt;/reportSet&gt;    </div><div class="line">    &lt;/reportSets&gt;    </div><div class="line">   &lt;/plugin&gt;    </div><div class="line">  &lt;/plugins&gt;    </div><div class="line"> &lt;/reporting&gt;    </div><div class="line"> &lt;!-- 继承自该项目的所有子项目的默认依赖信息。这部分的依赖信息不会被立即解析,而是当子项目声明一个依赖（必须描述group ID和 artifact ID信息），如果group ID和artifact ID以外的一些信息没有描述，则通过group ID和artifact ID 匹配到这里的依赖，并使用这里的依赖信息。--&gt;    </div><div class="line"> &lt;dependencyManagement&gt;    </div><div class="line">  &lt;dependencies&gt;    </div><div class="line">   &lt;!--参见dependencies/dependency元素--&gt;    </div><div class="line">   &lt;dependency&gt;    </div><div class="line">    ......    </div><div class="line">   &lt;/dependency&gt;    </div><div class="line">  &lt;/dependencies&gt;    </div><div class="line"> &lt;/dependencyManagement&gt;       </div><div class="line">    &lt;!--项目分发信息，在执行mvn deploy后表示要发布的位置。有了这些信息就可以把网站部署到远程服务器或者把构件部署到远程仓库。--&gt;     </div><div class="line">    &lt;distributionManagement&gt;    </div><div class="line">        &lt;!--部署项目产生的构件到远程仓库需要的信息--&gt;    </div><div class="line">        &lt;repository&gt;    </div><div class="line">         &lt;!--是分配给快照一个唯一的版本号（由时间戳和构建流水号）？还是每次都使用相同的版本号？参见repositories/repository元素--&gt;    </div><div class="line">   &lt;uniqueVersion/&gt;    </div><div class="line">   &lt;id&gt;banseon-maven2&lt;/id&gt;     </div><div class="line">   &lt;name&gt;banseon maven2&lt;/name&gt;     </div><div class="line">            &lt;url&gt;file://$&#123;basedir&#125;/target/deploy&lt;/url&gt;     </div><div class="line">            &lt;layout/&gt;    </div><div class="line">  &lt;/repository&gt;    </div><div class="line">  &lt;!--构件的快照部署到哪里？如果没有配置该元素，默认部署到repository元素配置的仓库，参见distributionManagement/repository元素--&gt;     </div><div class="line">  &lt;snapshotRepository&gt;    </div><div class="line">   &lt;uniqueVersion/&gt;    </div><div class="line">   &lt;id&gt;banseon-maven2&lt;/id&gt;    </div><div class="line">            &lt;name&gt;Banseon-maven2 Snapshot Repository&lt;/name&gt;    </div><div class="line">            &lt;url&gt;scp://svn.baidu.com/banseon:/usr/local/maven-snapshot&lt;/url&gt;     </div><div class="line">   &lt;layout/&gt;    </div><div class="line">  &lt;/snapshotRepository&gt;    </div><div class="line">  &lt;!--部署项目的网站需要的信息--&gt;     </div><div class="line">        &lt;site&gt;    </div><div class="line">         &lt;!--部署位置的唯一标识符，用来匹配站点和settings.xml文件里的配置--&gt;     </div><div class="line">            &lt;id&gt;banseon-site&lt;/id&gt;     </div><div class="line">            &lt;!--部署位置的名称--&gt;    </div><div class="line">            &lt;name&gt;business api website&lt;/name&gt;     </div><div class="line">            &lt;!--部署位置的URL，按protocol://hostname/path形式--&gt;    </div><div class="line">            &lt;url&gt;     </div><div class="line">                scp://svn.baidu.com/banseon:/var/www/localhost/banseon-web      </div><div class="line">            &lt;/url&gt;     </div><div class="line">        &lt;/site&gt;    </div><div class="line">  &lt;!--项目下载页面的URL。如果没有该元素，用户应该参考主页。使用该元素的原因是：帮助定位那些不在仓库里的构件（由于license限制）。--&gt;    </div><div class="line">  &lt;downloadUrl/&gt;    </div><div class="line">  &lt;!--如果构件有了新的group ID和artifact ID（构件移到了新的位置），这里列出构件的重定位信息。--&gt;    </div><div class="line">  &lt;relocation&gt;    </div><div class="line">   &lt;!--构件新的group ID--&gt;    </div><div class="line">   &lt;groupId/&gt;    </div><div class="line">   &lt;!--构件新的artifact ID--&gt;    </div><div class="line">   &lt;artifactId/&gt;    </div><div class="line">   &lt;!--构件新的版本号--&gt;    </div><div class="line">   &lt;version/&gt;    </div><div class="line">   &lt;!--显示给用户的，关于移动的额外信息，例如原因。--&gt;    </div><div class="line">   &lt;message/&gt;    </div><div class="line">  &lt;/relocation&gt;    </div><div class="line">  &lt;!-- 给出该构件在远程仓库的状态。不得在本地项目中设置该元素，因为这是工具自动更新的。有效的值有：none（默认），converted（仓库管理员从 Maven 1 POM转换过来），partner（直接从伙伴Maven 2仓库同步过来），deployed（从Maven 2实例部 署），verified（被核实时正确的和最终的）。--&gt;    </div><div class="line">  &lt;status/&gt;           </div><div class="line">    &lt;/distributionManagement&gt;    </div><div class="line">    &lt;!--以值替代名称，Properties可以在整个POM中使用，也可以作为触发条件（见settings.xml配置文件里activation元素的说明）。格式是&lt;name&gt;value&lt;/name&gt;。--&gt;    </div><div class="line">    &lt;properties/&gt;    </div><div class="line">&lt;/project&gt;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt; pom作为项目对象模型。通过xml表示maven项目，使用pom.xml来实现。主要描述了项目：包括配置文件；开发者需要遵循的规则，缺陷管理系统，组织和licenses，项目的url，项目的依赖性，以及其他所有的项目相关因素。&lt;br&gt;
    
    </summary>
    
      <category term="Maven" scheme="http://yoursite.com/categories/Maven/"/>
    
    
      <category term="Maven" scheme="http://yoursite.com/tags/Maven/"/>
    
  </entry>
  
  <entry>
    <title>Jar包添加到maven本地仓库</title>
    <link href="http://yoursite.com/2017/03/07/Jar%E5%8C%85%E6%B7%BB%E5%8A%A0%E5%88%B0maven%E6%9C%AC%E5%9C%B0%E4%BB%93%E5%BA%93/"/>
    <id>http://yoursite.com/2017/03/07/Jar包添加到maven本地仓库/</id>
    <published>2017-03-07T13:02:25.000Z</published>
    <updated>2017-09-28T08:10:04.299Z</updated>
    
    <content type="html"><![CDATA[<p> maven在应用的过程中，有 maven在应用的过程中，有些jar包在仓库上面是没法找到的，这需要我们自己手动导入到仓库中，些jar包在仓库上面是没法找到的，这需要我们自己手动导入到仓库中。</p><a id="more"></a><h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><p>zxing-3.21.jar是根据github上面项目<a href="https://github.com/zxing" target="_blank" rel="external">ZXing Project</a>自己生成的jar包，该包主要应用于二维码生成，下面讲述怎么把怎么把zxing-3.21.jar添加到本地的maven仓库中。</p><h3 id="环境要求"><a href="#环境要求" class="headerlink" title="环境要求"></a>环境要求</h3><p>需要配置JDK和maven环境，完成后以管理员身份打开命令提示符窗口(cmd),再输入下面相关的语法。</p><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">mvn install:install-file -Dfile=jar包的位置(参数一) -DgroupId=groupId(参数二) -DartifactId=artifactId(参数三) -Dversion=version(参数四) -Dpackaging=jar</div><div class="line"></div><div class="line">eg:</div><div class="line">mvn install:install-file -Dfile=&quot;C:\Users\eric\Desktop\zxing\3.21\zxing-3.21.jar&quot; -DgroupId=com.eric -DartifactId=zxing -Dversion=3.21 -Dpackaging=jar</div><div class="line"></div><div class="line">result：</div><div class="line">[INFO] Scanning for projects...</div><div class="line">[INFO]</div><div class="line">[INFO] ------------------------------------------------------------------------</div><div class="line">[INFO] Building Maven Stub Project (No POM) 1</div><div class="line">[INFO] ------------------------------------------------------------------------</div><div class="line">[INFO]</div><div class="line">[INFO] --- maven-install-plugin:2.4:install-file (default-cli) @ standalone-pom ---</div><div class="line">[INFO] Installing C:\Users\eric\Desktop\zxing\3.21\zxing-3.21.jar to C:\Users\eric\.m2\repository\com\eric\zxing\3.21\zxing-3.21.jar</div><div class="line">[INFO] Installing C:\Users\eric\AppData\Local\Temp\mvninstall6543969167446403883.pom to C:\Users\eric\.m2\repository\com\eric\zxing\3.21\zxing-3.21.pom</div><div class="line">[INFO] ------------------------------------------------------------------------</div><div class="line">[INFO] BUILD SUCCESS</div><div class="line">[INFO] ------------------------------------------------------------------------</div><div class="line">[INFO] Total time: 0.836 s</div><div class="line">[INFO] Finished at: 2017-03-08T00:24:12+08:00</div><div class="line">[INFO] Final Memory: 7M/117M</div><div class="line">[INFO] ------------------------------------------------------------------------</div><div class="line">(添加成功！)</div></pre></td></tr></table></figure><p><strong>注意：地址+jar包名,即C:\Users\eric\Desktop\zxing\3.21\zxing-3.21.jar要加引号””,”参数二\参数三\参数四”这也是jar包在仓库中的地址。</strong></p><h3 id="查看生成的依赖"><a href="#查看生成的依赖" class="headerlink" title="查看生成的依赖"></a>查看生成的依赖</h3><p>查看添加的zxing-3.21.jar的dependency</p><ul><li>通过设置的对应参数获取.即</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">-DgroupId=groupId(参数二) -DartifactId=artifactId(参数三) -Dversion=version(参数四)</div></pre></td></tr></table></figure><ul><li>参看本地仓库中pom文件C:\Users\eric.m2\repository\com\eric\zxing\3.21\zxing-3.21.pom，可以看到:</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;groupId&gt;com.eric&lt;/groupId&gt;</div><div class="line">&lt;artifactId&gt;zxing&lt;/artifactId&gt;</div><div class="line">&lt;version&gt;3.21&lt;/version&gt;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt; maven在应用的过程中，有 maven在应用的过程中，有些jar包在仓库上面是没法找到的，这需要我们自己手动导入到仓库中，些jar包在仓库上面是没法找到的，这需要我们自己手动导入到仓库中。&lt;/p&gt;
    
    </summary>
    
      <category term="Maven" scheme="http://yoursite.com/categories/Maven/"/>
    
    
      <category term="Maven" scheme="http://yoursite.com/tags/Maven/"/>
    
  </entry>
  
  <entry>
    <title>Redis数据类型--SortedSet（有序集合）</title>
    <link href="http://yoursite.com/2017/03/06/Redis%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B--SortedSet%EF%BC%88%E6%9C%89%E5%BA%8F%E9%9B%86%E5%90%88%EF%BC%89/"/>
    <id>http://yoursite.com/2017/03/06/Redis数据类型--SortedSet（有序集合）/</id>
    <published>2017-03-06T13:02:25.000Z</published>
    <updated>2017-09-28T09:35:43.367Z</updated>
    
    <content type="html"><![CDATA[<p>有序集合和散列一样，都用于存储键值对：有序集合的键被称为成员（member），每个成员都是各不相同；而有序集合的值则被称为分值（score），分值必须为浮点数。有序集合是Redis里面唯一一个既可以根据成员访问元素（这一点和散列一样），又可以根据分值以及分值的排列顺序来访问元素的结构。字符串成员（member）与浮点数分值（score）之间的有序映射，元素的排列顺序由分值的大小决定。<br>结构的读写：<br> 添加、获取、删除单个元素<br> 根据分值范围（range）或者成员来获取元素<br><a id="more"></a></p><h3 id="ZADD"><a href="#ZADD" class="headerlink" title="ZADD"></a><strong>ZADD</strong></h3><p><strong>ZADD key score member [[score member] [score member] …]</strong></p><p> 将一个或多个 member 元素及其 score 值加入到有序集 key 当中。<br> 如果某个 member 已经是有序集的成员，那么更新这个 member 的 score 值，并通过重新插入这个 member 元素，来保证该 member 在正确的位置上。<br> score 值可以是整数值或双精度浮点数。<br> 如果 key 不存在，则创建一个空的有序集并执行 ZADD 操作。<br> 当 key 存在但不是有序集类型时，返回一个错误。<br> 在 Redis 2.4 版本以前， ZADD 每次只能添加一个元素。</p><h4 id="可用版本"><a href="#可用版本" class="headerlink" title="可用版本"></a>可用版本</h4><p>版本&gt;= 1.2.0</p><h4 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><p>O(M*log(N))， N 是有序集的基数， M 为成功添加的新成员的数量。</p><h4 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h4><p>被成功添加的新成员的数量，不包括那些被更新的、已经存在的成员。</p><h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"># 添加单个元素</div><div class="line">redis&gt; ZADD page_rank 10 google.com</div><div class="line">(integer) 1</div><div class="line"># 添加多个元素</div><div class="line">redis&gt; ZADD page_rank 9 baidu.com 8 bing.com</div><div class="line">(integer) 2</div><div class="line">redis&gt; ZRANGE page_rank 0 -1 WITHSCORES</div><div class="line">1) &quot;bing.com&quot;</div><div class="line">2) &quot;8&quot;</div><div class="line">3) &quot;baidu.com&quot;</div><div class="line">4) &quot;9&quot;</div><div class="line">5) &quot;google.com&quot;</div><div class="line">6) &quot;10&quot;</div><div class="line"># 添加已存在元素，且 score 值不变</div><div class="line">redis&gt; ZADD page_rank 10 google.com</div><div class="line">(integer) 0</div><div class="line">redis&gt; ZRANGE page_rank 0 -1 WITHSCORES  # 没有改变</div><div class="line">1) &quot;bing.com&quot;</div><div class="line">2) &quot;8&quot;</div><div class="line">3) &quot;baidu.com&quot;</div><div class="line">4) &quot;9&quot;</div><div class="line">5) &quot;google.com&quot;</div><div class="line">6) &quot;10&quot;</div><div class="line"># 添加已存在元素，但是改变 score 值</div><div class="line">redis&gt; ZADD page_rank 6 bing.com</div><div class="line">(integer) 0</div><div class="line">redis&gt; ZRANGE page_rank 0 -1 WITHSCORES  # bing.com 元素的 score 值被改变</div><div class="line">1) &quot;bing.com&quot;</div><div class="line">2) &quot;6&quot;</div><div class="line">3) &quot;baidu.com&quot;</div><div class="line">4) &quot;9&quot;</div><div class="line">5) &quot;google.com&quot;</div><div class="line">6) &quot;10&quot;</div></pre></td></tr></table></figure><h3 id="ZCARD"><a href="#ZCARD" class="headerlink" title="ZCARD"></a><strong>ZCARD</strong></h3><p><strong>ZCARD key</strong></p><p> 返回有序集 key 的基数。</p><h4 id="可用版本-1"><a href="#可用版本-1" class="headerlink" title="可用版本"></a>可用版本</h4><p>版本&gt;= 1.2.0</p><h4 id="时间复杂度-1"><a href="#时间复杂度-1" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><p>O(1)</p><h4 id="返回值-1"><a href="#返回值-1" class="headerlink" title="返回值"></a>返回值</h4><p>当 key 存在且是有序集类型时，返回有序集的基数。<br>当 key 不存在时，返回 0 。</p><h4 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">redis &gt; ZADD salary 2000 tom    # 添加一个成员</div><div class="line">(integer) 1</div><div class="line">redis &gt; ZCARD salary</div><div class="line">(integer) 1</div><div class="line">redis &gt; ZADD salary 5000 jack   # 再添加一个成员</div><div class="line">(integer) 1</div><div class="line">redis &gt; ZCARD salary</div><div class="line">(integer) 2</div><div class="line">redis &gt; EXISTS non_exists_key   # 对不存在的 key 进行 ZCARD 操作</div><div class="line">(integer) 0</div><div class="line">redis &gt; ZCARD non_exists_key</div><div class="line">(integer) 0</div></pre></td></tr></table></figure><h3 id="ZCOUNT"><a href="#ZCOUNT" class="headerlink" title="ZCOUNT"></a><strong>ZCOUNT</strong></h3><p><strong>ZCOUNT key min max</strong></p><p> 返回有序集 key 中， score 值在 min 和 max 之间(默认包括 score 值等于 min 或 max )的成员的数量。</p><h4 id="可用版本-2"><a href="#可用版本-2" class="headerlink" title="可用版本"></a>可用版本</h4><p>版本&gt;= 2.0.0</p><h4 id="时间复杂度-2"><a href="#时间复杂度-2" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><p>O(log(N)+M)， N 为有序集的基数， M 为值在 min 和 max 之间的元素的数量。</p><h4 id="返回值-2"><a href="#返回值-2" class="headerlink" title="返回值"></a>返回值</h4><p>score 值在 min 和 max 之间的成员的数量。</p><h4 id="示例-2"><a href="#示例-2" class="headerlink" title="示例"></a>示例</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">redis&gt; ZRANGE salary 0 -1 WITHSCORES    # 测试数据</div><div class="line">1) &quot;jack&quot;</div><div class="line">2) &quot;2000&quot;</div><div class="line">3) &quot;peter&quot;</div><div class="line">4) &quot;3500&quot;</div><div class="line">5) &quot;tom&quot;</div><div class="line">6) &quot;5000&quot;</div><div class="line">redis&gt; ZCOUNT salary 2000 5000          # 计算薪水在 2000-5000 之间的人数</div><div class="line">(integer) 3</div><div class="line">redis&gt; ZCOUNT salary 3000 5000          # 计算薪水在 3000-5000 之间的人数</div><div class="line">(integer) 2</div></pre></td></tr></table></figure><h3 id="ZINCRBY"><a href="#ZINCRBY" class="headerlink" title="ZINCRBY"></a><strong>ZINCRBY</strong></h3><p><strong>ZINCRBY key increment member</strong></p><p> 为有序集 key 的成员 member 的 score 值加上增量 increment 。<br> 可以通过传递一个负数值 increment ，让 score 减去相应的值，比如 ZINCRBY key -5 member ，就是让 member 的 score 值减去 5 。<br> 当 key 不存在，或 member 不是 key 的成员时， ZINCRBY key increment member 等同于 ZADD key increment member 。<br> 当 key 不是有序集类型时，返回一个错误。<br> score 值可以是整数值或双精度浮点数。</p><h4 id="可用版本-3"><a href="#可用版本-3" class="headerlink" title="可用版本"></a>可用版本</h4><p>版本&gt;= 1.2.0</p><h4 id="时间复杂度-3"><a href="#时间复杂度-3" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><p>O(log(N))</p><h4 id="返回值-3"><a href="#返回值-3" class="headerlink" title="返回值"></a>返回值</h4><p>member 成员的新 score 值，以字符串形式表示。</p><h4 id="示例-3"><a href="#示例-3" class="headerlink" title="示例"></a>示例</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">redis&gt; ZSCORE salary tom</div><div class="line">&quot;2000&quot;</div><div class="line">redis&gt; ZINCRBY salary 2000 tom   # tom 加薪啦！</div><div class="line">&quot;4000&quot;</div></pre></td></tr></table></figure><h3 id="ZRANGE"><a href="#ZRANGE" class="headerlink" title="ZRANGE"></a><strong>ZRANGE</strong></h3><p><strong>ZRANGE key start stop [WITHSCORES]</strong></p><p> 返回有序集 key 中，指定区间内的成员。<br> 其中成员的位置按 score 值递增(从小到大)来排序。<br> 具有相同 score 值的成员按字典序(lexicographical order )来排列。<br> 如果你需要成员按 score 值递减(从大到小)来排列，请使用 ZREVRANGE 命令。<br> 下标参数 start 和 stop 都以 0 为底，也就是说，以 0 表示有序集第一个成员，以 1 表示有序集第二个成员，以此类推。<br>你也可以使用负数下标，以 -1 表示最后一个成员， -2 表示倒数第二个成员，以此类推。<br> 超出范围的下标并不会引起错误。</p><ul><li>比如说，当 start 的值比有序集的最大下标还要大，或是 start &gt; stop 时， ZRANGE 命令只是简单地返回一个空列表。</li><li>另一方面，假如 stop 参数的值比有序集的最大下标还要大，那么 Redis 将 stop 当作最大下标来处理。</li></ul><p> 可以通过使用 WITHSCORES 选项，来让成员和它的 score 值一并返回，返回列表以 value1,score1, …, valueN,scoreN 的格式表示。<br> 客户端库可能会返回一些更复杂的数据类型，比如数组、元组等。</p><h4 id="可用版本-4"><a href="#可用版本-4" class="headerlink" title="可用版本"></a>可用版本</h4><p>版本&gt;= 1.2.0</p><h4 id="时间复杂度-4"><a href="#时间复杂度-4" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><p>O(log(N)+M)， N 为有序集的基数，而 M 为结果集的基数。</p><h4 id="返回值-4"><a href="#返回值-4" class="headerlink" title="返回值"></a>返回值</h4><p>指定区间内，带有 score 值(可选)的有序集成员的列表。</p><h4 id="示例-4"><a href="#示例-4" class="headerlink" title="示例"></a>示例</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">redis &gt; ZRANGE salary 0 -1 WITHSCORES             # 显示整个有序集成员</div><div class="line">1) &quot;jack&quot;</div><div class="line">2) &quot;3500&quot;</div><div class="line">3) &quot;tom&quot;</div><div class="line">4) &quot;5000&quot;</div><div class="line">5) &quot;boss&quot;</div><div class="line">6) &quot;10086&quot;</div><div class="line">redis &gt; ZRANGE salary 1 2 WITHSCORES              # 显示有序集下标区间 1 至 2 的成员</div><div class="line">1) &quot;tom&quot;</div><div class="line">2) &quot;5000&quot;</div><div class="line">3) &quot;boss&quot;</div><div class="line">4) &quot;10086&quot;</div><div class="line">redis &gt; ZRANGE salary 0 200000 WITHSCORES         # 测试 end 下标超出最大下标时的情况</div><div class="line">1) &quot;jack&quot;</div><div class="line">2) &quot;3500&quot;</div><div class="line">3) &quot;tom&quot;</div><div class="line">4) &quot;5000&quot;</div><div class="line">5) &quot;boss&quot;</div><div class="line">6) &quot;10086&quot;</div><div class="line">redis &gt; ZRANGE salary 200000 3000000 WITHSCORES   # 测试当给定区间不存在于有序集时的情况</div><div class="line">(empty list or set)</div></pre></td></tr></table></figure><h3 id="ZRANGEBYSCORE"><a href="#ZRANGEBYSCORE" class="headerlink" title="ZRANGEBYSCORE"></a><strong>ZRANGEBYSCORE</strong></h3><p><strong>ZRANGEBYSCORE key min max [WITHSCORES] [LIMIT offset count]</strong></p><p> 返回有序集 key 中，所有 score 值介于 min 和 max 之间(包括等于 min 或 max )的成员。有序集成员按 score 值递增(从小到大)次序排列。<br> 具有相同 score 值的成员按字典序(lexicographical order)来排列(该属性是有序集提供的，不需要额外的计算)。<br> 可选的 LIMIT 参数指定返回结果的数量及区间(就像SQL中的 SELECT LIMIT offset, count )，注意当 offset 很大时，定位 offset 的操作可能需要遍历整个有序集，此过程最坏复杂度为 O(N) 时间。<br> 可选的 WITHSCORES 参数决定结果集是单单返回有序集的成员，还是将有序集成员及其 score 值一起返回。<br> 该选项自 Redis 2.0 版本起可用。</p><p><strong>区间及无限</strong></p><p> min 和 max 可以是 -inf 和 +inf ，这样一来，你就可以在不知道有序集的最低和最高 score 值的情况下，使用 ZRANGEBYSCORE 这类命令。<br> 默认情况下，区间的取值使用闭区间 (小于等于或大于等于)，你也可以通过给参数前增加 ( 符号来使用可选的开区间 (小于或大于)。</p><p><strong>举个例子</strong></p><p> ZRANGEBYSCORE zset (1 5  返回所有符合条件 1 &lt; score &lt;= 5 的成员，而<br> ZRANGEBYSCORE zset (5 (10 则返回所有符合条件 5 &lt; score &lt; 10 的成员。</p><h4 id="可用版本-5"><a href="#可用版本-5" class="headerlink" title="可用版本"></a>可用版本</h4><p>版本&gt;= 1.0.5</p><h4 id="时间复杂度-5"><a href="#时间复杂度-5" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><p>O(log(N)+M)， N 为有序集的基数， M 为被结果集的基数。</p><h4 id="返回值-5"><a href="#返回值-5" class="headerlink" title="返回值"></a>返回值</h4><p>指定区间内，带有 score 值(可选)的有序集成员的列表。</p><h4 id="示例-5"><a href="#示例-5" class="headerlink" title="示例"></a>示例</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">redis&gt; ZADD salary 2500 jack                        # 测试数据</div><div class="line">(integer) 0</div><div class="line">redis&gt; ZADD salary 5000 tom</div><div class="line">(integer) 0</div><div class="line">redis&gt; ZADD salary 12000 peter</div><div class="line">(integer) 0</div><div class="line">redis&gt; ZRANGEBYSCORE salary -inf +inf               # 显示整个有序集</div><div class="line">1) &quot;jack&quot;</div><div class="line">2) &quot;tom&quot;</div><div class="line">3) &quot;peter&quot;</div><div class="line">redis&gt; ZRANGEBYSCORE salary -inf +inf WITHSCORES    # 显示整个有序集及成员的 score 值</div><div class="line">1) &quot;jack&quot;</div><div class="line">2) &quot;2500&quot;</div><div class="line">3) &quot;tom&quot;</div><div class="line">4) &quot;5000&quot;</div><div class="line">5) &quot;peter&quot;</div><div class="line">6) &quot;12000&quot;</div><div class="line">redis&gt; ZRANGEBYSCORE salary -inf 5000 WITHSCORES    # 显示工资 &lt;=5000 的所有成员</div><div class="line">1) &quot;jack&quot;</div><div class="line">2) &quot;2500&quot;</div><div class="line">3) &quot;tom&quot;</div><div class="line">4) &quot;5000&quot;</div><div class="line">redis&gt; ZRANGEBYSCORE salary (5000 400000            # 显示工资大于 5000 小于等于 400000 的成员</div><div class="line">1) &quot;peter&quot;</div></pre></td></tr></table></figure><h3 id="ZRANK"><a href="#ZRANK" class="headerlink" title="ZRANK"></a><strong>ZRANK</strong></h3><p><strong>ZRANK key member</strong></p><p> 返回有序集 key 中成员 member 的排名。其中有序集成员按 score 值递增(从小到大)顺序排列。<br> 排名以 0 为底，也就是说， score 值最小的成员排名为 0 。<br> 使用 ZREVRANK 命令可以获得成员按 score 值递减(从大到小)排列的排名。</p><h4 id="可用版本-6"><a href="#可用版本-6" class="headerlink" title="可用版本"></a>可用版本</h4><p>版本&gt;= 2.0.0</p><h4 id="时间复杂度-6"><a href="#时间复杂度-6" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><p>O(log(N))</p><h4 id="返回值-6"><a href="#返回值-6" class="headerlink" title="返回值"></a>返回值</h4><p>如果 member 是有序集 key 的成员，返回 member 的排名。<br>如果 member 不是有序集 key 的成员，返回 nil 。</p><h4 id="示例-6"><a href="#示例-6" class="headerlink" title="示例"></a>示例</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">redis&gt; ZRANGE salary 0 -1 WITHSCORES        # 显示所有成员及其 score 值</div><div class="line">1) &quot;peter&quot;</div><div class="line">2) &quot;3500&quot;</div><div class="line">3) &quot;tom&quot;</div><div class="line">4) &quot;4000&quot;</div><div class="line">5) &quot;jack&quot;</div><div class="line">6) &quot;5000&quot;</div><div class="line">redis&gt; ZRANK salary tom                     # 显示 tom 的薪水排名，第二</div><div class="line">(integer) 1</div></pre></td></tr></table></figure><h3 id="ZREM"><a href="#ZREM" class="headerlink" title="ZREM"></a><strong>ZREM</strong></h3><p><strong>ZREM key member [member …]</strong></p><p> 移除有序集 key 中的一个或多个成员，不存在的成员将被忽略。<br> 当 key 存在但不是有序集类型时，返回一个错误。<br> 在 Redis 2.4 版本以前， ZREM 每次只能删除一个元素。</p><h4 id="可用版本-7"><a href="#可用版本-7" class="headerlink" title="可用版本"></a>可用版本</h4><blockquote><p>= 1.2.0</p><h4 id="时间复杂度-7"><a href="#时间复杂度-7" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><p>O(M*log(N))， N 为有序集的基数， M 为被成功移除的成员的数量。</p><h4 id="返回值-7"><a href="#返回值-7" class="headerlink" title="返回值"></a>返回值</h4><p>被成功移除的成员的数量，不包括被忽略的成员。</p><h4 id="示例-7"><a href="#示例-7" class="headerlink" title="示例"></a>示例</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"># 测试数据</div><div class="line">redis&gt; ZRANGE page_rank 0 -1 WITHSCORES</div><div class="line">1) &quot;bing.com&quot;</div><div class="line">2) &quot;8&quot;</div><div class="line">3) &quot;baidu.com&quot;</div><div class="line">4) &quot;9&quot;</div><div class="line">5) &quot;google.com&quot;</div><div class="line">6) &quot;10&quot;</div><div class="line"># 移除单个元素</div><div class="line">redis&gt; ZREM page_rank google.com</div><div class="line">(integer) 1</div><div class="line">redis&gt; ZRANGE page_rank 0 -1 WITHSCORES</div><div class="line">1) &quot;bing.com&quot;</div><div class="line">2) &quot;8&quot;</div><div class="line">3) &quot;baidu.com&quot;</div><div class="line">4) &quot;9&quot;</div><div class="line"># 移除多个元素</div><div class="line">redis&gt; ZREM page_rank baidu.com bing.com</div><div class="line">(integer) 2</div><div class="line">redis&gt; ZRANGE page_rank 0 -1 WITHSCORES</div><div class="line">(empty list or set)</div><div class="line"># 移除不存在元素</div><div class="line">redis&gt; ZREM page_rank non-exists-element</div><div class="line">(integer) 0</div></pre></td></tr></table></figure></blockquote><h3 id="ZREMRANGEBYRANK"><a href="#ZREMRANGEBYRANK" class="headerlink" title="ZREMRANGEBYRANK"></a><strong>ZREMRANGEBYRANK</strong></h3><p><strong>ZREMRANGEBYRANK key start stop</strong></p><p> 移除有序集 key 中，指定排名(rank)区间内的所有成员。<br> 区间分别以下标参数 start 和 stop 指出，包含 start 和 stop 在内。<br> 下标参数 start 和 stop 都以 0 为底，也就是说，以 0 表示有序集第一个成员，以 1 表示有序集第二个成员，以此类推。<br> 你也可以使用负数下标，以 -1 表示最后一个成员， -2 表示倒数第二个成员，以此类推。</p><h4 id="可用版本-8"><a href="#可用版本-8" class="headerlink" title="可用版本"></a>可用版本</h4><p>版本&gt;= 2.0.0</p><h4 id="时间复杂度-8"><a href="#时间复杂度-8" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><p>O(log(N)+M)， N 为有序集的基数，而 M 为被移除成员的数量。</p><h4 id="返回值-8"><a href="#返回值-8" class="headerlink" title="返回值"></a>返回值</h4><p>被移除成员的数量。</p><h4 id="示例-8"><a href="#示例-8" class="headerlink" title="示例"></a>示例</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">redis&gt; ZADD salary 2000 jack</div><div class="line">(integer) 1</div><div class="line">redis&gt; ZADD salary 5000 tom</div><div class="line">(integer) 1</div><div class="line">redis&gt; ZADD salary 3500 peter</div><div class="line">(integer) 1</div><div class="line">redis&gt; ZREMRANGEBYRANK salary 0 1       # 移除下标 0 至 1 区间内的成员</div><div class="line">(integer) 2</div><div class="line">redis&gt; ZRANGE salary 0 -1 WITHSCORES    # 有序集只剩下一个成员</div><div class="line">1) &quot;tom&quot;</div><div class="line">2) &quot;5000&quot;</div></pre></td></tr></table></figure><h3 id="ZREMRANGEBYSCORE"><a href="#ZREMRANGEBYSCORE" class="headerlink" title="ZREMRANGEBYSCORE"></a><strong>ZREMRANGEBYSCORE</strong></h3><p><strong>ZREMRANGEBYSCORE key min max</strong></p><p> 移除有序集 key 中，所有 score 值介于 min 和 max 之间(包括等于 min 或 max )的成员。<br> 自版本2.1.6开始， score 值等于 min 或 max 的成员也可以不包括在内，详情请参见 ZRANGEBYSCORE 命令。</p><h4 id="可用版本-9"><a href="#可用版本-9" class="headerlink" title="可用版本"></a>可用版本</h4><p>版本&gt;= 1.2.0</p><h4 id="时间复杂度-9"><a href="#时间复杂度-9" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><p>O(log(N)+M)， N 为有序集的基数，而 M 为被移除成员的数量。</p><h4 id="返回值-9"><a href="#返回值-9" class="headerlink" title="返回值"></a>返回值</h4><p>被移除成员的数量。</p><h4 id="示例-9"><a href="#示例-9" class="headerlink" title="示例"></a>示例</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">redis&gt; ZRANGE salary 0 -1 WITHSCORES          # 显示有序集内所有成员及其 score 值</div><div class="line">1) &quot;tom&quot;</div><div class="line">2) &quot;2000&quot;</div><div class="line">3) &quot;peter&quot;</div><div class="line">4) &quot;3500&quot;</div><div class="line">5) &quot;jack&quot;</div><div class="line">6) &quot;5000&quot;</div><div class="line">redis&gt; ZREMRANGEBYSCORE salary 1500 3500      # 移除所有薪水在 1500 到 3500 内的员工</div><div class="line">(integer) 2</div><div class="line">redis&gt; ZRANGE salary 0 -1 WITHSCORES          # 剩下的有序集成员</div><div class="line">1) &quot;jack&quot;</div><div class="line">2) &quot;5000&quot;</div></pre></td></tr></table></figure><h3 id="ZREVRANGE"><a href="#ZREVRANGE" class="headerlink" title="ZREVRANGE"></a><strong>ZREVRANGE</strong></h3><p><strong>ZREVRANGE key start stop [WITHSCORES]</strong></p><p> 返回有序集 key 中，指定区间内的成员。<br> 其中成员的位置按 score 值递减(从大到小)来排列。<br> 具有相同 score 值的成员按字典序的逆序(reverse lexicographical order)排列。<br> 除了成员按 score 值递减的次序排列这一点外， ZREVRANGE 命令的其他方面和 ZRANGE 命令一样。</p><h4 id="可用版本-10"><a href="#可用版本-10" class="headerlink" title="可用版本"></a>可用版本</h4><p>版本&gt;= 1.2.0</p><h4 id="时间复杂度-10"><a href="#时间复杂度-10" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><p>O(log(N)+M)， N 为有序集的基数，而 M 为结果集的基数。</p><h4 id="返回值-10"><a href="#返回值-10" class="headerlink" title="返回值"></a>返回值</h4><p>指定区间内，带有 score 值(可选)的有序集成员的列表。</p><h4 id="示例-10"><a href="#示例-10" class="headerlink" title="示例"></a>示例</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">redis&gt; ZRANGE salary 0 -1 WITHSCORES        # 递增排列</div><div class="line">1) &quot;peter&quot;</div><div class="line">2) &quot;3500&quot;</div><div class="line">3) &quot;tom&quot;</div><div class="line">4) &quot;4000&quot;</div><div class="line">5) &quot;jack&quot;</div><div class="line">6) &quot;5000&quot;</div><div class="line">redis&gt; ZREVRANGE salary 0 -1 WITHSCORES     # 递减排列</div><div class="line">1) &quot;jack&quot;</div><div class="line">2) &quot;5000&quot;</div><div class="line">3) &quot;tom&quot;</div><div class="line">4) &quot;4000&quot;</div><div class="line">5) &quot;peter&quot;</div><div class="line">6) &quot;3500&quot;</div></pre></td></tr></table></figure><h3 id="ZREVRANGEBYSCORE"><a href="#ZREVRANGEBYSCORE" class="headerlink" title="ZREVRANGEBYSCORE"></a><strong>ZREVRANGEBYSCORE</strong></h3><p><strong>ZREVRANGEBYSCORE key max min [WITHSCORES] [LIMIT offset count]</strong></p><p> 返回有序集 key 中， score 值介于 max 和 min 之间(默认包括等于 max 或 min )的所有的成员。有序集成员按 score 值递减(从大到小)的次序排列。<br> 具有相同 score 值的成员按字典序的逆序(reverse lexicographical order )排列。<br> 除了成员按 score 值递减的次序排列这一点外， ZREVRANGEBYSCORE 命令的其他方面和 ZRANGEBYSCORE 命令一样。</p><h4 id="可用版本-11"><a href="#可用版本-11" class="headerlink" title="可用版本"></a>可用版本</h4><p>版本&gt;= 2.2.0</p><h4 id="时间复杂度-11"><a href="#时间复杂度-11" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><p>O(log(N)+M)， N 为有序集的基数， M 为结果集的基数。</p><h4 id="返回值-11"><a href="#返回值-11" class="headerlink" title="返回值"></a>返回值</h4><p>指定区间内，带有 score 值(可选)的有序集成员的列表。</p><h4 id="示例-11"><a href="#示例-11" class="headerlink" title="示例"></a>示例</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">redis &gt; ZADD salary 10086 jack</div><div class="line">(integer) 1</div><div class="line">redis &gt; ZADD salary 5000 tom</div><div class="line">(integer) 1</div><div class="line">redis &gt; ZADD salary 7500 peter</div><div class="line">(integer) 1</div><div class="line">redis &gt; ZADD salary 3500 joe</div><div class="line">(integer) 1</div><div class="line">redis &gt; ZREVRANGEBYSCORE salary +inf -inf   # 逆序排列所有成员</div><div class="line">1) &quot;jack&quot;</div><div class="line">2) &quot;peter&quot;</div><div class="line">3) &quot;tom&quot;</div><div class="line">4) &quot;joe&quot;</div><div class="line">redis &gt; ZREVRANGEBYSCORE salary 10000 2000  # 逆序排列薪水介于 10000 和 2000 之间的成员</div><div class="line">1) &quot;peter&quot;</div><div class="line">2) &quot;tom&quot;</div><div class="line">3) &quot;joe&quot;</div></pre></td></tr></table></figure><h3 id="ZREVRANK"><a href="#ZREVRANK" class="headerlink" title="ZREVRANK"></a><strong>ZREVRANK</strong></h3><p><strong>ZREVRANK key member</strong></p><p> 返回有序集 key 中成员 member 的排名。其中有序集成员按 score 值递减(从大到小)排序。<br> 排名以 0 为底，也就是说， score 值最大的成员排名为 0 。<br> 使用 ZRANK 命令可以获得成员按 score 值递增(从小到大)排列的排名。</p><h4 id="可用版本-12"><a href="#可用版本-12" class="headerlink" title="可用版本"></a>可用版本</h4><p>版本&gt;= 2.0.0</p><h4 id="时间复杂度-12"><a href="#时间复杂度-12" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><p>O(log(N))</p><h4 id="返回值-12"><a href="#返回值-12" class="headerlink" title="返回值"></a>返回值</h4><p>如果 member 是有序集 key 的成员，返回 member 的排名。<br>如果 member 不是有序集 key 的成员，返回 nil 。</p><h4 id="示例-12"><a href="#示例-12" class="headerlink" title="示例"></a>示例</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">redis 127.0.0.1:6379&gt; ZRANGE salary 0 -1 WITHSCORES     # 测试数据</div><div class="line">1) &quot;jack&quot;</div><div class="line">2) &quot;2000&quot;</div><div class="line">3) &quot;peter&quot;</div><div class="line">4) &quot;3500&quot;</div><div class="line">5) &quot;tom&quot;</div><div class="line">6) &quot;5000&quot;</div><div class="line">redis&gt; ZREVRANK salary peter     # peter 的工资排第二</div><div class="line">(integer) 1</div><div class="line">redis&gt; ZREVRANK salary tom       # tom 的工资最高</div><div class="line">(integer) 0</div></pre></td></tr></table></figure><h3 id="ZSCORE"><a href="#ZSCORE" class="headerlink" title="ZSCORE"></a><strong>ZSCORE</strong></h3><p><strong>ZSCORE key member</strong></p><p> 返回有序集 key 中，成员 member 的 score 值。<br> 如果 member 元素不是有序集 key 的成员，或 key 不存在，返回 nil 。</p><h4 id="可用版本-13"><a href="#可用版本-13" class="headerlink" title="可用版本"></a>可用版本</h4><p>版本&gt;= 1.2.0</p><h4 id="时间复杂度-13"><a href="#时间复杂度-13" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><p>O(1)</p><h4 id="返回值-13"><a href="#返回值-13" class="headerlink" title="返回值"></a>返回值</h4><p>member 成员的 score 值，以字符串形式表示。</p><h4 id="示例-13"><a href="#示例-13" class="headerlink" title="示例"></a>示例</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">redis&gt; ZRANGE salary 0 -1 WITHSCORES    # 测试数据</div><div class="line">1) &quot;tom&quot;</div><div class="line">2) &quot;2000&quot;</div><div class="line">3) &quot;peter&quot;</div><div class="line">4) &quot;3500&quot;</div><div class="line">5) &quot;jack&quot;</div><div class="line">6) &quot;5000&quot;</div><div class="line">redis&gt; ZSCORE salary peter              # 注意返回值是字符串</div><div class="line">&quot;3500&quot;</div></pre></td></tr></table></figure><h3 id="ZUNIONSTORE"><a href="#ZUNIONSTORE" class="headerlink" title="ZUNIONSTORE"></a><strong>ZUNIONSTORE</strong></h3><p><strong>ZUNIONSTORE destination numkeys key [key …] [WEIGHTS weight [weight …]] [AGGREGATE SUM|MIN|MAX]</strong></p><p> 计算给定的一个或多个有序集的并集，其中给定 key 的数量必须以 numkeys 参数指定，并将该并集(结果集)储存到 destination 。<br> 默认情况下，结果集中某个成员的 score 值是所有给定集下该成员 score 值之 和 。</p><p><strong>WEIGHTS</strong></p><p> 使用 WEIGHTS 选项，你可以为 每个 给定有序集 分别 指定一个乘法因子(multiplication factor)，每个给定有序集的所有成员的 score 值在传递给聚合函数(aggregation function)之前都要先乘以该有序集的因子。<br> 如果没有指定 WEIGHTS 选项，乘法因子默认设置为 1 。</p><p><strong>AGGREGATE</strong></p><p> 使用 AGGREGATE 选项，你可以指定并集的结果集的聚合方式。<br> 默认使用的参数 SUM ，可以将所有集合中某个成员的 score 值之 和 作为结果集中该成员的 score 值；使用参数 MIN ，可以将所有集合中某个成员的 最小 score 值作为结果集中该成员的 score 值；而参数 MAX 则是将所有集合中某个成员的 最大 score 值作为结果集中该成员的 score 值。</p><h4 id="可用版本-14"><a href="#可用版本-14" class="headerlink" title="可用版本"></a>可用版本</h4><p>版本&gt;= 2.0.0</p><h4 id="时间复杂度-14"><a href="#时间复杂度-14" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><p>O(N)+O(M log(M))， N 为给定有序集基数的总和， M 为结果集的基数。</p><h4 id="返回值-14"><a href="#返回值-14" class="headerlink" title="返回值"></a>返回值</h4><p>保存到 destination 的结果集的基数。</p><h4 id="示例-14"><a href="#示例-14" class="headerlink" title="示例"></a>示例</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">redis&gt; ZRANGE programmer 0 -1 WITHSCORES</div><div class="line">1) &quot;peter&quot;</div><div class="line">2) &quot;2000&quot;</div><div class="line">3) &quot;jack&quot;</div><div class="line">4) &quot;3500&quot;</div><div class="line">5) &quot;tom&quot;</div><div class="line">6) &quot;5000&quot;</div><div class="line">redis&gt; ZRANGE manager 0 -1 WITHSCORES</div><div class="line">1) &quot;herry&quot;</div><div class="line">2) &quot;2000&quot;</div><div class="line">3) &quot;mary&quot;</div><div class="line">4) &quot;3500&quot;</div><div class="line">5) &quot;bob&quot;</div><div class="line">6) &quot;4000&quot;</div><div class="line">redis&gt; ZUNIONSTORE salary 2 programmer manager WEIGHTS 1 3   # 公司决定加薪。。。除了程序员。。。</div><div class="line">(integer) 6</div><div class="line">redis&gt; ZRANGE salary 0 -1 WITHSCORES</div><div class="line">1) &quot;peter&quot;</div><div class="line">2) &quot;2000&quot;</div><div class="line">3) &quot;jack&quot;</div><div class="line">4) &quot;3500&quot;</div><div class="line">5) &quot;tom&quot;</div><div class="line">6) &quot;5000&quot;</div><div class="line">7) &quot;herry&quot;</div><div class="line">8) &quot;6000&quot;</div><div class="line">9) &quot;mary&quot;</div><div class="line">10) &quot;10500&quot;</div><div class="line">11) &quot;bob&quot;</div><div class="line">12) &quot;12000&quot;</div></pre></td></tr></table></figure><h3 id="ZINTERSTORE"><a href="#ZINTERSTORE" class="headerlink" title="ZINTERSTORE"></a><strong>ZINTERSTORE</strong></h3><p><strong>ZINTERSTORE destination numkeys key [key …] [WEIGHTS weight [weight …]] [AGGREGATE SUM|MIN|MAX]</strong></p><p> 计算给定的一个或多个有序集的交集，其中给定 key 的数量必须以 numkeys 参数指定，并将该交集(结果集)储存到 destination 。<br> 默认情况下，结果集中某个成员的 score 值是所有给定集下该成员 score 值之和.<br> 关于 WEIGHTS 和 AGGREGATE 选项的描述，参见 ZUNIONSTORE 命令。</p><h4 id="可用版本-15"><a href="#可用版本-15" class="headerlink" title="可用版本"></a>可用版本</h4><p>版本&gt;= 2.0.0</p><h4 id="时间复杂度-15"><a href="#时间复杂度-15" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><p>O(N<em>K)+O(M</em>log(M))， N 为给定 key 中基数最小的有序集， K 为给定有序集的数量， M 为结果集的基数。</p><h4 id="返回值-15"><a href="#返回值-15" class="headerlink" title="返回值"></a>返回值</h4><p>保存到 destination 的结果集的基数。</p><h4 id="示例-15"><a href="#示例-15" class="headerlink" title="示例"></a>示例</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">redis &gt; ZADD mid_test 70 &quot;Li Lei&quot;</div><div class="line">(integer) 1</div><div class="line">redis &gt; ZADD mid_test 70 &quot;Han Meimei&quot;</div><div class="line">(integer) 1</div><div class="line">redis &gt; ZADD mid_test 99.5 &quot;Tom&quot;</div><div class="line">(integer) 1</div><div class="line">redis &gt; ZADD fin_test 88 &quot;Li Lei&quot;</div><div class="line">(integer) 1</div><div class="line">redis &gt; ZADD fin_test 75 &quot;Han Meimei&quot;</div><div class="line">(integer) 1</div><div class="line">redis &gt; ZADD fin_test 99.5 &quot;Tom&quot;</div><div class="line">(integer) 1</div><div class="line">redis &gt; ZINTERSTORE sum_point 2 mid_test fin_test</div><div class="line">(integer) 3</div><div class="line">redis &gt; ZRANGE sum_point 0 -1 WITHSCORES     # 显示有序集内所有成员及其 score 值</div><div class="line">1) &quot;Han Meimei&quot;</div><div class="line">2) &quot;145&quot;</div><div class="line">3) &quot;Li Lei&quot;</div><div class="line">4) &quot;158&quot;</div><div class="line">5) &quot;Tom&quot;</div><div class="line">6) &quot;199&quot;</div></pre></td></tr></table></figure><h3 id="ZSCAN"><a href="#ZSCAN" class="headerlink" title="ZSCAN"></a><strong>ZSCAN</strong></h3><p><strong>ZSCAN key cursor [MATCH pattern] [COUNT count]</strong></p><p> 详细信息请参考 SCAN 命令。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;有序集合和散列一样，都用于存储键值对：有序集合的键被称为成员（member），每个成员都是各不相同；而有序集合的值则被称为分值（score），分值必须为浮点数。有序集合是Redis里面唯一一个既可以根据成员访问元素（这一点和散列一样），又可以根据分值以及分值的排列顺序来访问元素的结构。字符串成员（member）与浮点数分值（score）之间的有序映射，元素的排列顺序由分值的大小决定。&lt;br&gt;结构的读写：&lt;br&gt; 添加、获取、删除单个元素&lt;br&gt; 根据分值范围（range）或者成员来获取元素&lt;br&gt;
    
    </summary>
    
      <category term="Redis" scheme="http://yoursite.com/categories/Redis/"/>
    
    
      <category term="Redis" scheme="http://yoursite.com/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Redis数据类型--String（字符串）</title>
    <link href="http://yoursite.com/2017/03/06/Redis%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B--String%EF%BC%88%E5%AD%97%E7%AC%A6%E4%B8%B2%EF%BC%89/"/>
    <id>http://yoursite.com/2017/03/06/Redis数据类型--String（字符串）/</id>
    <published>2017-03-06T13:02:25.000Z</published>
    <updated>2017-09-28T09:36:40.330Z</updated>
    
    <content type="html"><![CDATA[<p>Redis的字符串和其他编程语言或者其他键值存储提供的字符串非常相似。一个key对应一个value。<br>string类型是二进制安全的，可以包含任何数据，比如jpg图片或者序列化的对象。从内部实现来看其实string可以看作byte数组，最大上限1G字节。<br>另外string类型可以被部分命令按int处理，比如incr等命令。<br>文档目前描述的内容以 Redis 2.8 版本为准。<br><a id="more"></a></p><h3 id="SET"><a href="#SET" class="headerlink" title="SET"></a><strong>SET</strong></h3><p><strong>SET key value [EX seconds] [PX milliseconds] [NX|XX]</strong><br> 将字符串值 value 关联到 key 。<br> 如果 key 已经持有其他值， SET 就覆写旧值，无视类型。<br> 对于某个原本带有生存时间（TTL）的键来说， 当 SET 命令成功在这个键上执行时， 这个键原有的 TTL 将被清除。</p><h4 id="可选参数"><a href="#可选参数" class="headerlink" title="可选参数"></a>可选参数</h4><p> <strong>EX second ：</strong>设置键的过期时间为 second 秒。 SET key value EX second 效果等同于 SETEX key second value 。<br> <strong>PX millisecond ：</strong>设置键的过期时间为 millisecond 毫秒。 SET key value PX millisecond 效果等同于 PSETEX key millisecond value 。<br> <strong>NX ：</strong>只在键不存在时，才对键进行设置操作。 SET key value NX 效果等同于 SETNX key value 。<br> <strong>XX ：</strong>只在键已经存在时，才对键进行设置操作。</p><h4 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h4><p> SET 在设置操作成功完成时，才返回 OK 。如果设置了 NX 或者 XX ，但因为条件没达到而造成设置操作未执行，那么命令返回空批量回复（NULL Bulk Reply）。</p><h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">127.0.0.1:6379&gt; SET key &quot;value&quot;</div><div class="line">OK</div><div class="line">127.0.0.1:6379&gt; SET key &quot;value1&quot; EX 10086 XX</div><div class="line">OK</div><div class="line">127.0.0.1:6379&gt; SET key &quot;value1&quot; PX 10086 NX</div><div class="line">(nil)</div></pre></td></tr></table></figure><h3 id="SETBIT"><a href="#SETBIT" class="headerlink" title="SETBIT"></a><strong>SETBIT</strong></h3><p><strong>SETBIT key offset value</strong><br> 对 key 所储存的字符串值，设置或清除指定偏移量上的位(bit)。<br> 位的设置或清除取决于 value 参数，可以是 0 也可以是 1 。<br> 当 key 不存在时，自动生成一个新的字符串值。<br> 字符串会进行伸展(grown)以确保它可以将 value 保存在指定的偏移量上。当字符串值进行伸展时，空白位置以 0 填充。<br> offset 参数必须大于或等于 0 ，小于 2^32 (bit 映射被限制在 512 MB 之内)。</p><h4 id="返回值-1"><a href="#返回值-1" class="headerlink" title="返回值"></a>返回值</h4><p>指定偏移量原来储存的位。</p><h4 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">127.0.0.1:6379&gt; SETBIT bit 50 1</div><div class="line">(integer) 0</div><div class="line">127.0.0.1:6379&gt; GETBIT bit 50</div><div class="line">(integer) 1</div><div class="line">127.0.0.1:6379&gt; GETBIT bit 40</div><div class="line">(integer) 0</div></pre></td></tr></table></figure><h3 id="SETEX"><a href="#SETEX" class="headerlink" title="SETEX"></a><strong>SETEX</strong></h3><p><strong>SETEX key seconds value</strong><br> 将值 value 关联到 key ，并将 key 的生存时间设为 seconds (以秒为单位)。<br> 如果 key 已经存在， SETEX 命令将覆写旧值。</p><h4 id="返回值-2"><a href="#返回值-2" class="headerlink" title="返回值"></a>返回值</h4><p>设置成功时返回 OK 。当 seconds 参数不合法时，返回一个错误。</p><h4 id="示例-2"><a href="#示例-2" class="headerlink" title="示例"></a>示例</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">127.0.0.1:6379&gt; SETEX key 50 &quot;value&quot;</div><div class="line">OK</div><div class="line">127.0.0.1:6379&gt; GET key</div><div class="line">&quot;value&quot;</div><div class="line">127.0.0.1:6379&gt; TTL key</div><div class="line">(integer) 29</div></pre></td></tr></table></figure><h3 id="SETNX"><a href="#SETNX" class="headerlink" title="SETNX"></a><strong>SETNX</strong></h3><p><strong>SETNX key value</strong><br> 将 key 的值设为 value ，当且仅当 key 不存在。<br> 若给定的 key 已经存在，则 SETNX 不做任何动作。<br> SETNX 是『SET if Not eXists』(如果不存在，则 SET)的简写。</p><h4 id="返回值-3"><a href="#返回值-3" class="headerlink" title="返回值"></a>返回值</h4><p>设置成功，返回 1 。设置失败，返回 0 。</p><h4 id="示例-3"><a href="#示例-3" class="headerlink" title="示例"></a>示例</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">127.0.0.1:6379&gt; SETNX key &quot;value&quot;</div><div class="line">(integer) 1</div><div class="line">127.0.0.1:6379&gt; SETNX key &quot;value1&quot;</div><div class="line">(integer) 0</div></pre></td></tr></table></figure><h3 id="SETRANGE"><a href="#SETRANGE" class="headerlink" title="SETRANGE"></a><strong>SETRANGE</strong></h3><p><strong>SETRANGE key offset value</strong><br> 用 value 参数覆写(overwrite)给定 key 所储存的字符串值，从偏移量 offset 开始。<br> 不存在的 key 当作空白字符串处理。<br> SETRANGE 命令会确保字符串足够长以便将 value 设置在指定的偏移量上，如果给定 key 原来储存的字符串长度比偏移量小(比如字符串只有 5 个字符长，但你设置的 offset 是 10 )，那么原字符和偏移量之间的空白将用零字节(zerobytes, “\x00” )来填充。<br> 注意你能使用的最大偏移量是 2^29-1(536870911) ，因为 Redis 字符串的大小被限制在 512 兆(megabytes)以内。如果你需要使用比这更大的空间，你可以使用多个 key 。</p><p><strong>注意：</strong>当生成一个很长的字符串时，Redis 需要分配内存空间，该操作有时候可能会造成服务器阻塞(block)。在2010年的Macbook Pro上，设置偏移量为 536870911(512MB 内存分配)，耗费约 300 毫秒， 设置偏移量为 134217728(128MB 内存分配)，耗费约 80 毫秒，设置偏移量 33554432(32MB 内存分配)，耗费约 30 毫秒，设置偏移量为 8388608(8MB 内存分配)，耗费约 8 毫秒。 注意若首次内存分配成功之后，再对同一个 key 调用 SETRANGE 操作，无须再重新内存。</p><h4 id="返回值-4"><a href="#返回值-4" class="headerlink" title="返回值"></a>返回值</h4><p>被 SETRANGE 修改之后，字符串的长度。</p><h4 id="示例-4"><a href="#示例-4" class="headerlink" title="示例"></a>示例</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">127.0.0.1:6379&gt; EXISTS empty_key</div><div class="line">(integer) 0</div><div class="line">127.0.0.1:6379&gt; SETRANGE empty_key 5 &quot;Redis!&quot;</div><div class="line">(integer) 11</div><div class="line">127.0.0.1:6379&gt; GET empty_key</div><div class="line">&quot;\x00\x00\x00\x00\x00Redis!&quot;</div><div class="line">127.0.0.1:6379&gt;</div></pre></td></tr></table></figure><h3 id="GET"><a href="#GET" class="headerlink" title="GET"></a><strong>GET</strong></h3><p><strong>GET key</strong><br> 返回 key 所关联的字符串值。<br> 如果 key 不存在那么返回特殊值 nil 。<br> 假如 key 储存的值不是字符串类型，返回一个错误，因为 GET 只能用于处理字符串值。</p><h4 id="返回值-5"><a href="#返回值-5" class="headerlink" title="返回值"></a>返回值</h4><p>当 key 不存在时，返回 nil ，否则，返回 key 的值。如果 key 不是字符串类型，那么返回一个错误。</p><h4 id="示例-5"><a href="#示例-5" class="headerlink" title="示例"></a>示例</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">127.0.0.1:6379&gt; SET key &quot;value&quot;</div><div class="line">OK</div><div class="line">127.0.0.1:6379&gt; GET key</div><div class="line">&quot;value&quot;</div></pre></td></tr></table></figure><h3 id="GETBIT"><a href="#GETBIT" class="headerlink" title="GETBIT"></a><strong>GETBIT</strong></h3><p><strong>GETBIT key offset</strong><br> 对 key 所储存的字符串值，获取指定偏移量上的位(bit)。<br> 当 offset 比字符串值的长度大，或者 key 不存在时，返回 0 。</p><h4 id="返回值-6"><a href="#返回值-6" class="headerlink" title="返回值"></a>返回值</h4><p>字符串值指定偏移量上的位(bit)。对不存在的 key 或者不存在的 offset 进行 GETBIT， 返回 0。</p><h4 id="示例-6"><a href="#示例-6" class="headerlink" title="示例"></a>示例</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">127.0.0.1:6379&gt; EXISTS bits</div><div class="line">(integer) 0</div><div class="line">127.0.0.1:6379&gt; GETBIT bits 100</div><div class="line">(integer) 0</div><div class="line">127.0.0.1:6379&gt; SETBIT bits 101 1</div><div class="line">(integer) 0</div><div class="line">127.0.0.1:6379&gt; GETBIT bits 101</div><div class="line">(integer) 1</div></pre></td></tr></table></figure><h3 id="GETRANGE"><a href="#GETRANGE" class="headerlink" title="GETRANGE"></a><strong>GETRANGE</strong></h3><p><strong>GETRANGE key start end</strong><br> 返回 key 中字符串值的子字符串，字符串的截取范围由 start 和 end 两个偏移量决定(包括 start 和 end 在内)。<br> 负数偏移量表示从字符串最后开始计数， -1 表示最后一个字符， -2 表示倒数第二个，以此类推。<br> GETRANGE 通过保证子字符串的值域(range)不超过实际字符串的值域来处理超出范围的值域请求。</p><h4 id="返回值-7"><a href="#返回值-7" class="headerlink" title="返回值"></a>返回值</h4><p>截取得出的子字符串。</p><h4 id="示例-7"><a href="#示例-7" class="headerlink" title="示例"></a>示例</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">127.0.0.1:6379&gt; SET greeting &quot;hello, my friend&quot;</div><div class="line">OK</div><div class="line">127.0.0.1:6379&gt; GETRANGE greeting 0 4          # 返回索引0-4的字符，包括4。</div><div class="line">&quot;hello&quot;</div><div class="line">127.0.0.1:6379&gt; GETRANGE greeting -1 -5        # 不支持回绕操作</div><div class="line">&quot;&quot;</div><div class="line">127.0.0.1:6379&gt; GETRANGE greeting -3 -1        # 负数索引</div><div class="line">&quot;end&quot;</div><div class="line">127.0.0.1:6379&gt; GETRANGE greeting 0 -1         # 从第一个到最后一个</div><div class="line">&quot;hello, my friend&quot;</div><div class="line">127.0.0.1:6379&gt; GETRANGE greeting 0 1008611    # 值域超出部分被符略</div><div class="line">&quot;hello, my friend&quot;</div></pre></td></tr></table></figure><h3 id="GETSET"><a href="#GETSET" class="headerlink" title="GETSET"></a><strong>GETSET</strong></h3><p><strong>GETSET key value</strong><br> 将给定 key 的值设为 value ，并返回 key 的旧值(old value)。<br> 当 key 存在但不是字符串类型时，返回一个错误。</p><h4 id="可用版本"><a href="#可用版本" class="headerlink" title="可用版本"></a>可用版本</h4><p>   版本&gt;= 1.0.0</p><h4 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><p>O(1)</p><h4 id="返回值-8"><a href="#返回值-8" class="headerlink" title="返回值"></a>返回值</h4><p> 返回给定 key 的旧值。<br> 当 key 没有旧值时，也即是， key 不存在时，返回 nil 。</p><h4 id="示例-8"><a href="#示例-8" class="headerlink" title="示例"></a>示例</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">redis&gt; GETSET db mongodb    # 没有旧值，返回 nil</div><div class="line">(nil)</div><div class="line">redis&gt; GET db</div><div class="line">&quot;mongodb&quot;</div><div class="line">redis&gt; GETSET db redis      # 返回旧值 mongodb</div><div class="line">&quot;mongodb&quot;</div><div class="line">redis&gt; GET db</div><div class="line">&quot;redis&quot;</div></pre></td></tr></table></figure><h3 id="APPEND"><a href="#APPEND" class="headerlink" title="APPEND"></a><strong>APPEND</strong></h3><p><strong>APPEND key value</strong><br> 如果 key 已经存在并且是一个字符串， APPEND 命令将 value 追加到 key 原来的值的末尾。<br> 如果 key 不存在， APPEND 就简单地将给定 key 设为 value ，就像执行 SET key value 一样。</p><h4 id="可用版本-1"><a href="#可用版本-1" class="headerlink" title="可用版本"></a>可用版本</h4><blockquote><p>= 2.0.0</p><h4 id="时间复杂度-1"><a href="#时间复杂度-1" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><p>平摊O(1)</p><h4 id="返回值-9"><a href="#返回值-9" class="headerlink" title="返回值"></a>返回值</h4><p>追加 value 之后， key 中字符串的长度。</p></blockquote><h4 id="示例-9"><a href="#示例-9" class="headerlink" title="示例"></a>示例</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"># 对不存在的 key 执行 APPEND</div><div class="line">redis&gt; EXISTS myphone               # 确保 myphone 不存在</div><div class="line">(integer) 0</div><div class="line">redis&gt; APPEND myphone &quot;nokia&quot;       # 对不存在的 key 进行 APPEND  ，等同于 SET myphone &quot;nokia&quot;</div><div class="line">(integer) 5                         # 字符长度</div><div class="line"># 对已存在的字符串进行 APPEND</div><div class="line">redis&gt; APPEND myphone &quot; - 1110&quot;     # 长度从 5 个字符增加到 12 个字符</div><div class="line">(integer) 12</div><div class="line">redis&gt; GET myphone</div><div class="line">&quot;nokia - 1110&quot;</div></pre></td></tr></table></figure><h3 id="BITCOUNT"><a href="#BITCOUNT" class="headerlink" title="BITCOUNT"></a><strong>BITCOUNT</strong></h3><p><strong>BITCOUNT key [start] [end]</strong><br> 计算给定字符串中，被设置为 1 的比特位的数量。<br> 一般情况下，给定的整个字符串都会被进行计数，通过指定额外的 start 或 end 参数，可以让计数只在特定的位上进行。<br> start 和 end 参数的设置和 GETRANGE 命令类似，都可以使用负数值：比如 -1 表示最后一个位，而 -2 表示倒数第二个位，以此类推。<br> 不存在的 key 被当成是空字符串来处理，因此对一个不存在的 key 进行 BITCOUNT 操作，结果为 0 。</p><h4 id="可用版本-2"><a href="#可用版本-2" class="headerlink" title="可用版本"></a>可用版本</h4><p>版本&gt;= 2.6.0</p><h4 id="时间复杂度-2"><a href="#时间复杂度-2" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><p>O(N)</p><h4 id="返回值-10"><a href="#返回值-10" class="headerlink" title="返回值"></a>返回值</h4><p>被设置为 1 的位的数量。</p><h4 id="示例-10"><a href="#示例-10" class="headerlink" title="示例"></a>示例</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">redis&gt; BITCOUNT bits</div><div class="line">(integer) 0</div><div class="line">redis&gt; SETBIT bits 0 1          # 0001</div><div class="line">(integer) 0</div><div class="line">redis&gt; BITCOUNT bits</div><div class="line">(integer) 1</div><div class="line">redis&gt; SETBIT bits 3 1          # 1001</div><div class="line">(integer) 0</div><div class="line">redis&gt; BITCOUNT bits</div><div class="line">(integer) 2</div></pre></td></tr></table></figure><h3 id="BITOP"><a href="#BITOP" class="headerlink" title="BITOP"></a><strong>BITOP</strong></h3><p><strong>BITOP operation destkey key [key …]</strong><br> 对一个或多个保存二进制位的字符串 key 进行位元操作，并将结果保存到 destkey 上。<br> operation 可以是 AND 、 OR 、 NOT 、 XOR 这四种操作中的任意一种：</p><ul><li>BITOP AND destkey key [key …] ，对一个或多个 key 求逻辑并，并将结果保存到 destkey 。</li><li>BITOP OR destkey key [key …] ，对一个或多个 key 求逻辑或，并将结果保存到 destkey 。</li><li>BITOP XOR destkey key [key …] ，对一个或多个 key 求逻辑异或，并将结果保存到 destkey 。</li><li>BITOP NOT destkey key ，对给定 key 求逻辑非，并将结果保存到 destkey 。</li></ul><p> 除了 NOT 操作之外，其他操作都可以接受一个或多个 key 作为输入。</p><h4 id="处理不同长度的字符串"><a href="#处理不同长度的字符串" class="headerlink" title="处理不同长度的字符串"></a>处理不同长度的字符串</h4><p>当 BITOP 处理不同长度的字符串时，较短的那个字符串所缺少的部分会被看作 0 。空的 key 也被看作是包含 0 的字符串序列。</p><h4 id="可用版本-3"><a href="#可用版本-3" class="headerlink" title="可用版本"></a>可用版本</h4><p>版本&gt;= 2.6.0</p><h4 id="时间复杂度-3"><a href="#时间复杂度-3" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><p>O(N)</p><h4 id="返回值-11"><a href="#返回值-11" class="headerlink" title="返回值"></a>返回值</h4><p>保存到 destkey 的字符串的长度，和输入 key 中最长的字符串长度相等。</p><p><strong>注意：</strong> BITOP 的复杂度为 O(N) ，当处理大型矩阵(matrix)或者进行大数据量的统计时，最好将任务指派到附属节点(slave)进行，避免阻塞主节点。</p><h4 id="示例-11"><a href="#示例-11" class="headerlink" title="示例"></a>示例</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">redis&gt; SETBIT bits-1 0 1        # bits-1 = 1001</div><div class="line">(integer) 0</div><div class="line">redis&gt; SETBIT bits-1 3 1</div><div class="line">(integer) 0</div><div class="line">redis&gt; SETBIT bits-2 0 1        # bits-2 = 1011</div><div class="line">(integer) 0</div><div class="line">redis&gt; SETBIT bits-2 1 1</div><div class="line">(integer) 0</div><div class="line">redis&gt; SETBIT bits-2 3 1</div><div class="line">(integer) 0</div><div class="line">redis&gt; BITOP AND and-result bits-1 bits-2</div><div class="line">(integer) 1</div><div class="line">redis&gt; GETBIT and-result 0      # and-result = 1001</div><div class="line">(integer) 1</div><div class="line">redis&gt; GETBIT and-result 1</div><div class="line">(integer) 0</div><div class="line">redis&gt; GETBIT and-result 2</div><div class="line">(integer) 0</div><div class="line">redis&gt; GETBIT and-result 3</div><div class="line">(integer) 1</div></pre></td></tr></table></figure><h3 id="DECR"><a href="#DECR" class="headerlink" title="DECR"></a><strong>DECR</strong></h3><p><strong>DECR key</strong><br> 将 key 中储存的数字值减一。<br> 如果 key 不存在，那么 key 的值会先被初始化为 0 ，然后再执行 DECR 操作。<br> 如果值包含错误的类型，或字符串类型的值不能表示为数字，那么返回一个错误。<br> 本操作的值限制在 64 位(bit)有符号数字表示之内。</p><h4 id="可用版本-4"><a href="#可用版本-4" class="headerlink" title="可用版本"></a>可用版本</h4><p>版本&gt;= 1.0.0</p><h4 id="时间复杂度-4"><a href="#时间复杂度-4" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><p>O(1)</p><h4 id="返回值-12"><a href="#返回值-12" class="headerlink" title="返回值"></a>返回值</h4><p>执行 DECR 命令之后 key 的值。</p><h4 id="示例-12"><a href="#示例-12" class="headerlink" title="示例"></a>示例</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"># 对存在的数字值 key 进行 DECR</div><div class="line">redis&gt; SET failure_times 10</div><div class="line">OK</div><div class="line">redis&gt; DECR failure_times</div><div class="line">(integer) 9</div><div class="line"># 对不存在的 key 值进行 DECR</div><div class="line">redis&gt; EXISTS count</div><div class="line">(integer) 0</div><div class="line">redis&gt; DECR count</div><div class="line">(integer) -1</div><div class="line"># 对存在但不是数值的 key 进行 DECR</div><div class="line">redis&gt; SET company YOUR_CODE_SUCKS.LLC</div><div class="line">OK</div><div class="line">redis&gt; DECR company</div><div class="line">(error) ERR value is not an integer or out of range</div></pre></td></tr></table></figure><h3 id="DECRBY"><a href="#DECRBY" class="headerlink" title="DECRBY"></a><strong>DECRBY</strong></h3><p><strong>DECRBY key decrement</strong><br> 将 key 所储存的值减去减量 decrement 。<br> 如果 key 不存在，那么 key 的值会先被初始化为 0 ，然后再执行 DECRBY 操作。<br> 如果值包含错误的类型，或字符串类型的值不能表示为数字，那么返回一个错误。<br> 本操作的值限制在 64 位(bit)有符号数字表示之内。</p><h4 id="可用版本-5"><a href="#可用版本-5" class="headerlink" title="可用版本"></a>可用版本</h4><p>版本&gt;= 1.0.0</p><h4 id="时间复杂度-5"><a href="#时间复杂度-5" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><p>O(1)</p><h4 id="返回值-13"><a href="#返回值-13" class="headerlink" title="返回值"></a>返回值</h4><p>减去 decrement 之后， key 的值。</p><h3 id="示例-13"><a href="#示例-13" class="headerlink" title="示例"></a>示例</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"># 对已存在的 key 进行 DECRBY</div><div class="line">redis&gt; SET count 100</div><div class="line">OK</div><div class="line">redis&gt; DECRBY count 20</div><div class="line">(integer) 80</div><div class="line"># 对不存在的 key 进行DECRBY</div><div class="line">redis&gt; EXISTS pages</div><div class="line">(integer) 0</div><div class="line">redis&gt; DECRBY pages 10</div><div class="line">(integer) -10</div></pre></td></tr></table></figure><h3 id="INCR"><a href="#INCR" class="headerlink" title="INCR"></a><strong>INCR</strong></h3><p><strong>INCR key</strong><br> 将 key 中储存的数字值增一。<br> 如果 key 不存在，那么 key 的值会先被初始化为 0 ，然后再执行 INCR 操作。<br> 如果值包含错误的类型，或字符串类型的值不能表示为数字，那么返回一个错误。<br> 本操作的值限制在 64 位(bit)有符号数字表示之内。</p><p><strong>注意：</strong>这是一个针对字符串的操作，因为 Redis 没有专用的整数类型，所以 key 内储存的字符串被解释为十进制 64 位有符号整数来执行 INCR 操作。</p><h4 id="可用版本-6"><a href="#可用版本-6" class="headerlink" title="可用版本"></a>可用版本</h4><p>版本&gt;= 1.0.0</p><h4 id="时间复杂度-6"><a href="#时间复杂度-6" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><p>O(1)</p><h4 id="返回值-14"><a href="#返回值-14" class="headerlink" title="返回值"></a>返回值</h4><p>执行 INCR 命令之后 key 的值。</p><h4 id="示例-14"><a href="#示例-14" class="headerlink" title="示例"></a>示例</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">redis&gt; SET page_view 20</div><div class="line">OK</div><div class="line">redis&gt; INCR page_view</div><div class="line">(integer) 21</div><div class="line">redis&gt; GET page_view    # 数字值在 Redis 中以字符串的形式保存</div><div class="line">&quot;21&quot;</div></pre></td></tr></table></figure><h3 id="INCRBY"><a href="#INCRBY" class="headerlink" title="INCRBY"></a><strong>INCRBY</strong></h3><p><strong>INCRBY key increment</strong><br> 将 key 所储存的值加上增量 increment 。<br> 如果 key 不存在，那么 key 的值会先被初始化为 0 ，然后再执行 INCRBY 命令。<br> 如果值包含错误的类型，或字符串类型的值不能表示为数字，那么返回一个错误。<br> 本操作的值限制在 64 位(bit)有符号数字表示之内。</p><h4 id="可用版本-7"><a href="#可用版本-7" class="headerlink" title="可用版本"></a>可用版本</h4><p>版本&gt;= 1.0.0</p><h4 id="时间复杂度-7"><a href="#时间复杂度-7" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><p>O(1)</p><h4 id="返回值-15"><a href="#返回值-15" class="headerlink" title="返回值"></a>返回值</h4><p>加上 increment 之后， key 的值。</p><h4 id="示例-15"><a href="#示例-15" class="headerlink" title="示例"></a>示例</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"># key 存在且是数字值</div><div class="line">redis&gt; SET rank 50</div><div class="line">OK</div><div class="line">redis&gt; INCRBY rank 20</div><div class="line">(integer) 70</div><div class="line">redis&gt; GET rank</div><div class="line">&quot;70&quot;</div><div class="line"># key 不存在时</div><div class="line">redis&gt; EXISTS counter</div><div class="line">(integer) 0</div><div class="line">redis&gt; INCRBY counter 30</div><div class="line">(integer) 30</div><div class="line">redis&gt; GET counter</div><div class="line">&quot;30&quot;</div><div class="line"># key 不是数字值时</div><div class="line">redis&gt; SET book &quot;long long ago...&quot;</div><div class="line">OK</div><div class="line">redis&gt; INCRBY book 200</div><div class="line">(error) ERR value is not an integer or out of range</div></pre></td></tr></table></figure><h3 id="INCRBYFLOAT"><a href="#INCRBYFLOAT" class="headerlink" title="INCRBYFLOAT"></a><strong>INCRBYFLOAT</strong></h3><p><strong>INCRBYFLOAT key increment</strong><br> 为 key 中所储存的值加上浮点数增量 increment 。<br> 如果 key 不存在，那么 INCRBYFLOAT 会先将 key 的值设为 0 ，再执行加法操作。<br> 如果命令执行成功，那么 key 的值会被更新为（执行加法之后的）新值，并且新值会以字符串的形式返回给调用者。<br> 无论是 key 的值，还是增量 increment ，都可以使用像 2.0e7 、 3e5 、 90e-2 那样的指数符号(exponential notation)来表示，但是，执行 INCRBYFLOAT 命令之后的值总是以同样的形式储存，也即是，它们总是由一个数字，一个（可选的）小数点和一个任意位的小数部分组成（比如 3.14 、 69.768 ，诸如此类)，小数部分尾随的 0 会被移除，如果有需要的话，还会将浮点数改为整数（比如 3.0 会被保存成 3 ）。<br> 除此之外，无论加法计算所得的浮点数的实际精度有多长， INCRBYFLOAT 的计算结果也最多只能表示小数点的后十七位。</p><p>当以下任意一个条件发生时，返回一个错误：</p><ul><li>key 的值不是字符串类型(因为 Redis 中的数字和浮点数都以字符串的形式保存，所以它们都属于字符串类型）</li><li>key 当前的值或者给定的增量 increment 不能解释(parse)为双精度浮点数(double precision floating point number）</li></ul><h4 id="可用版本-8"><a href="#可用版本-8" class="headerlink" title="可用版本"></a>可用版本</h4><p>版本&gt;= 2.6.0</p><h4 id="时间复杂度-8"><a href="#时间复杂度-8" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><p>O(1)</p><h4 id="返回值-16"><a href="#返回值-16" class="headerlink" title="返回值"></a>返回值</h4><p>执行命令之后 key 的值。</p><h4 id="示例-16"><a href="#示例-16" class="headerlink" title="示例"></a>示例</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"># 值和增量都不是指数符号</div><div class="line">redis&gt; SET mykey 10.50</div><div class="line">OK</div><div class="line">redis&gt; INCRBYFLOAT mykey 0.1</div><div class="line">&quot;10.6&quot;</div><div class="line"># 值和增量都是指数符号</div><div class="line">redis&gt; SET mykey 314e-2</div><div class="line">OK</div><div class="line">redis&gt; GET mykey                # 用 SET 设置的值可以是指数符号</div><div class="line">&quot;314e-2&quot;</div><div class="line">redis&gt; INCRBYFLOAT mykey 0      # 但执行 INCRBYFLOAT 之后格式会被改成非指数符号</div><div class="line">&quot;3.14&quot;</div><div class="line"># 可以对整数类型执行</div><div class="line">redis&gt; SET mykey 3</div><div class="line">OK</div><div class="line">redis&gt; INCRBYFLOAT mykey 1.1</div><div class="line">&quot;4.1&quot;</div><div class="line"># 后跟的 0 会被移除</div><div class="line">redis&gt; SET mykey 3.0</div><div class="line">OK</div><div class="line">redis&gt; GET mykey                                    # SET 设置的值小数部分可以是 0</div><div class="line">&quot;3.0&quot;</div><div class="line">redis&gt; INCRBYFLOAT mykey 1.000000000000000000000    # 但 INCRBYFLOAT 会将无用的 0 忽略掉，有需要的话，将浮点变为整数</div><div class="line">&quot;4&quot;</div><div class="line">redis&gt; GET mykey</div><div class="line">&quot;4&quot;</div></pre></td></tr></table></figure><h3 id="MGET"><a href="#MGET" class="headerlink" title="MGET"></a><strong>MGET</strong></h3><p><strong>MGET key [key …]</strong><br> 返回所有(一个或多个)给定 key 的值。<br> 如果给定的 key 里面，有某个 key 不存在，那么这个 key 返回特殊值 nil 。因此，该命令永不失败。</p><h4 id="可用版本-9"><a href="#可用版本-9" class="headerlink" title="可用版本"></a>可用版本</h4><p>版本&gt;= 1.0.0</p><h4 id="时间复杂度-9"><a href="#时间复杂度-9" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><p>O(N) , N 为给定 key 的数量。</p><h4 id="返回值-17"><a href="#返回值-17" class="headerlink" title="返回值"></a>返回值</h4><p>一个包含所有给定 key 的值的列表。</p><h4 id="示例-17"><a href="#示例-17" class="headerlink" title="示例"></a>示例</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">redis&gt; SET redis redis.com</div><div class="line">OK</div><div class="line">redis&gt; SET mongodb mongodb.org</div><div class="line">OK</div><div class="line">redis&gt; MGET redis mongodb</div><div class="line">1) &quot;redis.com&quot;</div><div class="line">2) &quot;mongodb.org&quot;</div><div class="line">redis&gt; MGET redis mongodb mysql     # 不存在的 mysql 返回 nil</div><div class="line">1) &quot;redis.com&quot;</div><div class="line">2) &quot;mongodb.org&quot;</div><div class="line">3) (nil)</div></pre></td></tr></table></figure><h3 id="MSET"><a href="#MSET" class="headerlink" title="MSET"></a><strong>MSET</strong></h3><p><strong>MSET key value [key value …]</strong><br> 同时设置一个或多个 key-value 对。<br> 如果某个给定 key 已经存在，那么 MSET 会用新值覆盖原来的旧值，如果这不是你所希望的效果，请考虑使用 MSETNX 命令：它只会在所有给定 key 都不存在的情况下进行设置操作。<br> MSET 是一个原子性(atomic)操作，所有给定 key 都会在同一时间内被设置，某些给定 key 被更新而另一些给定 key 没有改变的情况，不可能发生。</p><h4 id="可用版本-10"><a href="#可用版本-10" class="headerlink" title="可用版本"></a>可用版本</h4><p>版本&gt;= 1.0.1</p><h4 id="时间复杂度-10"><a href="#时间复杂度-10" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><p>O(N)， N 为要设置的 key 数量。</p><h4 id="返回值-18"><a href="#返回值-18" class="headerlink" title="返回值"></a>返回值</h4><p>总是返回 OK (因为 MSET 不可能失败)</p><h4 id="示例-18"><a href="#示例-18" class="headerlink" title="示例"></a>示例</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">redis&gt; MSET date &quot;2012.3.30&quot; time &quot;11:00 a.m.&quot; weather &quot;sunny&quot;</div><div class="line">OK</div><div class="line">redis&gt; MGET date time weather</div><div class="line">1) &quot;2012.3.30&quot;</div><div class="line">2) &quot;11:00 a.m.&quot;</div><div class="line">3) &quot;sunny&quot;</div><div class="line"># MSET 覆盖旧值例子</div><div class="line">redis&gt; SET google &quot;google.hk&quot;</div><div class="line">OK</div><div class="line">redis&gt; MSET google &quot;google.com&quot;</div><div class="line">OK</div><div class="line">redis&gt; GET google</div><div class="line">&quot;google.com&quot;</div></pre></td></tr></table></figure><h3 id="MSETNX"><a href="#MSETNX" class="headerlink" title="MSETNX"></a><strong>MSETNX</strong></h3><p><strong>MSETNX key value [key value …]</strong><br> 同时设置一个或多个 key-value 对，当且仅当所有给定 key 都不存在。<br> 即使只有一个给定 key 已存在， MSETNX 也会拒绝执行所有给定 key 的设置操作。<br> MSETNX 是原子性的，因此它可以用作设置多个不同 key 表示不同字段(field)的唯一性逻辑对象(unique logic object)，所有字段要么全被设置，要么全不被设置。</p><h4 id="可用版本-11"><a href="#可用版本-11" class="headerlink" title="可用版本"></a>可用版本</h4><p>版本&gt;= 1.0.1</p><h4 id="时间复杂度-11"><a href="#时间复杂度-11" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><p>O(N)， N 为要设置的 key 的数量。</p><h4 id="返回值-19"><a href="#返回值-19" class="headerlink" title="返回值"></a>返回值</h4><p>当所有 key 都成功设置，返回 1 。<br>如果所有给定 key 都设置失败(至少有一个 key 已经存在)，那么返回 0 。</p><h4 id="示例-19"><a href="#示例-19" class="headerlink" title="示例"></a>示例</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"># 对不存在的 key 进行 MSETNX</div><div class="line">redis&gt; MSETNX rmdbs &quot;MySQL&quot; nosql &quot;MongoDB&quot; key-value-store &quot;redis&quot;</div><div class="line">(integer) 1</div><div class="line">redis&gt; MGET rmdbs nosql key-value-store</div><div class="line">1) &quot;MySQL&quot;</div><div class="line">2) &quot;MongoDB&quot;</div><div class="line">3) &quot;redis&quot;</div><div class="line"># MSET 的给定 key 当中有已存在的 key</div><div class="line">redis&gt; MSETNX rmdbs &quot;Sqlite&quot; language &quot;python&quot;  # rmdbs 键已经存在，操作失败</div><div class="line">(integer) 0</div><div class="line">redis&gt; EXISTS language                          # 因为 MSET 是原子性操作，language 没有被设置</div><div class="line">(integer) 0</div><div class="line">redis&gt; GET rmdbs                                # rmdbs 也没有被修改</div><div class="line">&quot;MySQL&quot;</div></pre></td></tr></table></figure><h3 id="PSETEX"><a href="#PSETEX" class="headerlink" title="PSETEX"></a><strong>PSETEX</strong></h3><p><strong>PSETEX key milliseconds value</strong><br>  这个命令和 SETEX 命令相似，但它以毫秒为单位设置 key 的生存时间，而不是像 SETEX 命令那样，以秒为单位。</p><h4 id="可用版本-12"><a href="#可用版本-12" class="headerlink" title="可用版本"></a>可用版本</h4><p>版本&gt;= 2.6.0</p><h4 id="时间复杂度-12"><a href="#时间复杂度-12" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><p>O(1)</p><h4 id="返回值-20"><a href="#返回值-20" class="headerlink" title="返回值"></a>返回值</h4><p>设置成功时返回 OK 。</p><h4 id="示例-20"><a href="#示例-20" class="headerlink" title="示例"></a>示例</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">redis&gt; PSETEX mykey 1000 &quot;Hello&quot;</div><div class="line">OK</div><div class="line">redis&gt; PTTL mykey</div><div class="line">(integer) 999</div><div class="line">redis&gt; GET mykey</div><div class="line">&quot;Hello&quot;</div></pre></td></tr></table></figure><h3 id="STRLEN"><a href="#STRLEN" class="headerlink" title="STRLEN"></a><strong>STRLEN</strong></h3><p><strong>STRLEN key</strong><br> 返回 key 所储存的字符串值的长度。<br> 当 key 储存的不是字符串值时，返回一个错误。</p><h4 id="可用版本-13"><a href="#可用版本-13" class="headerlink" title="可用版本"></a>可用版本</h4><p>版本&gt;= 2.2.0</p><h4 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h4><p>O(1)</p><h4 id="返回值-21"><a href="#返回值-21" class="headerlink" title="返回值"></a>返回值</h4><p>字符串值的长度。<br>当 key 不存在时，返回 0 。</p><h4 id="示例-21"><a href="#示例-21" class="headerlink" title="示例"></a>示例</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"># 获取字符串的长度</div><div class="line">redis&gt; SET mykey &quot;Hello world&quot;</div><div class="line">OK</div><div class="line">redis&gt; STRLEN mykey</div><div class="line">(integer) 11</div><div class="line"># 不存在的 key 长度为 0</div><div class="line">redis&gt; STRLEN nonexisting</div><div class="line">(integer) 0</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Redis的字符串和其他编程语言或者其他键值存储提供的字符串非常相似。一个key对应一个value。&lt;br&gt;string类型是二进制安全的，可以包含任何数据，比如jpg图片或者序列化的对象。从内部实现来看其实string可以看作byte数组，最大上限1G字节。&lt;br&gt;另外string类型可以被部分命令按int处理，比如incr等命令。&lt;br&gt;文档目前描述的内容以 Redis 2.8 版本为准。&lt;br&gt;
    
    </summary>
    
      <category term="Redis" scheme="http://yoursite.com/categories/Redis/"/>
    
    
      <category term="Redis" scheme="http://yoursite.com/tags/Redis/"/>
    
  </entry>
  
</feed>
