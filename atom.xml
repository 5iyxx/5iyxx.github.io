<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>5IYXX</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2017-11-17T18:14:58.787Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Eric Chen</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Java运行时的数据区域</title>
    <link href="http://yoursite.com/2017/11/17/Java%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E5%9F%9F/"/>
    <id>http://yoursite.com/2017/11/17/Java运行时数据区域/</id>
    <published>2017-11-16T19:28:55.000Z</published>
    <updated>2017-11-17T18:14:58.787Z</updated>
    
    <content type="html"><![CDATA[<p>Java虚拟机在执行Java程序的过程会把它管理的内存划分为若干个不同的数据区域。</p><a id="more"></a><p>这些区域有各自的用途，及创建和销毁的时间，有些区域随虚拟机进程的启动而存在，有些区域则是依赖用户线程的启动和结束来建立和销毁。Java虚拟机所管理的内存包括以下几个运行时数据区域，如图1所示。</p><div align="center"><br><img src="/images/JVM/j1.jpg" alt=""><br>图1 java虚拟机运行时数据区</div><h3 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h3><p>程序计数器（Program Counter Resister）是一块较小的内存空间，它可以看作是当前线程所执行的<a href="https://baike.baidu.com/item/%E5%AD%97%E8%8A%82%E7%A0%81/9953683?fr=aladdin" target="_blank" rel="external">字节码</a>的行号指示器。在虚拟机的概念模型里(仅是概念模型，各种虚拟机可能会通过一些更高效的方式去实现)，<strong>字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令</strong>，分支、循环、跳转异常处理、线程恢复等基层功能都需要依赖这个计数器完成。<br>由于Java虚拟机的多线程是通过线程轮流切换并分配处理执行时间的方式来实现的，在任何一个确定的时刻，一个处理器（对于多核处理器说是一个内核）都只执行一条线程中的指令。因此，为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，各条线程之间计数器互不影响，独立存储，我们称这类内存区域为”线程私有”的内存。<br>如果线程正在执行的是一个Java方法，这个计数器记录的是<strong>正在执行的虚拟机字节码指令的地址</strong>；如果正在执行的是Native方法，这个计数器则为空（Undefined）。此内存区域是唯一一个在Java虚拟机规范中没有规定任何OutOfMemoryError情况的区域。</p><h3 id="Java虚拟机栈"><a href="#Java虚拟机栈" class="headerlink" title="Java虚拟机栈"></a>Java虚拟机栈</h3><p>与程序计数器一样，Java虚拟机栈（Java Virtual Machine Stacks）也是线程私有的，它的生命周期与线程相同。虚拟机栈描述的是Java方法执行的内存模型：每个方法在执行的同时都会创建一个栈帧（Stack Frame）<strong>用于存储局部变量表、操作数栈、动态链接、方法出口等信息</strong>。每个方法从调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中入栈到出栈的过程。<br>经常有人把Java内存区分为堆内存（Heap）和栈内存（Stack），这种分法比较粗糙，Java内存区域的划分实际上远比这复杂。这种划分方式的流行只能说明大多程序员最关注的、与对象内存分配关系最密切的内存区域是这两块。其中所指的“堆”将在下面进行专门的讲述，而所指的“栈”就是现在讲的虚拟机栈，或者说是虚拟机栈中局部变量表部分。<br>局部变量表存放了<strong>编译期可知</strong>的各种基本数据类型(boolean、byte、int、short、long、float、double、char)、对象引用（reference类型，它不等同于对象本身，可能是一个指向对象起始地址的引用指针，也可能是指向一个代表对象的<a href="https://baike.baidu.com/item/%E5%8F%A5%E6%9F%84/3527587?fr=aladdin" target="_blank" rel="external">句柄</a>或其他与此对象相关的位置）和returnAddress类型（指向了一条字节码指令的地址）。<br>在Java虚拟机规范中，对这个区域规定了两种异常情况：如果线程请求的栈深读大于虚拟机所允许的深度，将抛出StackOverflowError异常；如果虚拟机栈可以动态扩展（当前大部分的Java虚拟机都可以动态扩展，只不过Java虚拟机规范中也允许固定长度的虚拟机栈），如果扩展时无法申请到足够的内存，就会抛出OutOfMemoryError异常。</p><h3 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h3><p>本地方法栈（Native Method Shack）与虚拟机栈所发挥的作用非常相似的，它们之间的区别不过是虚拟机栈为虚拟机执行Java（也就是字节码）服务，而本地方法栈则为虚拟机使用到的Native方法服务。在虚拟机规范中对本地方法栈中方法使用的语言、使用方式与数据结构并没有强制规定，因此具体的虚拟机可以自由实现它。甚至有的虚拟机（譬如Sun HotSpot虚拟机）直接就把本地方法栈和虚拟机栈合二为一。与虚拟机栈一样，本地方法也可以抛出StackOverflowError和OutOfMemorryError异常。</p><h3 id="Java堆"><a href="#Java堆" class="headerlink" title="Java堆"></a>Java堆</h3><p>对于大多数应用来说，Java堆（Java Heap）是Java虚拟机所管理的内存中最大的一块。Java堆是被所有线程共享的一块内存区域，在虚拟机启动时创建。此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例都在这里分配内存</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Java虚拟机在执行Java程序的过程会把它管理的内存划分为若干个不同的数据区域。&lt;/p&gt;
    
    </summary>
    
      <category term="Understanding The JVM" scheme="http://yoursite.com/categories/Understanding-The-JVM/"/>
    
    
      <category term="JVM" scheme="http://yoursite.com/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>Lock的使用</title>
    <link href="http://yoursite.com/2017/11/16/Lock%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>http://yoursite.com/2017/11/16/Lock的使用/</id>
    <published>2017-11-16T01:41:55.000Z</published>
    <updated>2017-11-16T01:33:03.616Z</updated>
    
    <content type="html"><![CDATA[<p>使用Java5中Lock对象也能实现同步的效果，而且在使用上也更加方便。</p><a id="more"></a><h2 id="使用ReentrantLock类的使用"><a href="#使用ReentrantLock类的使用" class="headerlink" title="使用ReentrantLock类的使用"></a>使用ReentrantLock类的使用</h2><div align="center"><br><img src="/images/Thread/si1.jpg" alt=""><br>图1 “饿汉模式”的运行结果</div><p><a href="https://github.com/5iyxx/JavaMulti-threadProgramming.git" target="_blank" rel="external">Java多线程编程核心技术源代码</a>。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;使用Java5中Lock对象也能实现同步的效果，而且在使用上也更加方便。&lt;/p&gt;
    
    </summary>
    
      <category term="JavaMulti-threadProgramming" scheme="http://yoursite.com/categories/JavaMulti-threadProgramming/"/>
    
    
      <category term="Thread" scheme="http://yoursite.com/tags/Thread/"/>
    
  </entry>
  
  <entry>
    <title>延迟加载(懒汉模式)</title>
    <link href="http://yoursite.com/2017/11/14/%E5%BB%B6%E8%BF%9F%E5%8A%A0%E8%BD%BD(%E6%87%92%E6%B1%89%E6%A8%A1%E5%BC%8F)/"/>
    <id>http://yoursite.com/2017/11/14/延迟加载(懒汉模式)/</id>
    <published>2017-11-14T12:30:55.000Z</published>
    <updated>2017-11-14T16:28:26.817Z</updated>
    
    <content type="html"><![CDATA[<p>什么是延迟加载？延迟加载就是字啊调用get()方法时实例才被创建，常见的实现方法就是在get()方法中进行new实例化。而延迟加载从中文的语境来看，是“缓慢”、“不急迫”的含义，所以也称为“懒汉模式”。</p><a id="more"></a><h3 id="延迟加载-“懒汉模式”解析"><a href="#延迟加载-“懒汉模式”解析" class="headerlink" title="延迟加载/“懒汉模式”解析"></a>延迟加载/“懒汉模式”解析</h3><p>延迟加载/“懒汉模式”解析是在调用方法时实例才被创建。<br><strong>代码清单1 懒汉模式</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">public class MyObject &#123;</div><div class="line">private static MyObject myObject;</div><div class="line"></div><div class="line">private MyObject() &#123;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line">public static MyObject getInstance() &#123;</div><div class="line">// 延迟加载</div><div class="line">if (myObject != null) &#123;</div><div class="line"></div><div class="line">&#125; else &#123;</div><div class="line">myObject = new MyObject();</div><div class="line">&#125;</div><div class="line">return myObject;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">public class MyThread extends Thread &#123;</div><div class="line"></div><div class="line">@Override</div><div class="line">public void run() &#123;</div><div class="line">System.out.println(MyObject.getInstance().hashCode());</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">public class Run &#123;</div><div class="line"></div><div class="line">public static void main(String[] args) &#123;</div><div class="line">MyThread t1 = new MyThread();</div><div class="line">t1.start();</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>运行结果如图1所示，虽然取得一个对象的实例，但如果是在多线程的环境中，就会出现取出多个实例的情况，与单例模式的初衷是相背离的。</p><div align="center"><br><img src="/images/Thread/lh1.jpg" alt=""><br>图1 “饿汉模式”成功取出一个实例</div><h3 id="延迟加载-”懒汉模式“的缺点"><a href="#延迟加载-”懒汉模式“的缺点" class="headerlink" title="延迟加载/”懒汉模式“的缺点"></a>延迟加载/”懒汉模式“的缺点</h3><p>前面的两个测试虽然使用了“<a href="https://5iyxx.github.io/2017/11/14/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E4%B8%8E%E5%A4%9A%E7%BA%BF%E7%A8%8B/" target="_blank" rel="external">立即加载</a>”和“延迟加载”实现了单例设计模式，但在多线程的环境中，前面“延迟加载”示例中的代码完全就是错误的，根本不能实现保存单例的状态。来看一下如何在多线程环境中结合“错误的单例模式”创建出“多例”。<br><strong>代码清单2 “多例”</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line">public class MyObject &#123;</div><div class="line">private static MyObject myObject;</div><div class="line"></div><div class="line">private MyObject() &#123;</div><div class="line"></div><div class="line">&#125;</div><div class="line">public static MyObject getInstance() &#123;</div><div class="line">try &#123;</div><div class="line">if (myObject != null) &#123;</div><div class="line">&#125; else &#123;</div><div class="line">// 模拟在创建对象之前做一些准备性的工作</div><div class="line">Thread.sleep(3000);</div><div class="line">myObject = new MyObject();</div><div class="line">&#125;</div><div class="line">&#125; catch (InterruptedException e) &#123;</div><div class="line">e.printStackTrace();</div><div class="line">&#125;</div><div class="line">return myObject;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">public class MyThread extends Thread &#123;</div><div class="line"></div><div class="line">@Override</div><div class="line">public void run() &#123;</div><div class="line">System.out.println(MyObject.getInstance().hashCode());</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">public class Run &#123;</div><div class="line"></div><div class="line">public static void main(String[] args) &#123;</div><div class="line">MyThread t1 = new MyThread();</div><div class="line">MyThread t2 = new MyThread();</div><div class="line">MyThread t3= new MyThread();</div><div class="line">t1.start();</div><div class="line">t2.start();</div><div class="line">t3.start();</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>运行结果如图2所示，打印出来了3种hasCode，说明创建出了3个对象，并不是单例的，这就是“错误的单例模式”。</p><div align="center"><br><img src="/images/Thread/lh2.jpg" alt=""><br>图2 非单例设计模式</div><h3 id="延迟加载-“懒汉模式”的解决方案"><a href="#延迟加载-“懒汉模式”的解决方案" class="headerlink" title="延迟加载/“懒汉模式”的解决方案"></a>延迟加载/“懒汉模式”的解决方案</h3><h4 id="声明synchronized关键字"><a href="#声明synchronized关键字" class="headerlink" title="声明synchronized关键字"></a>声明synchronized关键字</h4><p>在代码清单2中<code>public static MyObject getInstance()</code>前加上synchronized。运行结果如图3所示。</p><div align="center"><br><img src="/images/Thread/lh3.jpg" alt=""><br>图3 运行结果</div><p>此方法加入同步synchronized关键字得到相同实例的对象，但此方法的运行效率非常低下，是同步运行的，下一个线程想要取得对象，则必须等上一个线程释放锁之后，才可以继续运行。</p><h4 id="尝试同步方法块"><a href="#尝试同步方法块" class="headerlink" title="尝试同步方法块"></a>尝试同步方法块</h4><p>同步方法是对方法的整体进行持锁，这对运行效率来讲是不利的。改成同步代码块能解决吗？<br><strong>代码清单3 代码块</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line">public class MyObject &#123;</div><div class="line">private static MyObject myObject;</div><div class="line"></div><div class="line">private MyObject() &#123;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line">public static MyObject getInstance() &#123;</div><div class="line">try &#123;</div><div class="line">synchronized (MyObject.class) &#123;</div><div class="line">if (myObject != null) &#123;</div><div class="line">&#125; else &#123;</div><div class="line">// 模拟在创建对象之前做一些准备性的工作</div><div class="line">Thread.sleep(3000);</div><div class="line">myObject = new MyObject();</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125; catch (InterruptedException e) &#123;</div><div class="line">e.printStackTrace();</div><div class="line">&#125;</div><div class="line">return myObject;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">public class MyThread extends Thread &#123;</div><div class="line"></div><div class="line">@Override</div><div class="line">public void run() &#123;</div><div class="line">System.out.println(MyObject.getInstance().hashCode());</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">public class Run &#123;</div><div class="line"></div><div class="line">public static void main(String[] args) &#123;</div><div class="line">MyThread t1 = new MyThread();</div><div class="line">MyThread t2 = new MyThread();</div><div class="line">MyThread t3= new MyThread();</div><div class="line">t1.start();</div><div class="line">t2.start();</div><div class="line">t3.start();</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>运行结果如图4所示，此方法加入同步synchronized语句块得带相同实例的对象，但此方法的运行效率也是非常低的，和synchronized同步方法一样是同步运行的。继续更改代码尝试解决这个缺点。</p><div align="center"><br><img src="/images/Thread/lh4.jpg" alt=""><br>图4 运行结果</div><h4 id="针对某些重要的代码进行单独的同步"><a href="#针对某些重要的代码进行单独的同步" class="headerlink" title="针对某些重要的代码进行单独的同步"></a>针对某些重要的代码进行单独的同步</h4><p>同步代码块可以针对某些重要的代码进行单独的同步，而其他的代码则不需要同步。这样在运行时，效率完全可以得到大幅提升，对代码清单4中的代码进行修改。<br><strong>代码清单5 修改MyObject类</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">public class MyObject &#123;</div><div class="line">private static MyObject myObject;</div><div class="line"></div><div class="line">private MyObject() &#123;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line">public static MyObject getInstance() &#123;</div><div class="line">try &#123;</div><div class="line">if (myObject != null) &#123;</div><div class="line">&#125; else &#123;</div><div class="line">// 模拟在创建对象之前做一些准备性的工作</div><div class="line">Thread.sleep(3000);</div><div class="line">                    //使用synchronized (MyObject.class)</div><div class="line">                    //虽然部分代码被上锁</div><div class="line">                    //但还是有非线性安全问题</div><div class="line">synchronized (MyObject.class) &#123;</div><div class="line">myObject = new MyObject();</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125; catch (InterruptedException e) &#123;</div><div class="line">e.printStackTrace();</div><div class="line">&#125;</div><div class="line">return myObject;</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>运行结果如图5所示，此方法使用同步synchronized语句块，只对实例化对象的关键代码进行同步，从语句的结构来讲，运行的效率的确得到了提升。但如果是遇到多线程的情况下还是无法解决得到同一个实例对象的结果。到底如何解决“懒汉模式”遇到多线程的情况呢？</p><div align="center"><br><img src="/images/Thread/lh5.jpg" alt=""><br>图5 运行结果</div><h4 id="使用DCL双检查锁机制"><a href="#使用DCL双检查锁机制" class="headerlink" title="使用DCL双检查锁机制"></a>使用DCL双检查锁机制</h4><p>在最后的步骤中，使用的是DCL双检查锁机制来实现多线程环境中的延迟加载单例设计模式。对代码清单4中的代码进行修改。<br><strong>代码清单6 修改MyObject类</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">public class MyObject &#123;</div><div class="line">private static MyObject myObject;</div><div class="line"></div><div class="line">private MyObject() &#123;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line">public static MyObject getInstance() &#123;</div><div class="line">try &#123;</div><div class="line"></div><div class="line">if (myObject != null) &#123;</div><div class="line">&#125; else &#123;</div><div class="line">// 模拟在创建对象之前做一些准备性的工作</div><div class="line">Thread.sleep(3000);</div><div class="line">synchronized (MyObject.class) &#123;</div><div class="line">if (myObject == null) &#123;</div><div class="line">myObject = new MyObject();</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125; catch (InterruptedException e) &#123;</div><div class="line">e.printStackTrace();</div><div class="line">&#125;</div><div class="line">return myObject;</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>运行结果如图6所示，使用双重检查锁功能，成功地解决了“懒汉模式”遇到多线程的问题。<strong>DCL也是大多数线程结合单例模式使用的解决方案</strong>。</p><div align="center"><br><img src="/images/Thread/lh6.jpg" alt=""><br>图6 运行结果</div><p><a href="https://github.com/5iyxx/JavaMulti-threadProgramming.git" target="_blank" rel="external">Java多线程编程核心技术源代码</a>。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;什么是延迟加载？延迟加载就是字啊调用get()方法时实例才被创建，常见的实现方法就是在get()方法中进行new实例化。而延迟加载从中文的语境来看，是“缓慢”、“不急迫”的含义，所以也称为“懒汉模式”。&lt;/p&gt;
    
    </summary>
    
      <category term="JavaMulti-threadProgramming" scheme="http://yoursite.com/categories/JavaMulti-threadProgramming/"/>
    
    
      <category term="Thread" scheme="http://yoursite.com/tags/Thread/"/>
    
  </entry>
  
  <entry>
    <title>单例模式与多线程</title>
    <link href="http://yoursite.com/2017/11/14/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E4%B8%8E%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    <id>http://yoursite.com/2017/11/14/单例模式与多线程/</id>
    <published>2017-11-14T07:41:55.000Z</published>
    <updated>2017-11-14T10:31:42.428Z</updated>
    
    <content type="html"><![CDATA[<p>如何使单例模式遇到多线程是安全的、正确的。</p><a id="more"></a><h3 id="立即加载-“饿汗模式”"><a href="#立即加载-“饿汗模式”" class="headerlink" title="立即加载/“饿汗模式”"></a>立即加载/“饿汗模式”</h3><p>什么是立即加载？立即加载就是使用类的时候已经将对象创建完毕，常见的实现办法就是直接new实例化。而立即加载从中文的语境来看，有“着急”、”急迫”的含义，所以也称为“饿汉模式”。<br>立即加载/“饿汉模式”是在调用方法前，实例已经被创建了。<br><strong>代码清单1 饿汉模式</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">public class MyObject &#123;</div><div class="line">//立即加载方式==饿汉模式</div><div class="line">private  static MyObject myObject=new MyObject();</div><div class="line">private MyObject()&#123;</div><div class="line"></div><div class="line">&#125;</div><div class="line">public static MyObject getInstance()&#123;</div><div class="line">//此版本代码为立即加载</div><div class="line">//此版本代码的缺点是不能有其他实例变量</div><div class="line">//因为getInstance()方法没有同步</div><div class="line">//所以有可能出现非线性安全问题</div><div class="line">return myObject;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">public class MyThread extends Thread &#123;</div><div class="line"></div><div class="line">@Override</div><div class="line">public void run() &#123;</div><div class="line">System.out.println(MyObject.getInstance().hashCode());</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">public class Run &#123;</div><div class="line"></div><div class="line">public static void main(String[] args) &#123;</div><div class="line">MyThread t1 = new MyThread();</div><div class="line">MyThread t2 = new MyThread();</div><div class="line">MyThread t3= new MyThread();</div><div class="line">t1.start();</div><div class="line">t2.start();</div><div class="line">t3.start();</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>运行结果如图1所示，打印的hashCode是同一个值，说明对象是同一个，也就实现了立即加载型单例设计模式。</p><div align="center"><br><img src="/images/Thread/si1.jpg" alt=""><br>图1 “饿汉模式”的运行结果</div><h3 id="延迟加载-“懒汉模式”"><a href="#延迟加载-“懒汉模式”" class="headerlink" title="延迟加载/“懒汉模式”"></a>延迟加载/“懒汉模式”</h3><p>什么是延迟加载？延迟加载就是字啊调用get()方法时实例才被创建，常见的实现方法就是在get()方法中进行new实例化。而延迟加载从中文的语境来看，是“缓慢”、“不急迫”的含义，所以也称为“懒汉模式”。</p><p><a href="https://github.com/5iyxx/JavaMulti-threadProgramming.git" target="_blank" rel="external">Java多线程编程核心技术源代码</a>。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;如何使单例模式遇到多线程是安全的、正确的。&lt;/p&gt;
    
    </summary>
    
      <category term="JavaMulti-threadProgramming" scheme="http://yoursite.com/categories/JavaMulti-threadProgramming/"/>
    
    
      <category term="Thread" scheme="http://yoursite.com/tags/Thread/"/>
    
  </entry>
  
  <entry>
    <title>定时器Timer</title>
    <link href="http://yoursite.com/2017/11/13/%E5%AE%9A%E6%97%B6%E5%99%A8Timer/"/>
    <id>http://yoursite.com/2017/11/13/定时器Timer/</id>
    <published>2017-11-13T14:50:15.000Z</published>
    <updated>2017-11-14T07:53:14.138Z</updated>
    
    <content type="html"><![CDATA[<p>定时计划任务功能在Java中主要使用的就是Timer对象，它在内部使用多线程的方式进行处理，所以它和其它线程技术上还是有非常大的关联的。</p><a id="more"></a><h3 id="定时器Timer的使用"><a href="#定时器Timer的使用" class="headerlink" title="定时器Timer的使用"></a>定时器Timer的使用</h3><p>在JDK库中Timer类主要负责计划任务的功能，也就是在指定的时间开始执行某一个任务。Timer类的方法列表如图1所示。<br>Timer类的主要作用就是设置计划任务，但封装任务的类却是TimerTask类，类结构如图2所示。执行计划任务的代码要放入TimerTask的子类中，因为因为TimerTask是一个抽象类。</p><div align="center"><br><img src="/images/Thread/ti1.jpg" alt=""><br>图1 类Timer的方法列表</div><div align="center"><br><img src="/images/Thread/ti2.jpg" alt=""><br>图2 类TimerTask类相关的信息</div><h3 id="方法schedule-TimerTask-task，Date-time-的测试"><a href="#方法schedule-TimerTask-task，Date-time-的测试" class="headerlink" title="方法schedule(TimerTask task，Date time)的测试"></a>方法schedule(TimerTask task，Date time)的测试</h3><p>该方法的作用是在指定的日期执行一次某一任务。<br>1 执行任务的时间晚于当前的时间：在未来执行的效果</p><p><strong>代码清单1 在未来执行的效果</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">public class Run1 &#123;</div><div class="line"></div><div class="line">private static Timer timer = new Timer();</div><div class="line"></div><div class="line">static public class MyTask extends TimerTask &#123;</div><div class="line">@Override</div><div class="line">public void run() &#123;</div><div class="line">System.out.println(&quot;运行了！时间为：&quot; + new Date());</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">public static void main(String[] args) &#123;</div><div class="line">try &#123;</div><div class="line">MyTask task = new MyTask();</div><div class="line">SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);</div><div class="line">String dateString = &quot;2017-11-13 23:46:38&quot;;</div><div class="line"></div><div class="line">Date dateRef = sdf.parse(dateString);</div><div class="line">System.out.println(&quot;字符串时间&quot; + dateRef.toLocaleString() + &quot; 当前时间&quot;</div><div class="line">+ new Date().toLocaleString());</div><div class="line">timer.schedule(task, dateRef);</div><div class="line">&#125; catch (ParseException e) &#123;</div><div class="line">e.printStackTrace();</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>程序运行后的结果如图3所示。任务虽然执行完了，但进程还未销毁，为什么会出现这样的情况？</p><div align="center"><br><img src="/images/Thread/ti3.jpg" alt=""><br>图3 运行结果</div><p>在创建Timer对象时，JDK源码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">public Timer()&#123;</div><div class="line">this(&quot;Timer-&quot;+serialNumber());</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>此构造方法调用的是如下构造方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">public Timer(String name)&#123;</div><div class="line">thread.setName(name);</div><div class="line">thread.start();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>查看构造方法可以得知，创建一个Timer就是启动一个新的线程，这个新启动的线程并不是守护线程，它一直在运行。<br>查看构造方法可以得知，创建一个Timer就是启动一个新的线程，这个新启动的线程并不是守护线程，它一直在运行。<br><strong>代码清单2 Timer的守护线程</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">public class Run1TimerIsDaemon &#123;</div><div class="line"></div><div class="line">private static Timer timer = new Timer(true);</div><div class="line"></div><div class="line">static public class MyTask extends TimerTask &#123;</div><div class="line">@Override</div><div class="line">public void run() &#123;</div><div class="line">System.out.println(&quot;运行了！时间为：&quot; + new Date());</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">public static void main(String[] args) &#123;</div><div class="line">try &#123;</div><div class="line">MyTask task = new MyTask();</div><div class="line">SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);</div><div class="line">String dateString = &quot;2017-11-13 22:07:16&quot;;</div><div class="line">//Timer timer=new Timer();</div><div class="line">Date dateRef = sdf.parse(dateString);</div><div class="line">System.out.println(&quot;字符串时间：&quot; + dateRef.toLocaleString() + &quot; 当前时间：&quot; + new Date().toLocaleString());</div><div class="line">timer.schedule(task, dateRef);</div><div class="line">&#125; catch (ParseException e) &#123;</div><div class="line">e.printStackTrace();</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>程序运行后迅速结束当前的进程，并且TimerTask中的任务不再被运行，因为线程已经结束了。</p><div align="center"><br><img src="/images/Thread/ti4.jpg" alt=""><br>图4 守护线程创建成功进程退出</div><p>2 计划时间早于当前时间：提前运行的效果</p><p>如果执行任务的时间早于当前时间，则立即执行task任务。将代码清单2中<code>//Timer timer=new Timer();</code>注释去掉。</p><div align="center"><br><img src="/images/Thread/ti5.jpg" alt=""><br>图5 立即执行task任务</div><p>3 多个TimerTask任务及延时的测试</p><p>Timer中允许有多个TimerTask任务。<br><strong>代码清单3 多个TimerTask任务</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line">public class Run2 &#123;</div><div class="line"></div><div class="line">private static Timer timer = new Timer();</div><div class="line"></div><div class="line">static public class MyTask1 extends TimerTask &#123;</div><div class="line">@Override</div><div class="line">public void run() &#123;</div><div class="line">System.out.println(&quot;运行了！时间为：&quot; + new Date());</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">static public class MyTask2 extends TimerTask &#123;</div><div class="line">@Override</div><div class="line">public void run() &#123;</div><div class="line">System.out.println(&quot;运行了！时间为：&quot; + new Date());</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">public static void main(String[] args) &#123;</div><div class="line">try &#123;</div><div class="line">MyTask1 task1 = new MyTask1();</div><div class="line">MyTask2 task2 = new MyTask2();</div><div class="line"></div><div class="line">SimpleDateFormat sdf1 = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);</div><div class="line">SimpleDateFormat sdf2 = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);</div><div class="line"></div><div class="line">String dateString1 = &quot;2017-11-14 10:21:48&quot;;</div><div class="line">String dateString2 = &quot;2017-11-14 10:21:49&quot;;</div><div class="line"></div><div class="line">Date dateRef1 = sdf1.parse(dateString1);</div><div class="line">Date dateRef2 = sdf2.parse(dateString2);</div><div class="line"></div><div class="line">System.out.println(&quot;字符串1时间&quot; + dateRef1.toLocaleString() + &quot; 当前时间：&quot;</div><div class="line">+ new Date().toLocaleString());</div><div class="line">System.out.println(&quot;字符串2时间&quot; + dateRef2.toLocaleString() + &quot; 当前时间：&quot;</div><div class="line">+ new Date().toLocaleString());</div><div class="line"></div><div class="line">timer.schedule(task1, dateRef1);</div><div class="line">timer.schedule(task2, dateRef2);</div><div class="line">&#125; catch (ParseException e) &#123;</div><div class="line">e.printStackTrace();</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>程序运行结果如图6所示。</p><div align="center"><br><img src="/images/Thread/ti6.jpg" alt=""><br>图6 一个Timer中可以运行多个TimerTask</div><p>TimerTask是以队列的方式一个一个被顺序执行的，所以执行的时间有可能和预期的时间不一致，因为前面的任务有可能消耗的时间较长，则后面的任务运行的时间也会被延迟。<br><strong>代码清单4 任务运行被延迟</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div></pre></td><td class="code"><pre><div class="line">public class Run2Later &#123;</div><div class="line"></div><div class="line">private static Timer timer = new Timer();</div><div class="line"></div><div class="line">static public class MyTask1 extends TimerTask &#123;</div><div class="line">@Override</div><div class="line">public void run() &#123;</div><div class="line">try &#123;</div><div class="line">System.out.println(&quot;1 begin 运行了！时间为：&quot; + new Date());</div><div class="line">Thread.sleep(20000);</div><div class="line">System.out.println(&quot;1   end 运行了！时间为：&quot; + new Date());</div><div class="line">&#125; catch (InterruptedException e) &#123;</div><div class="line">e.printStackTrace();</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">static public class MyTask2 extends TimerTask &#123;</div><div class="line">@Override</div><div class="line">public void run() &#123;</div><div class="line">System.out.println(&quot;2 begin 运行了！时间为：&quot; + new Date());</div><div class="line">System.out.println(&quot;运行了！时间为：&quot; + new Date());</div><div class="line">System.out.println(&quot;2   end 运行了！时间为：&quot; + new Date());</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">public static void main(String[] args) &#123;</div><div class="line">try &#123;</div><div class="line">MyTask1 task1 = new MyTask1();</div><div class="line">MyTask2 task2 = new MyTask2();</div><div class="line"></div><div class="line">SimpleDateFormat sdf1 = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);</div><div class="line">SimpleDateFormat sdf2 = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);</div><div class="line"></div><div class="line">String dateString1 = &quot;2017-11-14 10:30:18&quot;;</div><div class="line">String dateString2 = &quot;2017-11-14 10:30:28&quot;;</div><div class="line"></div><div class="line">Date dateRef1 = sdf1.parse(dateString1);</div><div class="line">Date dateRef2 = sdf2.parse(dateString2);</div><div class="line"></div><div class="line">System.out.println(&quot;字符串1时间：&quot; + dateRef1.toLocaleString() + &quot; 当前时间：&quot;</div><div class="line">+ new Date().toLocaleString());</div><div class="line">System.out.println(&quot;字符串2时间：&quot; + dateRef2.toLocaleString() + &quot; 当前时间：&quot;</div><div class="line">+ new Date().toLocaleString());</div><div class="line"></div><div class="line">timer.schedule(task1, dateRef1);</div><div class="line">timer.schedule(task2, dateRef2);</div><div class="line">&#125; catch (ParseException e) &#123;</div><div class="line">e.printStackTrace();</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>由于task1需要用时20秒执行完成任务，task1开始的时间是2017-11-14 10:30:18，那么将要影响task2的计划任务的时间，task2以此时间为基准，向后延迟20秒，task2在11:33:20执行任务。<strong>因为Task是被放入队列中的，得一个一个顺序运行</strong>。</p><p>程序运行结果如图6所示。</p><div align="center"><br><img src="/images/Thread/ti7.jpg" alt=""><br>图7 任务2的运行时间被延迟了</div><h3 id="方法schedule-TimerTask-task，Date-time，long-period-的测试"><a href="#方法schedule-TimerTask-task，Date-time，long-period-的测试" class="headerlink" title="方法schedule(TimerTask task，Date time，long period)的测试"></a>方法schedule(TimerTask task，Date time，long period)的测试</h3><p>该方法的作用是指在指定日期之后，按指定的间隔周期性地无限循环执行某一任务。<br>1 计划时间晚于当前时间：在未来执行的效果。</p><p><strong>代码清单5 在未来的时间开始循环执行</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">public class Run &#123;</div><div class="line">static public class MyTask extends TimerTask &#123;</div><div class="line">@Override</div><div class="line">public void run() &#123;</div><div class="line">System.out.println(&quot;运行了！时间为：&quot; + new Date());</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">public static void main(String[] args) &#123;</div><div class="line">try &#123;</div><div class="line">MyTask task = new MyTask();</div><div class="line">SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);</div><div class="line">String dateString = &quot;2017-11-14 10:46:11&quot;;</div><div class="line">Timer timer = new Timer();</div><div class="line">Date dateRef = sdf.parse(dateString);</div><div class="line">System.out.println(&quot;字符串时间：&quot; + dateRef.toLocaleString() + &quot; 当前时间：&quot;</div><div class="line">+ new Date().toLocaleString());</div><div class="line">timer.schedule(task, dateRef, 4000);</div><div class="line">&#125; catch (ParseException e) &#123;</div><div class="line">e.printStackTrace();</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>运行结果如图8所示，每隔4秒运行一次TimerTask，并且无限期地重复执行。</p><div align="center"><br><img src="/images/Thread/ti8.jpg" alt=""><br>图8 运行结果</div><p>2 计划时间早于当前时间：提前运行的效果</p><p>如果计划时间早于当前时间，则立即执行task。<br>运行代码清单5中程序，运行结果如图9所示。</p><div align="center"><br><img src="/images/Thread/ti9.jpg" alt=""><br>图9 立即执行task任务</div><p>3 任务执行时间被延迟时</p><p><strong>代码清单6 任务执行时间被延迟</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">public class Run2_1 &#123;</div><div class="line">static public class MyTaskA extends TimerTask &#123;</div><div class="line">@Override</div><div class="line">public void run() &#123;</div><div class="line">try &#123;</div><div class="line">System.out.println(&quot;A运行了！时间为：&quot; + new Date());</div><div class="line">Thread.sleep(5000);</div><div class="line">System.out.println(&quot;A结束了！时间为：&quot; + new Date());</div><div class="line">&#125; catch (InterruptedException e) &#123;</div><div class="line">e.printStackTrace();</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">public static void main(String[] args) &#123;</div><div class="line">try &#123;</div><div class="line">MyTaskA taskA = new MyTaskA();</div><div class="line">SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);</div><div class="line">String dateString = &quot;2015-3-19 14:14:00&quot;;</div><div class="line">Timer timer = new Timer();</div><div class="line">Date dateRef = sdf.parse(dateString);</div><div class="line">System.out.println(&quot;字符串时间：&quot; + dateRef.toLocaleString() + &quot; 当前时间：&quot;</div><div class="line">+ new Date().toLocaleString());</div><div class="line">timer.schedule(taskA, dateRef, 4000);</div><div class="line">&#125; catch (ParseException e) &#123;</div><div class="line">e.printStackTrace();</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>运行结果如图10所示，任务被延时了但还是一个一个顺序运行。</p><div align="center"><br><img src="/images/Thread/ti10.jpg" alt=""><br>图10 运行结果</div><p>4 TimerTask类的cancel()方法</p><p>TimerTask类中的cancel()方法的作用是将自身从任何队列中清楚。<br><strong>代码清单7 TimerTask类的cancel()方法</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">public class Run2 &#123;</div><div class="line">static public class MyTaskA extends TimerTask &#123;</div><div class="line">@Override</div><div class="line">public void run() &#123;</div><div class="line">System.out.println(&quot;A运行了！时间为：&quot; + new Date());</div><div class="line">this.cancel();</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">static public class MyTaskB extends TimerTask &#123;</div><div class="line">@Override</div><div class="line">public void run() &#123;</div><div class="line">System.out.println(&quot;B运行了！时间为：&quot; + new Date());</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">public static void main(String[] args) &#123;</div><div class="line">try &#123;</div><div class="line">MyTaskA taskA = new MyTaskA();</div><div class="line">MyTaskB taskB = new MyTaskB();</div><div class="line">SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);</div><div class="line">String dateString = &quot;2014-10-12 09:12:00&quot;;</div><div class="line">Timer timer = new Timer();</div><div class="line">Date dateRef = sdf.parse(dateString);</div><div class="line">System.out.println(&quot;字符串时间：&quot; + dateRef.toLocaleString() + &quot; 当前时间：&quot;</div><div class="line">+ new Date().toLocaleString());</div><div class="line">timer.schedule(taskA, dateRef, 4000);</div><div class="line">timer.schedule(taskB, dateRef, 4000);</div><div class="line">&#125; catch (ParseException e) &#123;</div><div class="line">e.printStackTrace();</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>TimerTask类的cancel()方法是将自身从任务队列中被移除，其他任务不受影响。</p><div align="center"><br><img src="/images/Thread/ti11.jpg" alt=""><br>图11 TimerTaskA仅运行一次后被清楚了</div><p>5 Timer类的cancel()方法</p><p>和TimerTask类中的cancel()方法清楚自身不同，Timer类中的cancel()方法的作用是将任务队列中的全部任务清空。<br><strong>代码清单8 Timer类的cancel()方法</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line">public class Run3 &#123;</div><div class="line">private static Timer timer = new Timer();</div><div class="line"></div><div class="line">static public class MyTaskA extends TimerTask &#123;</div><div class="line">@Override</div><div class="line">public void run() &#123;</div><div class="line">System.out.println(&quot;A运行了！时间为：&quot; + new Date());</div><div class="line">timer.cancel();</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">static public class MyTaskB extends TimerTask &#123;</div><div class="line">@Override</div><div class="line">public void run() &#123;</div><div class="line">System.out.println(&quot;B运行了！时间为：&quot; + new Date());</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">public static void main(String[] args) &#123;</div><div class="line">try &#123;</div><div class="line">MyTaskA taskA = new MyTaskA();</div><div class="line">MyTaskB taskB = new MyTaskB();</div><div class="line">SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);</div><div class="line">String dateString = &quot;2017-11-14 11:38:23&quot;;</div><div class="line">Date dateRef = sdf.parse(dateString);</div><div class="line">System.out.println(&quot;字符串时间：&quot; + dateRef.toLocaleString() + &quot; 当前时间：&quot;</div><div class="line">+ new Date().toLocaleString());</div><div class="line">timer.schedule(taskA, dateRef, 4000);</div><div class="line">timer.schedule(taskB, dateRef, 4000);</div><div class="line">&#125; catch (ParseException e) &#123;</div><div class="line">e.printStackTrace();</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>运行结果如图12所示，全部任务被清除，并且进程被销毁，按钮有红色变为灰色。</p><div align="center"><br><img src="/images/Thread/ti12.jpg" alt=""><br>图12 进程被清空</div><p>6 Timer的cancel()方法注意事项</p><p>Timer类中的cancel()方法有时并不一定会停止执行计划任务，而是正常执行。<br><strong>代码清单9 cancel不一定能停止执行计划</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">public class Run4 &#123;</div><div class="line">static int i = 0;</div><div class="line"></div><div class="line">static public class MyTask extends TimerTask &#123;</div><div class="line">@Override</div><div class="line">public void run() &#123;</div><div class="line">System.out.println(&quot;正常执行了&quot; + i);</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">public static void main(String[] args) &#123;</div><div class="line">while (true) &#123;</div><div class="line">try &#123;</div><div class="line">i++;</div><div class="line">Timer timer = new Timer();</div><div class="line">MyTask task = new MyTask();</div><div class="line">SimpleDateFormat sdf = new SimpleDateFormat(</div><div class="line">&quot;yyyy-MM-dd HH:mm:ss&quot;);</div><div class="line">String dateString = &quot;2017-11-14 11:54:12&quot;;</div><div class="line"></div><div class="line">Date dateRef = sdf.parse(dateString);</div><div class="line">timer.schedule(task, dateRef);</div><div class="line">timer.cancel();</div><div class="line">&#125; catch (ParseException e) &#123;</div><div class="line">e.printStackTrace();</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>运行结果如图13所示。这是因为Timer类中的cancel()方法有时并没有争抢到queue锁，所以TimerTask 正常运行。</p><div align="center"><br><img src="/images/Thread/ti13.jpg" alt=""><br>图13 并没有停止</div><h3 id="方法schedule-TimerTask-task-long-delay-的测试"><a href="#方法schedule-TimerTask-task-long-delay-的测试" class="headerlink" title="方法schedule(TimerTask task,long delay)的测试"></a>方法schedule(TimerTask task,long delay)的测试</h3><p>该方法的作用是以执行schedule(TimerTask task,long delay)方法当前的时间为参考时间，在此时间基础上延迟指定的毫秒数后执行一次TimerTask任务。<br><strong>代码清单10 延迟执行一次</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">public class Run &#123;</div><div class="line">static public class MyTask extends TimerTask &#123;</div><div class="line">@Override</div><div class="line">public void run() &#123;</div><div class="line">System.out.println(&quot;运行了！时间为：&quot; + new Date());</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">public static void main(String[] args) &#123;</div><div class="line">MyTask task = new MyTask();</div><div class="line">Timer timer = new Timer();</div><div class="line">System.out.println(&quot;当前时间?&quot; + new Date().toLocaleString());</div><div class="line">timer.schedule(task, 7000);</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>任务task被延迟7秒执行，如图14所示。</p><div align="center"><br><img src="/images/Thread/ti14.jpg" alt=""><br>图14 运行结果</div><h3 id="方法schedule-TimerTask-task-long-delay，long-period-的测试"><a href="#方法schedule-TimerTask-task-long-delay，long-period-的测试" class="headerlink" title="方法schedule(TimerTask task,long delay，long period)的测试"></a>方法schedule(TimerTask task,long delay，long period)的测试</h3><p>该方法的作用是以执行schedule(TimerTask task,long delay,long period)方法当前的时间Wie参考时间，在此时间基础上延迟指定的毫秒数，再以某一间隔时间无限次数地执行某一任务。<br><strong>代码清单11  无限循环</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">public class Run &#123;</div><div class="line">static public class MyTask extends TimerTask &#123;</div><div class="line">@Override</div><div class="line">public void run() &#123;</div><div class="line">System.out.println(&quot;运行了！时间为：&quot; + new Date());</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">public static void main(String[] args) &#123;</div><div class="line">MyTask task = new MyTask();</div><div class="line">Timer timer = new Timer();</div><div class="line">System.out.println(&quot;当前时间&quot;+new Date().toLocaleString());</div><div class="line">timer.schedule(task, 3000,5000);</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>凡是使用方法带有period参数的，都是无限循环执行TimerTask中的任务。</p><div align="center"><br><img src="/images/Thread/ti15.jpg" alt=""><br>图15 循环运行</div><h3 id="方法scheduleAtFixedRate-TimerTask-task-Date-firstTime-long-period-的测试"><a href="#方法scheduleAtFixedRate-TimerTask-task-Date-firstTime-long-period-的测试" class="headerlink" title="方法scheduleAtFixedRate(TimerTask task,Date firstTime,long period)的测试"></a>方法scheduleAtFixedRate(TimerTask task,Date firstTime,long period)的测试</h3><p>方法schedule和方法scheduleAtFixedRate都会按顺序执行，所以不要考虑非线程安全的情况。<br>方法schedule和scheduleAtFixedRate主要的区别只在于不延时的情况。<br>使用schedule方法：如果执行任务的时间没有被延迟时，那么下一次任务的执行时间参考的是上一次任务的“开始”时的时间来计算。<br>使用scheduleAtFixedRate方法：如果执行任务的时间没有被延迟时，那么下一次任务的执行时间参考的是上一次任务的“结束”时的时间来计算。<br>延时的情况则没有区别，也就是使用schedule或scheduleAtFixedRate方法都是如果执行任务的时间被延迟时，那么下一次任务的执行时间参考的是上一次任务“结束”时的时间来计算。</p><p>1 测试schedule方法任务不延时</p><p><strong>代码清单12 测试schedule方法任务不延时</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line">public class Run1 &#123;</div><div class="line"></div><div class="line">private static Timer timer = new Timer();</div><div class="line">private static int runCount = 0;</div><div class="line"></div><div class="line">static public class MyTask1 extends TimerTask &#123;</div><div class="line">@Override</div><div class="line">public void run() &#123;</div><div class="line">try &#123;</div><div class="line">System.out.println(&quot;1 begin 运行了！时间为：&quot; + new Date());</div><div class="line">Thread.sleep(1000);</div><div class="line">System.out.println(&quot;1   end 运行了！时间为：&quot; + new Date());</div><div class="line">runCount++;</div><div class="line">if (runCount == 5) &#123;</div><div class="line">timer.cancel();</div><div class="line">&#125;</div><div class="line">&#125; catch (InterruptedException e) &#123;</div><div class="line">e.printStackTrace();</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">public static void main(String[] args) &#123;</div><div class="line">try &#123;</div><div class="line">MyTask1 task1 = new MyTask1();</div><div class="line">SimpleDateFormat sdf1 = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);</div><div class="line">String dateString1 = &quot;2017-11-14 13:43:16&quot;;</div><div class="line">Date dateRef1 = sdf1.parse(dateString1);</div><div class="line">System.out.println(&quot;字符串1时间：&quot; + dateRef1.toLocaleString() + &quot; 当前时间：&quot;</div><div class="line">+ new Date().toLocaleString());</div><div class="line">timer.schedule(task1, dateRef1, 3000);</div><div class="line">&#125; catch (ParseException e) &#123;</div><div class="line">e.printStackTrace();</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>控制台打印的结果证明，在不延时的情况下，如果执行任务的时间没有被延迟时，则下一次执行任务的时间是上一次任务的开始时间加上delay时间。</p><div align="center"><br><img src="/images/Thread/ti16.jpg" alt=""><br>图16 没有延时的运行效果</div><p>2 测试schedule方法任务超时</p><p><strong>代码清单13 schedule方法任务超时</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line">public class Run2 &#123;</div><div class="line"></div><div class="line">private static Timer timer = new Timer();</div><div class="line">private static int runCount = 0;</div><div class="line"></div><div class="line">static public class MyTask1 extends TimerTask &#123;</div><div class="line">@Override</div><div class="line">public void run() &#123;</div><div class="line">try &#123;</div><div class="line">System.out.println(&quot;1 begin 运行了！时间为：&quot; + new Date());</div><div class="line">Thread.sleep(5000);</div><div class="line">System.out.println(&quot;1   end 运行了！时间为：&quot; + new Date());</div><div class="line">runCount++;</div><div class="line">if (runCount == 5) &#123;</div><div class="line">timer.cancel();</div><div class="line">&#125;</div><div class="line">&#125; catch (InterruptedException e) &#123;</div><div class="line">e.printStackTrace();</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">public static void main(String[] args) &#123;</div><div class="line">try &#123;</div><div class="line">MyTask1 task1 = new MyTask1();</div><div class="line">SimpleDateFormat sdf1 = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);</div><div class="line">String dateString1 = &quot;2017-11-14 14:42:10&quot;;</div><div class="line">Date dateRef1 = sdf1.parse(dateString1);</div><div class="line">System.out.println(&quot;字符串1时间：&quot; + dateRef1.toLocaleString() + &quot; 当前时间：&quot;</div><div class="line">+ new Date().toLocaleString());</div><div class="line">timer.schedule(task1, dateRef1, 2000);</div><div class="line">&#125; catch (ParseException e) &#123;</div><div class="line">e.printStackTrace();</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>程序运行结果如图17所示，从控制台打印的结果来看，如果执行任务的时间被延迟时，那么下一次的执行时间以上一次“结束”时的时间为参数来计算。</p><div align="center"><br><img src="/images/Thread/ti17.jpg" alt=""><br>图17 任务延时的效果</div><p>3 测试scheduleAtFixedRate方法任务不延时</p><p><strong>代码清单14 scheduleAtFixedRate方法任务不延时</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line">public class Run3 &#123;</div><div class="line"></div><div class="line">private static Timer timer = new Timer();</div><div class="line">private static int runCount = 0;</div><div class="line"></div><div class="line">static public class MyTask1 extends TimerTask &#123;</div><div class="line">@Override</div><div class="line">public void run() &#123;</div><div class="line">try &#123;</div><div class="line">System.out.println(&quot;1 begin 运行了！时间为：&quot; + new Date());</div><div class="line">Thread.sleep(2000);</div><div class="line">System.out.println(&quot;1   end 运行了！时间为：&quot; + new Date());</div><div class="line">runCount++;</div><div class="line">if (runCount == 5) &#123;</div><div class="line">timer.cancel();</div><div class="line">&#125;</div><div class="line">&#125; catch (InterruptedException e) &#123;</div><div class="line">e.printStackTrace();</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">public static void main(String[] args) &#123;</div><div class="line">try &#123;</div><div class="line">MyTask1 task1 = new MyTask1();</div><div class="line">SimpleDateFormat sdf1 = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);</div><div class="line">String dateString1 = &quot;2017-11-14 14:48:21&quot;;</div><div class="line">Date dateRef1 = sdf1.parse(dateString1);</div><div class="line">System.out.println(&quot;字符串1时间：&quot; + dateRef1.toLocaleString() + &quot; 当前时间：&quot;</div><div class="line">+ new Date().toLocaleString());</div><div class="line">timer.scheduleAtFixedRate(task1, dateRef1, 3000);</div><div class="line">&#125; catch (ParseException e) &#123;</div><div class="line">e.printStackTrace();</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>运行结果如图18所示，控制台打印的结果证明，如果执行任务的时间没有被延迟，则下一次执行任务的时间是上一次任务的开始时间加上delay时间。</p><div align="center"><br><img src="/images/Thread/ti18.jpg" alt=""><br>图18 没有被延时的运行效果</div><p>4 测试scheduleAtFixedRate方法任务超时</p><p><strong>代码清单15 scheduleAtFixedRate方法任务超时</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line">public class Run4 &#123;</div><div class="line"></div><div class="line">private static Timer timer = new Timer();</div><div class="line">private static int runCount = 0;</div><div class="line"></div><div class="line">static public class MyTask1 extends TimerTask &#123;</div><div class="line">@Override</div><div class="line">public void run() &#123;</div><div class="line">try &#123;</div><div class="line">System.out.println(&quot;1 begin 运行了！时间为：&quot; + new Date());</div><div class="line">Thread.sleep(5000);</div><div class="line">System.out.println(&quot;1   end 运行了！时间为：&quot; + new Date());</div><div class="line">runCount++;</div><div class="line">if (runCount == 5) &#123;</div><div class="line">timer.cancel();</div><div class="line">&#125;</div><div class="line">&#125; catch (InterruptedException e) &#123;</div><div class="line">e.printStackTrace();</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">public static void main(String[] args) &#123;</div><div class="line">try &#123;</div><div class="line">MyTask1 task1 = new MyTask1();</div><div class="line">SimpleDateFormat sdf1 = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);</div><div class="line">String dateString1 = &quot;2017-11-14 15:01:06&quot;;</div><div class="line">Date dateRef1 = sdf1.parse(dateString1);</div><div class="line">System.out.println(&quot;字符串1时间：&quot; + dateRef1.toLocaleString() + &quot; 当前时间：&quot;</div><div class="line">+ new Date().toLocaleString());</div><div class="line">timer.scheduleAtFixedRate(task1, dateRef1, 2000);</div><div class="line">&#125; catch (ParseException e) &#123;</div><div class="line">e.printStackTrace();</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>运行结果如图19所示，如果执行任务的时间被延迟，那么下一次任务的执行时间以上一次任务“结束”时的时间为参考来计算。</p><div align="center"><br><img src="/images/Thread/ti19.jpg" alt=""><br>图19 任务延时的运行效果</div><p>5 验证schedule方法不具有追赶执行性</p><p><strong>代码清单16 schedule方法不具有追赶执行性</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">public class Run5 &#123;</div><div class="line"></div><div class="line">private static Timer timer = new Timer();</div><div class="line"></div><div class="line">static public class MyTask1 extends TimerTask &#123;</div><div class="line">@Override</div><div class="line">public void run() &#123;</div><div class="line">System.out.println(&quot;1 begin 运行了！时间为：&quot; + new Date());</div><div class="line">System.out.println(&quot;1   end 运行了！时间为：&quot; + new Date());</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">public static void main(String[] args) &#123;</div><div class="line">try &#123;</div><div class="line">MyTask1 task1 = new MyTask1();</div><div class="line">SimpleDateFormat sdf1 = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);</div><div class="line">String dateString1 = &quot;2017-11-14 15:13:43&quot;;</div><div class="line">Date dateRef1 = sdf1.parse(dateString1);</div><div class="line">System.out.println(&quot;字符串1时间：&quot; + dateRef1.toLocaleString() + &quot; 当前时间：&quot;</div><div class="line">+ new Date().toLocaleString());</div><div class="line">timer.schedule(task1, dateRef1, 5000);</div><div class="line">&#125; catch (ParseException e) &#123;</div><div class="line">e.printStackTrace();</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>运行结果如图20所示，时间“2017-11-14 15:13:43”到“2017-11-14 15:16:06”之间的时间所对应的Task任务被取消了，不执行了。这就是Task不追赶的情况。</p><div align="center"><br><img src="/images/Thread/ti20.jpg" alt=""><br>图20 不追赶的情况</div><p>6 验证scheduleAtFixedRate方法具有追赶执行性<br><strong>代码清单17 scheduleAtFixedRate方法具有追赶执行性</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">public class Run6 &#123;</div><div class="line">private static Timer timer = new Timer();</div><div class="line"></div><div class="line">static public class MyTask1 extends TimerTask &#123;</div><div class="line">@Override</div><div class="line">public void run() &#123;</div><div class="line">System.out.println(&quot;1 begin 运行了！时间为：&quot; + new Date());</div><div class="line">System.out.println(&quot;1   end 运行了！时间为：&quot; + new Date());</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">public static void main(String[] args) &#123;</div><div class="line">try &#123;</div><div class="line">MyTask1 task1 = new MyTask1();</div><div class="line">SimpleDateFormat sdf1 = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);</div><div class="line">String dateString1 = &quot;2017-11-14 15:20:59&quot;;</div><div class="line">Date dateRef1 = sdf1.parse(dateString1);</div><div class="line">System.out.println(&quot;字符串1时间：&quot; + dateRef1.toLocaleString() + &quot; 当前时间：&quot;</div><div class="line">+ new Date().toLocaleString());</div><div class="line">timer.scheduleAtFixedRate(task1, dateRef1, 5000);</div><div class="line">&#125; catch (ParseException e) &#123;</div><div class="line">e.printStackTrace();</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>运行结果如图21所示，两个时间段内所对应的Task被“补充性”执行了，这就是Task任务追赶执行的特性。</p><div align="center"><br><img src="/images/Thread/ti21.jpg" alt=""><br>图21 追赶的情况</div><p><a href="https://github.com/5iyxx/JavaMulti-threadProgramming.git" target="_blank" rel="external">Java多线程编程核心技术源代码</a>。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;定时计划任务功能在Java中主要使用的就是Timer对象，它在内部使用多线程的方式进行处理，所以它和其它线程技术上还是有非常大的关联的。&lt;/p&gt;
    
    </summary>
    
      <category term="JavaMulti-threadProgramming" scheme="http://yoursite.com/categories/JavaMulti-threadProgramming/"/>
    
    
      <category term="Thread" scheme="http://yoursite.com/tags/Thread/"/>
    
  </entry>
  
  <entry>
    <title>线程间通信</title>
    <link href="http://yoursite.com/2017/11/11/%E7%BA%BF%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/"/>
    <id>http://yoursite.com/2017/11/11/线程间通信/</id>
    <published>2017-11-11T07:15:15.000Z</published>
    <updated>2017-11-13T05:47:13.176Z</updated>
    
    <content type="html"><![CDATA[<p>线程是操作系统中独立的个体，但这些个体如果不经过特殊的处理就不能成为一个整体。线程间的通信就是成为整体的必用方案之一，可以说，线程间进行通信后，系统之间的交互性会更强大，在大大提高CPU利用率的同时还会使程序员对各线程在处理的过程中进行有效的把控与监督。<br><a id="more"></a></p><h2 id="等待-通知机制"><a href="#等待-通知机制" class="headerlink" title="等待/通知机制"></a>等待/通知机制</h2><p>线程与线程之间不是独立的个体，它们彼此之间可以相互通信和协作。</p><h3 id="不使用等待-通知机制实现线程间通信"><a href="#不使用等待-通知机制实现线程间通信" class="headerlink" title="不使用等待/通知机制实现线程间通信"></a>不使用等待/通知机制实现线程间通信</h3><p>使用sleep()结合while(true)死循环法来实现多线程间通信。<br><strong>代码清单1 sleep()结合while(true)实现通信</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div></pre></td><td class="code"><pre><div class="line">public class MyList &#123;</div><div class="line"></div><div class="line">private List list = new ArrayList();</div><div class="line"></div><div class="line">public void add() &#123;</div><div class="line">list.add(&quot;高洪岩&quot;);</div><div class="line">&#125;</div><div class="line"></div><div class="line">public int size() &#123;</div><div class="line">return list.size();</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">public class ThreadA extends Thread &#123;</div><div class="line"></div><div class="line">private MyList list;</div><div class="line"></div><div class="line">public ThreadA(MyList list) &#123;</div><div class="line">super();</div><div class="line">this.list = list;</div><div class="line">&#125;</div><div class="line"></div><div class="line">@Override</div><div class="line">public void run() &#123;</div><div class="line">try &#123;</div><div class="line">for (int i = 0; i &lt; 10; i++) &#123;</div><div class="line">list.add();</div><div class="line">System.out.println(&quot;添加了&quot; + (i + 1) + &quot;个元素&quot;);</div><div class="line">Thread.sleep(2000);</div><div class="line">&#125;</div><div class="line">&#125; catch (InterruptedException e) &#123;</div><div class="line">e.printStackTrace();</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">public class ThreadB extends Thread &#123;</div><div class="line"></div><div class="line">private MyList list;</div><div class="line"></div><div class="line">public ThreadB(MyList list) &#123;</div><div class="line">super();</div><div class="line">this.list = list;</div><div class="line">&#125;</div><div class="line"></div><div class="line">@Override</div><div class="line">public void run() &#123;</div><div class="line">try &#123;</div><div class="line">while (true) &#123;</div><div class="line">System.out.println(list.size() );</div><div class="line">if (list.size() ==5) &#123;</div><div class="line">System.out.println(&quot;==5了，线程b要退出了！&quot;);</div><div class="line">throw new InterruptedException();</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125; catch (InterruptedException e) &#123;</div><div class="line">e.printStackTrace();</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">public class Test &#123;</div><div class="line"></div><div class="line">public static void main(String[] args) &#123;</div><div class="line">MyList service = new MyList();</div><div class="line"></div><div class="line">ThreadA a = new ThreadA(service);</div><div class="line">a.setName(&quot;A&quot;);</div><div class="line">a.start();</div><div class="line"></div><div class="line">ThreadB b = new ThreadB(service);</div><div class="line">b.setName(&quot;B&quot;);</div><div class="line">b.start();</div><div class="line"></div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>运行结果如图1所示。虽然两个线程之间实现了通信，但有一个弊端就是，线程ThreadB.java不停地通过while语句轮询机制来检测某一个条件，这样会浪费CPU资源。<br>如果轮询的时间间隔很小，更浪费CPU资源；如果轮询的时间间隔很大，有可能会取不到想要得到的数据。所以就需要有一种机制来实现减少CPU的资源浪费，而且还可以实现多个线程间通信，它就是“wait/notify”机制。</p><div align="center"><br><img src="/images/Thread/wn1.jpg" alt=""><br>图1 两个线程互相通信成功</div><h3 id="什么是等待-通知机制"><a href="#什么是等待-通知机制" class="headerlink" title="什么是等待/通知机制"></a>什么是等待/通知机制</h3><p>对于通过多个线程共同访问同一个变量，可以实现多个线程之间通信，但这种通信机制不是“等待/通知”，两个线程完全会主动式地读取一个共享变量，在花费时间的基础上，读到的值是不是想要的，并不能完全确定。所以现在迫切需要一种“等待/通知”机制来满足的需求。</p><h3 id="等待-通知机制的实现"><a href="#等待-通知机制的实现" class="headerlink" title="等待/通知机制的实现"></a>等待/通知机制的实现</h3><p>方法wait()的作用是使当前执行代码的线程进行等待，wait()方法是Object类的方法，该方法用来将当前线程置入“预执行队列”中，并且在wait()所在的代码行处停止执行，直到接到通知或被中断为止。在调用wait()之前，线程必须或得该对象的对象级别锁，即只能在同步方法或同步块中调用wait()方法。在执行wait()方法后，当前线程释放锁。在从wait()返回前，线程与其它线程竞争重新或得锁。如果调用wait()时没有持有适当的锁，则抛出IllegalMonitorStateException,它是RuntimeException的一个子类，因此，不需要try-catch语句进行辅捉异常。<br>方法notify()也要在同步方法或同步块中调用，即在调用前，线程也必须获得该对象的对象级别锁。如果调用notify()时没有持有适当的锁，也会抛出IllegalMonitorStateException。该方法用来通知那些可能等待该对象的对象锁的其他线程，如果有多个线程等待，则由线程规划器随机挑选其中一个呈wait状体的线程，对其发出通知notify，并使它等待获取该对象的对象锁。需要说明的是，在执行notify()方法后，当前线程不会马上释放该对象锁，呈wait状体的线程也并不能马上获取该对象锁，要等待到执行notify()方法的线程将程序执行完毕，也就是退出synchronized代码块后，当前线程才会释放锁，而呈wait状态所在的线程才可以获取该对象锁。当第一个锁得到该对象锁的wait线程执行完毕以后，它会释放该对象锁，此时如果该对象没有再次使用notify语句，则即便该对象已经空闲，其他wait状态等待的线程才可以获取该对象锁。当第一个获得了该对象的wait线程运行完毕后，它会释放掉该对象锁，此时如果该对象没有再次使用notify语句，则即便该对象已经空闲，其他wait状态等待的线程由于没有得到该对象的通知，还会继续阻塞在wait状态，直到这个对象发出一个notify或notifyAll。<br>用一句话总结一下wait和notify：wait使线程停止运行，而notify使停止的线程继续运行。</p><p><a href="https://github.com/5iyxx/JavaMulti-threadProgramming.git" target="_blank" rel="external">Java多线程编程核心技术源代码</a>。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;线程是操作系统中独立的个体，但这些个体如果不经过特殊的处理就不能成为一个整体。线程间的通信就是成为整体的必用方案之一，可以说，线程间进行通信后，系统之间的交互性会更强大，在大大提高CPU利用率的同时还会使程序员对各线程在处理的过程中进行有效的把控与监督。&lt;br&gt;
    
    </summary>
    
      <category term="JavaMulti-threadProgramming" scheme="http://yoursite.com/categories/JavaMulti-threadProgramming/"/>
    
    
      <category term="Thread" scheme="http://yoursite.com/tags/Thread/"/>
    
  </entry>
  
  <entry>
    <title>Hibernate中@Temporal的使用</title>
    <link href="http://yoursite.com/2017/11/11/Hibernate%E4%B8%AD@Temporal%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>http://yoursite.com/2017/11/11/Hibernate中@Temporal的使用/</id>
    <published>2017-11-11T03:53:00.000Z</published>
    <updated>2017-11-11T03:56:31.205Z</updated>
    
    <content type="html"><![CDATA[<p>  @Temporal标签的作用。<br><a id="more"></a></p><ol><li><p>如果在某类中有Date类型的属性，数据库中存储可能是’yyyy-MM-dd hh:MM:ss’要在查询时获得年月日，在该属性上标注@Temporal(TemporalType.DATE) 会得到形如’yyyy-MM-dd’ 格式的日期。</p></li><li><p>如果在某类中有Date类型的属性，数据库中存储可能是’yyyy-MM-dd hh:MM:ss’要获得时分秒，在该属性上标注 @Temporal(TemporalType.TIME) 会得到形如’HH:MM:SS’ 格式的日期。</p></li><li><p>如果在某类中有Date类型的属性，数据库中存储可能是’yyyy-MM-dd hh:MM:ss’要获得’是’yyyy-MM-dd hh:MM:ss’，在该属性上标注 @Temporal(TemporalType.TIMESTAMP) 会得到形如’HH:MM:SS’ 格式的日期</p></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;  @Temporal标签的作用。&lt;br&gt;
    
    </summary>
    
      <category term="JavaMulti-threadProgramming" scheme="http://yoursite.com/categories/JavaMulti-threadProgramming/"/>
    
    
      <category term="The Basic Of Hibernate" scheme="http://yoursite.com/tags/The-Basic-Of-Hibernate/"/>
    
  </entry>
  
  <entry>
    <title>volatile关键字</title>
    <link href="http://yoursite.com/2017/11/11/Volatile%E5%85%B3%E9%94%AE%E5%AD%97/"/>
    <id>http://yoursite.com/2017/11/11/Volatile关键字/</id>
    <published>2017-11-10T19:41:55.000Z</published>
    <updated>2017-11-14T09:32:34.601Z</updated>
    
    <content type="html"><![CDATA[<p>关键字volatile的主要作用是使变量在多个线程间可见。<br><a id="more"></a></p><h3 id="volatile关键字与死循环"><a href="#volatile关键字与死循环" class="headerlink" title="volatile关键字与死循环"></a>volatile关键字与死循环</h3><p>如果不是在多继承的情况下，使用继承Thread类和实现Runnable接口在取得程序运行的结果上并没有什么太大的区别。如果一旦出现“多继承”的情况，则用实现Runnable接口的方式来处理多线程的问题就是很有必要的。</p><p><strong>代码清单1 死循环</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">public class PrintString &#123;</div><div class="line">private boolean isContinuePrint = true;</div><div class="line"></div><div class="line">public boolean isContinuePrint() &#123;</div><div class="line">return isContinuePrint;</div><div class="line">&#125;</div><div class="line"></div><div class="line">public void setContinuePrint(boolean isContinuePrint) &#123;</div><div class="line">this.isContinuePrint = isContinuePrint;</div><div class="line">&#125;</div><div class="line"></div><div class="line">public void printStringMethod() &#123;</div><div class="line">try &#123;</div><div class="line">while (isContinuePrint == true)</div><div class="line">System.out.println(&quot;run printStringMethod threadName=&quot; + Thread.currentThread().getName());</div><div class="line">Thread.sleep(1000);</div><div class="line">&#125; catch (InterruptedException e) &#123;</div><div class="line">// TODO Auto-generated catch block</div><div class="line">e.printStackTrace();</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">public class Run &#123;</div><div class="line"></div><div class="line">public static void main(String[] args) &#123;</div><div class="line">PrintString printStringService=new PrintString();</div><div class="line">printStringService.printStringMethod();</div><div class="line">System.out.println(&quot;我要停止它！ stopThread=&quot;+Thread.currentThread().getName());</div><div class="line">  printStringService.setContinuePrint(false);</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>程序开始运行后，根本停不下来，结果如图1所示。<br>停不下来的原因主要就是main线程一直在处理while()循环，导致程序不能运行后面的代码。</p><div align="center"><br><img src="/images/Thread/vo1.jpg" alt=""><br>图1 停不下来的程序</div><h3 id="解决同步死循环"><a href="#解决同步死循环" class="headerlink" title="解决同步死循环"></a>解决同步死循环</h3><p>采用多线程，解决死循环。<br><strong>代码清单2 解决死循环</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line">public class PrintString implements Runnable&#123;</div><div class="line">private boolean isContinuePrint = true;</div><div class="line"></div><div class="line">public boolean isContinuePrint() &#123;</div><div class="line">return isContinuePrint;</div><div class="line">&#125;</div><div class="line"></div><div class="line">public void setContinuePrint(boolean isContinuePrint) &#123;</div><div class="line">this.isContinuePrint = isContinuePrint;</div><div class="line">&#125;</div><div class="line"></div><div class="line">public void printStringMethod() &#123;</div><div class="line">try &#123;</div><div class="line">while (isContinuePrint == true)</div><div class="line">System.out.println(&quot;run printStringMethod threadName=&quot; + Thread.currentThread().getName());</div><div class="line">Thread.sleep(1000);</div><div class="line">&#125; catch (InterruptedException e) &#123;</div><div class="line">// TODO Auto-generated catch block</div><div class="line">e.printStackTrace();</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">public void run() &#123;</div><div class="line">printStringMethod();</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">public class Run &#123;</div><div class="line"></div><div class="line">public static void main(String[] args) &#123;</div><div class="line">PrintString printStringService=new PrintString();</div><div class="line">new Thread(printStringService).start();</div><div class="line">System.out.println(&quot;我要停止它！ stopThread=&quot;+Thread.currentThread().getName());</div><div class="line">  printStringService.setContinuePrint(false);</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">`</div></pre></td></tr></table></figure></p><p>运行结果如图2，但当上面的代码运行在-server服务器模式中64bit的JVM时，会出现死循环。解决的办法是使用volatile关键字。<br>关键字volatile的作用是强制从公共堆栈中取得变量的值，而不是从线程私有数据栈中取得变量的值。</p><div align="center"><br><img src="/images/Thread/vo1.jpg" alt=""><br>图2 程序被停止了</div><h3 id="解决异步死循环"><a href="#解决异步死循环" class="headerlink" title="解决异步死循环"></a>解决异步死循环</h3><p>在探讨volatile之前先做一个测试。<br><strong>代码清单3 JVM设置为 -Server</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line">public class RunThread extends Thread&#123;</div><div class="line">    //volatile private boolean isRunning = true;</div><div class="line">private boolean isRunning = true;</div><div class="line"></div><div class="line">public boolean isRunning() &#123;</div><div class="line">return isRunning;</div><div class="line">&#125;</div><div class="line"></div><div class="line">public void setRunning(boolean isRunning) &#123;</div><div class="line">this.isRunning = isRunning;</div><div class="line">&#125;</div><div class="line"></div><div class="line">@Override</div><div class="line">public void run() &#123;</div><div class="line">   System.out.println(&quot;进入run了&quot;);</div><div class="line">while (isRunning==true)&#123;</div><div class="line">   </div><div class="line">   &#125;</div><div class="line">   System.out.println(&quot;线程被停止了！&quot;);</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">public class Run &#123;</div><div class="line"></div><div class="line">public static void main(String[] args) &#123;</div><div class="line">try &#123;</div><div class="line">RunThread thread = new RunThread();</div><div class="line">thread.start();</div><div class="line">Thread.sleep(1000);</div><div class="line">thread.setRunning(false);</div><div class="line">System.out.println(&quot;已经赋值为false&quot;);</div><div class="line">&#125; catch (InterruptedException e) &#123;</div><div class="line">e.printStackTrace();</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>在win10结合JDK64bit的环境中，使用Eclipse开发环境运行后的结果如图3所示。</p><div align="center"><br><img src="/images/Thread/vo3.jpg" alt=""><br>图3 打印结果</div><p>但是如果使用同样的代码，让他们运行在JVM设置为Server服务器的环境中，设置如图4所示。</p><div align="center"><br><img src="/images/Thread/vo4.jpg" alt=""><br>图4 配置JVM为-server模式</div><p>运行结果如图5所示，代码<code>System.out.println(&quot;线程被停止了！&quot;);</code> 从未被执行。</p><div align="center"><br><img src="/images/Thread/vo5.jpg" alt=""><br>图5 出现了死循环</div><p>是什么样的原因造成将JVM设置为-server使出现死循环呢？在启动RunThread.java线程时，变量<code>private boolean isRunning = true;</code>存在于公共堆栈及线程的私有堆栈中。在JVM被设置为-server模式时为了线程运行的效率，线程一直在私有堆栈中取得isRunning的值为true。而代码<code>thread.setRunning(false);</code>虽然被执行，更新的却是公共堆栈中的isRunning变量值false，所以一直就是死循环的状态。内存结果如图6所示。</p><div align="center"><br><img src="/images/Thread/vo6.jpg" alt=""><br>图6 线程的私有堆栈</div><p>这个问题其实就是私有堆栈中的值和公共堆栈中的值不同步造成的。解决这样的问题就要使用volatile关键字，它主要的作用就是当线程访问isRunning这个变量时，强制性从公共堆栈中进行取值。<br>在代码清单3中，定义变量isRunning前加上volatile，运行结果如图7.</p><div align="center"><br><img src="/images/Thread/vo7.jpg" alt=""><br>图7 在-server服务器模式不再出现死循环</div><p>通过使用volatile关键字，强制的从公共内存中读取变量的值，内存结构如图8所示。</p><div align="center"><br><img src="/images/Thread/vo8.jpg" alt=""><br>图8 读取公共内存</div><p>使用volatile关键字增加了实例变量在多个线程之间的可见性。但volatile关键字最致命的缺点是不支持原子性。<br>下面将关键字synchronized和volatile进行一下比较：</p><ol><li>关键字volatile是线程同步的轻量级实现，所以volatile性能肯定比synchronized要好，并且volatile只能修饰变量，而synchronized可以修饰方法，以及代码块。随着JDK新版本的发布，synchronized关键字在执行效率上得到了很大提升，在开发中使用synchronized关键字的比率还是比较大。</li><li>多线程访问volatile不会发生阻塞，而synchronized会出现阻塞。</li><li>volatile能保证数据的可见性，但不能保证原子性；而synchronized可以保证原子性，也可以间接保证可见性，因为它会将私有内存和公共内存中的数据做同步。</li><li>再次重申一下，关键字volatile解决的是变量在多个线程之间的可见性；而synchronized关键字解决的是多个线程之间访问资源的同步性。</li></ol><p><strong>线程安全包含原子性和可见性两个方面，Java的同步机制都是围绕这两个方向来确保线程安全的。</strong></p><h3 id="volatile非原子的特性"><a href="#volatile非原子的特性" class="headerlink" title="volatile非原子的特性"></a>volatile非原子的特性</h3><p>关键字volatile虽然增加了实例变量在多个线程之间的可见性，但它却不具备同步性，那么也就不具备原子性。</p><p><a href="https://github.com/5iyxx/JavaMulti-threadProgramming.git" target="_blank" rel="external">Java多线程编程核心技术源代码</a>。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;关键字volatile的主要作用是使变量在多个线程间可见。&lt;br&gt;
    
    </summary>
    
      <category term="JavaMulti-threadProgramming" scheme="http://yoursite.com/categories/JavaMulti-threadProgramming/"/>
    
    
      <category term="Thread" scheme="http://yoursite.com/tags/Thread/"/>
    
  </entry>
  
  <entry>
    <title>POJO与JavaBean的区别</title>
    <link href="http://yoursite.com/2017/10/01/POJO%E4%B8%8EJavaBean%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>http://yoursite.com/2017/10/01/POJO与JavaBean的区别/</id>
    <published>2017-10-01T01:43:50.000Z</published>
    <updated>2017-10-20T02:23:46.253Z</updated>
    
    <content type="html"><![CDATA[<p>POJO往往被称为Data对象，而JavaBean更是一个组件技术。</p><a id="more"></a><p>POJO（Plain Ordinary Java Object）简单的Java对象，实际就是普通JavaBeans，是为了避免和EJB混淆所创造的简称。</p><p>使用POJO名称是为了避免和EJB混淆起来, 而且简称比较直接. 其中有一些属性及其getter、setter方法的类,没有业务逻辑，有时可以作为VO(value -object)或dto(Data Transform Object)来使用.当然,如果你有一个简单的运算属性也是可以的,但不允许有业务方法,也不能携带有connection之类的方法。</p><p>POJO对象有时也被称为Data对象，大量应用于表现现实中的对象。如果项目中使用了Hibernate框架，有一个关联的xml文件，使对象与数据库中的表对应，对象的属性与表中的字段相对应。</p><p>POJO 和JavaBean是我们常见的两个关键字，一般容易混淆，POJO全称是Plain Ordinary Java Object / Pure Old Java Object，中文可以翻译成：普通Java类，具有一部分getter/setter方法的那种类就可以称作POJO，但是JavaBean则比 POJO复杂很多， Java Bean 是可复用的组件，对 Java Bean 并没有严格的规范，理论上讲，任何一个 Java 类都可以是一个 Bean 。但通常情况下，由于 Java Bean 是被容器所创建（如 Tomcat) 的，所以 Java Bean 应具有一个无参的构造器，另外，通常 Java Bean 还要实现 Serializable 接口用于实现 Bean 的持久性。 Java Bean 是不能被跨进程访问的。</p><p>JavaBean是一种组件技术，就好像你做了一个扳子，而这个扳子会在很多地方被拿去用，这个扳子也提供多种功能(你可以拿这个扳子扳、锤、撬等等)，而这个扳子就是一个组件。一般在web应用程序中建立一个数据库的映射对象时，我们只能称它为POJO。POJO(Plain Old Java Object)这个名字用来强调它是一个普通java对象，而不是一个特殊的对象，其主要用来指代那些没有遵从特定的Java对象模型、约定或框架（如EJB）的Java对象。理想地讲，一个POJO是一个不受任何限制的Java对象（除了Java语言规范）。</p><p>POJO是一个简单的普通的Java对象，它不包含业务逻辑或持久逻辑等，但不是JavaBean、EntityBean等，不具有任何特殊角色和不继承或不实现任何其它Java框架的类或接口。</p><p>转载于：<a href="http://www.cnblogs.com/Nickzerui/p/4596956.html" target="_blank" rel="external">http://www.cnblogs.com/Nickzerui/p/4596956.html</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;POJO往往被称为Data对象，而JavaBean更是一个组件技术。&lt;/p&gt;
    
    </summary>
    
      <category term="The Basic Of Java" scheme="http://yoursite.com/categories/The-Basic-Of-Java/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Red Hat 7 安装后环境配置</title>
    <link href="http://yoursite.com/2017/06/22/Red%20Hat%207%20%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"/>
    <id>http://yoursite.com/2017/06/22/Red Hat 7 环境配置/</id>
    <published>2017-06-22T12:04:50.000Z</published>
    <updated>2017-09-29T01:49:19.192Z</updated>
    
    <content type="html"><![CDATA[<p>Red Hat 7 安装后环境配置<br><a id="more"></a></p><h3 id="配置静态的ip地址"><a href="#配置静态的ip地址" class="headerlink" title="配置静态的ip地址"></a>配置静态的ip地址</h3><ul><li>查看系统的使用的网卡<br><code>ifconfig</code> 我本地网卡为eno16777736</li><li>打开配置文件<br><code>vi /etc/sysconfig/network-scripts/ifcfg-eno16777736</code></li><li>静态ip设置，需要根据自己的网络参数修改配置文件<br><code>BOOTPROTO=static</code> 指定地址的获取方式<br><code>IPADDR=192.168.0.225</code> ip地址<br><code>NETMASK=255.255.255.0</code> 子网掩码<br><code>GATEWAY=192.168.0.1</code> 网关</li><li>重启服务<br><code>systemctl  restart network</code></li><li>ping测试<br><code>ping 8.8.8.8</code><br><code>PING 8.8.8.8 (8.8.8.8) 56(84) bytes of data.</code><br><code>64 bytes from 8.8.8.8: icmp_seq=1 ttl=45 time=241 ms</code><br>测试如上结果，成功！</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Red Hat 7 安装后环境配置&lt;br&gt;
    
    </summary>
    
      <category term="Operations" scheme="http://yoursite.com/categories/Operations/"/>
    
    
      <category term="Linux" scheme="http://yoursite.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>在Maven中Tomcat热部署</title>
    <link href="http://yoursite.com/2017/05/11/%E5%9C%A8maven%E4%B8%ADTomcat%E7%83%AD%E9%83%A8%E7%BD%B2/"/>
    <id>http://yoursite.com/2017/05/11/在maven中Tomcat热部署/</id>
    <published>2017-05-11T01:43:50.000Z</published>
    <updated>2017-10-14T02:46:07.787Z</updated>
    
    <content type="html"><![CDATA[<p> 在Maven中Tomcat热部署，下面为一个简单做法流程，一共有三步。<br><a id="more"></a><br>第一步：修改tomcat-users.xml配置文件，配置用户、密码和权限。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;role rolename=&quot;manager-gui&quot; /&gt;</div><div class="line">&lt;role rolename=&quot;manager-script&quot; /&gt;</div><div class="line">&lt;user username=&quot;tomcat&quot; password=&quot;tomcat&quot; roles=&quot;manager-gui, manager-script&quot;/&gt;</div></pre></td></tr></table></figure></p><p>启动tomcat后，可以进入后台,如图1.</p><div align="center"><br><img src="/images/Operations/t1.jpg" alt=""><br>图1 后台页面</div><p>第二步：修改ip访问权限<br>对于IP访问权限在设置在/tomcat/webapps/manager/META-INF/context.xml中。<br>早期版本Tomcat默认是没有限制的，如图2所示。</p><div align="center"><br><img src="/images/Operations/t4.jpg" alt=""><br>图2 早期IP限制默认配置</div><p>现在Tomcat对于默认是对IP进行限制的，如果不需要进行限制可以模仿早期Tomcat默认配置，去掉IP限制，<br>默认如图3所示。</p><div align="center"><br><img src="/images/Operations/t5.jpg" alt=""><br>图3 现在IP限制默认配置</div><p>第三步：在pom文件中配置tomcat插件。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">&lt;!-- 配置Tomcat插件 --&gt;</div><div class="line">&lt;plugin&gt;</div><div class="line">&lt;groupId&gt;org.apache.tomcat.maven&lt;/groupId&gt;</div><div class="line">&lt;artifactId&gt;tomcat7-maven-plugin&lt;/artifactId&gt;</div><div class="line">&lt;version&gt;2.2&lt;/version&gt;</div><div class="line">&lt;configuration&gt;</div><div class="line">&lt;port&gt;8080&lt;/port&gt;</div><div class="line">&lt;path&gt;/&lt;/path&gt;</div><div class="line">&lt;url&gt;http://119.29.160.64/manager/text&lt;/url&gt;</div><div class="line">&lt;username&gt;tomcat&lt;/username&gt;</div><div class="line">&lt;password&gt;tomcat20170928&lt;/password&gt;</div><div class="line">&lt;/configuration&gt;</div><div class="line">&lt;/plugin&gt;</div></pre></td></tr></table></figure></p><p>第四步：部署<br>初次部署可以使用 “tomcat7:deploy” 命令<br>如果已经部署过使用 “tomcat7:redeploy” 命令<br>（如果第一次部署到根目录，可以直接用“tomcat7:redeploy”）<br>启动过程如图4、图5.</p><div align="center"><br><img src="/images/Operations/t2.jpg" alt=""><br>图4 Maven build…<br><img src="/images/Operations/t3.jpg" alt=""><br>图5 运行插件</div>]]></content>
    
    <summary type="html">
    
      &lt;p&gt; 在Maven中Tomcat热部署，下面为一个简单做法流程，一共有三步。&lt;br&gt;
    
    </summary>
    
      <category term="Operations" scheme="http://yoursite.com/categories/Operations/"/>
    
    
      <category term="Tomcat" scheme="http://yoursite.com/tags/Tomcat/"/>
    
      <category term="Maven" scheme="http://yoursite.com/tags/Maven/"/>
    
  </entry>
  
  <entry>
    <title>为什么要使用SocketAddress来管理网络地址</title>
    <link href="http://yoursite.com/2017/05/10/%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E4%BD%BF%E7%94%A8SocketAddress%E6%9D%A5%E7%AE%A1%E7%90%86%E7%BD%91%E7%BB%9C%E5%9C%B0%E5%9D%80/"/>
    <id>http://yoursite.com/2017/05/10/为什么要使用SocketAddress来管理网络地址/</id>
    <published>2017-05-10T01:43:50.000Z</published>
    <updated>2017-10-23T03:17:25.622Z</updated>
    
    <content type="html"><![CDATA[<p>在使用Socket来连接服务器时最简单的方式就是直接使用IP和端口，但Socket类中的connect方法并未提供这种方式，而是使用SocketAddress类来向connect方法传递服务器的IP和端口。虽然这种方式从表面上看要麻烦一些，但它会给我们带来另外一个好处，那就是网络地址的重用。<br><a id="more"></a></p><p><strong>所谓网络地址的重用表现在两个方面：</strong></p><ul><li>通过建立一个SocketAddress对象，可以在多次连接同一个服务器时使用这个SocketAddress对象。</li><li>在Socket类中提供了两个方法：getRemoteSocketAddress和getLocalSocketAddress，通过这两个方法可以得到服务器和本机的网络地址。而且所得到的网络地址在相应的Socket对象关闭后任然可以使用。下面是这两个方法的声明：</li><li><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">public SocketAddress getRemoteSocketAddress()</div><div class="line">public SocketAddress getLocalSocketAddress()</div></pre></td></tr></table></figure><p> 不管在使用Socket类连接服务器时是直接使用IP和端口，还是使用SocketAddress，这两个方法都返回SocketAddress形式的网络地址。当Socket对象未连接时这两个方法返回null，但要注意的是只有在Socket对象未连接时这两个方法才返回null，而当已经连接成功的Socket对象关闭后仍可使用这两个方法得到相应的网络地址。<br> 虽然上面曾多次提到SocketAddress，但SocketAddress只是个抽象类，它除了有一个默认的构造方法外，其它的方法都是abstract的，因此，我们必须使用SocketAddress的子类来建立SocketAddress对象。在JDK1.4中J只为我们提供了IP网络地址的实现类：java.net.InetSocketAddress。这个类是从SocketAddress继承的，我们可以通过如下的方法来建立SocketAddress对象。</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">SocketAddress socketAddress = new InetSocketAddress(host, ip);</div></pre></td></tr></table></figure><p>下面的代码演示了如何通过SocketAddress来共享网络地址：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line">package mynet;</div><div class="line"></div><div class="line">import java.net.*;</div><div class="line"></div><div class="line">public class MySocketAddress</div><div class="line">&#123;</div><div class="line">    public static void main(String[] args)</div><div class="line">    &#123;</div><div class="line">        try</div><div class="line">        &#123;</div><div class="line">            Socket socket1 = new Socket(&quot;www.ptpress.com.cn&quot;, 80);</div><div class="line">            SocketAddress socketAddress = socket1.getRemoteSocketAddress();</div><div class="line">            socket1.close();</div><div class="line">            Socket socket2 = new Socket();</div><div class="line">            // socket2.bind(new InetSocketAddress(&quot;192.168.18.252&quot;, 0));</div><div class="line">            socket2.connect(socketAddress);</div><div class="line">            socket2.close();</div><div class="line">            InetSocketAddress inetSocketAddress1 = (InetSocketAddress) socketAddress;</div><div class="line">            System.out.println(&quot;服务器域名:&quot;</div><div class="line">                            + inetSocketAddress1.getAddress().getHostName());</div><div class="line">            System.out.println(&quot;服务器IP:&quot;</div><div class="line">                            + inetSocketAddress1.getAddress().getHostAddress());</div><div class="line">            System.out.println(&quot;服务器端口:&quot; + inetSocketAddress1.getPort());</div><div class="line">            InetSocketAddress inetSocketAddress2 = (InetSocketAddress) socket2</div><div class="line">                            .getLocalSocketAddress();</div><div class="line">            System.out.println(&quot;本地IP:&quot;</div><div class="line">                            + inetSocketAddress2.getAddress().getLocalHost()</div><div class="line">                                            .getHostAddress());</div><div class="line">            System.out.println(&quot;本地端口:&quot; + inetSocketAddress2.getPort());</div><div class="line">        &#125;</div><div class="line">        catch (Exception e)</div><div class="line">        &#123;</div><div class="line">            System.out.println(e.getMessage());</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>输出结果：</p><p>服务器域名:www.ptpress.com.cn<br>服务器IP:219.238.168.74<br>服务器端口:80<br>本地IP:192.168.18.253<br>本地端口:4250</p><p>如果多次运行后，本地端口的值可能在每次都不一样。这是因为在socket2在连接时并未使用bind来绑定本地的端口，而这个本地端口是由系统在1024至65，535中随机选取的，因此，在每次运行程序时这个本地端口不一定相同。</p><p>本文出自 “<a href="http://androidguy.blog.51cto.com/974126/214448" target="_blank" rel="external">李宁的极客世界</a>”博客， <a href="http://androidguy.blog.51cto.com/974126/214448" target="_blank" rel="external">http://androidguy.blog.51cto.com/974126/214448</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在使用Socket来连接服务器时最简单的方式就是直接使用IP和端口，但Socket类中的connect方法并未提供这种方式，而是使用SocketAddress类来向connect方法传递服务器的IP和端口。虽然这种方式从表面上看要麻烦一些，但它会给我们带来另外一个好处，那就是网络地址的重用。&lt;br&gt;
    
    </summary>
    
      <category term="Netty:The Definitive Guide 2th" scheme="http://yoursite.com/categories/Netty-The-Definitive-Guide-2th/"/>
    
    
      <category term="NIO" scheme="http://yoursite.com/tags/NIO/"/>
    
      <category term="Socket" scheme="http://yoursite.com/tags/Socket/"/>
    
  </entry>
  
  <entry>
    <title>JavaBean总结</title>
    <link href="http://yoursite.com/2017/04/01/JavaBean%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2017/04/01/JavaBean总结/</id>
    <published>2017-04-01T01:43:50.000Z</published>
    <updated>2017-10-20T02:05:16.813Z</updated>
    
    <content type="html"><![CDATA[<p>符合一定规范编写的Java类，不是一种技术，而是一种规范。大家针对这种规范，总结了很多开发技巧、工具函数。符合这种规范的类，可以被其它的程序员或者框架使用。</p><a id="more"></a><h4 id="javabean-是什么？"><a href="#javabean-是什么？" class="headerlink" title="javabean 是什么？"></a>javabean 是什么？</h4><p>Bean的中文含义是“豆子”，顾名思义，JavaBean是指一段特殊的Java类，<br>就是有默然构造方法,只有get,set的方法的java类的对象.</p><p>专业点解释是：</p><p>JavaBean定义了一组规则<br>JavaBean就是遵循此规则的平常的Java对象 </p><p>满足这三个条件:<br>1.实现序列化接口<br>2.提供无参数的构造器<br>3.提供getter 和 setter方法访问它的属性.</p><p>简单地说，JavaBean是用Java语言描述的软件组件模型，其实际上是一个类。这些类遵循一个接口格式，以便于使函数命名、底层行为以及继承或实现的行为，可以把类看作标准的JavaBean组件进行构造和应用。<br>JavaBean一般分为可视化组件和非可视化组件两种。可视化组件可以是简单的GUI元素，如按钮或文本框，也可以是复杂的，如报表组件；非可视化组件没有GUI表现形式，用于封装业务逻辑、数据库操作等。其最大的优点在于可以实现代码的可重用性。JavaBean又同时具有以下特性。</p><ul><li>易于维护、使用、编写。</li><li>可实现代码的重用性。</li><li>可移植性强，但仅限于Java工作平台。</li><li>便于传输，不限于本地还是网络。</li><li>可以以其他部件的模式进行工作。</li></ul><p>对于有过其他语言编程经验的读者，可以将其看作类似微软的ActiveX的编程组件。但是区别在于JavaBean是跨平台的，而ActiveX组件则仅局限于Windows系统。总之，JavaBean比较适合于那些需要跨平台的、并具有可视化操作和定制特性的软件组件。</p><p>JavaBean组件与EJB（Enterprise JavaBean，企业级JavaBean）组件完全不同。EJB 是J2EE的核心，是一个用来创建分布式应用、服务器端以及基于Java应用的功能强大的组件模型。JavaBean组件主要用于存储状态信息，而EJB组件可以存储业务逻辑。</p><h4 id="使用JavaBean的原因"><a href="#使用JavaBean的原因" class="headerlink" title="使用JavaBean的原因"></a>使用JavaBean的原因</h4><p>程序中往往有重复使用的段落，JavaBean就是为了能够重复使用而设计的程序段落，而且这些段落并不只服务于某一个程序，而且每个JavaBean都具有特定功能，当需要这个功能的时候就可以调用相应的JavaBean。从这个意义上来讲，JavaBean大大简化了程序的设计过程，也方便了其他程序的重复使用。<br>JavaBean传统应用于可视化领域，如AWT（窗口工具集）下的应用。而现在，JavaBean更多地应用于非可视化领域，同时，JavaBean在服务器端的应用也表现出强大的优势。非可视化的JavaBean可以很好地实现业务逻辑、控制逻辑和显示页面的分离，现在多用于后台处理，使得系统具有更好的健壮性和灵活性。JSP + JavaBean和JSP + JavaBean + Servlet成为当前开发Web应用的主流模式。</p><h4 id="JavaBean的开发"><a href="#JavaBean的开发" class="headerlink" title="JavaBean的开发"></a>JavaBean的开发</h4><p>在程序设计的过程中，JavaBean不是独立的。为了能够更好地封装事务逻辑、数据库操作而便于实现业务逻辑和前台程序的分离，操作的过程往往是先开发需要的JavaBean，再在适当的时候进行调用。但一个完整有效的JavaBean必然会包含一个属性，伴随若干个get/set（只读/只写）函数的变量来设计和运行的。JavaBean作为一个特殊的类，具有自己独有的特性。应该注意以下3个方面。</p><ul><li>JavaBean类必须有一个没有参数的构造函数。</li><li>JavaBean类所有的属性最好定义为私有的。</li><li>JavaBean类中定义函数setXxx() 和getXxx()来对属性进行操作。其中Xxx是首字母大写的私有变量名称。</li></ul><p>转载于：<a href="http://blog.csdn.net/zdwzzu2006/article/details/5151788/" target="_blank" rel="external">http://blog.csdn.net/zdwzzu2006/article/details/5151788/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;符合一定规范编写的Java类，不是一种技术，而是一种规范。大家针对这种规范，总结了很多开发技巧、工具函数。符合这种规范的类，可以被其它的程序员或者框架使用。&lt;/p&gt;
    
    </summary>
    
      <category term="The Basic Of Java" scheme="http://yoursite.com/categories/The-Basic-Of-Java/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Spring中每个jar包的作用</title>
    <link href="http://yoursite.com/2017/03/10/Spring%E4%B8%AD%E6%AF%8F%E4%B8%AAjar%E5%8C%85%E7%9A%84%E4%BD%9C%E7%94%A8/"/>
    <id>http://yoursite.com/2017/03/10/Spring中每个jar包的作用/</id>
    <published>2017-03-10T01:43:50.000Z</published>
    <updated>2017-10-20T02:35:54.588Z</updated>
    
    <content type="html"><![CDATA[<p>一个工程需要很多个关于spring的jar包，下面详细说明每个jar的作用。</p><a id="more"></a><p><strong>spring.jar</strong><br>包含有完整发布模块的单个jar 包。但是不包括mock.jar, aspects.jar, spring-portlet.jar, and spring-hibernate2.jar。</p><p><strong>spring-src.zip就是所有的源代码压缩包。</strong></p><p>除了spring.jar 文件，Spring 还包括有其它21 个独立的jar 包，各自包含着对应的Spring组件，用户可以根据自己的需要来选择组合自己的jar 包，而不必引入整个spring.jar 的所有类文件。</p><h4 id="spring-core-jar"><a href="#spring-core-jar" class="headerlink" title="spring-core.jar"></a>spring-core.jar</h4><p>这个jar 文件包含Spring 框架基本的核心工具类。Spring 其它组件要都要使用到这个包里的类，是其它组件的基本核心，当然你也可以在自己的应用系统中使用这些工具类。<br>外部依赖Commons Logging， (Log4J)。</p><h4 id="spring-beans-jar"><a href="#spring-beans-jar" class="headerlink" title="spring-beans.jar"></a>spring-beans.jar</h4><p>这个jar 文件是所有应用都要用到的，它包含访问配置文件、创建和管理bean 以及进行Inversion of Control / Dependency Injection（IoC/DI）操作相关的所有类。如果应用只需基本的IoC/DI 支持，引入spring-core.jar 及spring-beans.jar 文件就可以了。<br>外部依赖spring-core，(CGLIB)。</p><h4 id="spring-aop-jar"><a href="#spring-aop-jar" class="headerlink" title="spring-aop.jar"></a>spring-aop.jar</h4><p>这个jar 文件包含在应用中使用Spring 的AOP 特性时所需的类和源码级元数据支持。使用基于AOP 的Spring特性，如声明型事务管理（Declarative Transaction Management），也要在应用里包含这个jar包。<br>外部依赖spring-core， (spring-beans，AOP Alliance， CGLIB，Commons Attributes)。</p><h4 id="spring-context-jar"><a href="#spring-context-jar" class="headerlink" title="spring-context.jar"></a>spring-context.jar</h4><p>这个jar 文件为Spring 核心提供了大量扩展。可以找到使用Spring ApplicationContext特性时所需的全部类，JDNI 所需的全部类，instrumentation组件以及校验Validation 方面的相关类。<br>外部依赖spring-beans, (spring-aop)。</p><h4 id="spring-dao-jar"><a href="#spring-dao-jar" class="headerlink" title="spring-dao.jar"></a>spring-dao.jar</h4><p>这个jar 文件包含Spring DAO、Spring Transaction 进行数据访问的所有类。为了使用声明型事务支持，还需在自己的应用里包含spring-aop.jar。<br>外部依赖spring-core，(spring-aop， spring-context， JTA API)。</p><h4 id="spring-jdbc-jar"><a href="#spring-jdbc-jar" class="headerlink" title="spring-jdbc.jar"></a>spring-jdbc.jar</h4><p>这个jar 文件包含对Spring 对JDBC 数据访问进行封装的所有类。<br>外部依赖spring-beans，spring-dao。</p><h4 id="spring-support-jar"><a href="#spring-support-jar" class="headerlink" title="spring-support.jar"></a>spring-support.jar</h4><p>这个jar 文件包含支持UI模版（Velocity，FreeMarker，JasperReports），邮件服务，脚本服务(JRuby)，缓存Cache（EHCache），任务计划Scheduling（uartz）方面的类。<br>外部依赖spring-context, (spring-jdbc, Velocity, FreeMarker, JasperReports, BSH, Groovy, JRuby, Quartz, EHCache)</p><h4 id="spring-web-jar"><a href="#spring-web-jar" class="headerlink" title="spring-web.jar"></a>spring-web.jar</h4><p>这个jar 文件包含Web 应用开发时，用到Spring 框架时所需的核心类，包括自动载入Web Application Context 特性的类、Struts 与JSF 集成类、文件上传的支持类、Filter 类和大量工具辅助类。<br>外部依赖spring-context, Servlet API, (JSP API, JSTL, Commons FileUpload, COS)。</p><h4 id="spring-webmvc-jar"><a href="#spring-webmvc-jar" class="headerlink" title="spring-webmvc.jar"></a>spring-webmvc.jar</h4><p>这个jar 文件包含Spring MVC 框架相关的所有类。包括框架的Servlets，Web MVC框架，控制器和视图支持。当然，如果你的应用使用了独立的MVC 框架，则无需这个JAR 文件里的任何类。<br>外部依赖spring-web, (spring-support，Tiles，iText，POI)。</p><h4 id="spring-portlet-jar"><a href="#spring-portlet-jar" class="headerlink" title="spring-portlet.jar"></a>spring-portlet.jar</h4><p>spring自己实现的一个类似Spring MVC的框架。包括一个MVC框架和控制器。<br>外部依赖spring-web， Portlet API，(spring-webmvc)。</p><h4 id="spring-struts-jar"><a href="#spring-struts-jar" class="headerlink" title="spring-struts.jar"></a>spring-struts.jar</h4><p>Struts框架支持，可以更方便更容易的集成Struts框架。<br>外部依赖spring-web，Struts。</p><h4 id="spring-remoting-jar"><a href="#spring-remoting-jar" class="headerlink" title="spring-remoting.jar"></a>spring-remoting.jar</h4><p>这个jar 文件包含支持EJB、远程调用Remoting（RMI、Hessian、Burlap、Http Invoker、JAX-RPC）方面的类。<br>外部依赖spring-aop， (spring-context，spring-web，Hessian，Burlap，JAX-RPC，EJB API)。</p><h4 id="spring-jmx-jar"><a href="#spring-jmx-jar" class="headerlink" title="spring-jmx.jar"></a>spring-jmx.jar</h4><p>这个jar包提供了对JMX 1.0/1.2的支持类。<br>外部依赖spring-beans，spring-aop， JMX API。</p><h4 id="spring-jms-jar"><a href="#spring-jms-jar" class="headerlink" title="spring-jms.jar"></a>spring-jms.jar</h4><p>这个jar包提供了对JMS 1.0.2/1.1的支持类。<br>外部依赖spring-beans，spring-dao，JMS API。</p><h4 id="spring-jca-jar"><a href="#spring-jca-jar" class="headerlink" title="spring-jca.jar"></a>spring-jca.jar</h4><p>对JCA 1.0的支持。<br>外部依赖spring-beans，spring-dao， JCA API。</p><h4 id="spring-jdo-jar"><a href="#spring-jdo-jar" class="headerlink" title="spring-jdo.jar"></a>spring-jdo.jar</h4><p>对JDO 1.0/2.0的支持。<br>外部依赖spring-jdbc， JDO API， (spring-web)。</p><h4 id="spring-jpa-jar"><a href="#spring-jpa-jar" class="headerlink" title="spring-jpa.jar"></a>spring-jpa.jar</h4><p>对JPA 1.0的支持。<br>外部依赖spring-jdbc， JPA API， (spring-web)。</p><h4 id="spring-hibernate2-jar"><a href="#spring-hibernate2-jar" class="headerlink" title="spring-hibernate2.jar"></a>spring-hibernate2.jar</h4><p>对Hibernate 2.1的支持，已经不建议使用。<br>外部依赖spring-jdbc，Hibernate2，(spring-web)。</p><h4 id="spring-hibernate3-jar"><a href="#spring-hibernate3-jar" class="headerlink" title="spring-hibernate3.jar"></a>spring-hibernate3.jar</h4><p>对Hibernate 3.0/3.1/3.2的支持。<br>外部依赖spring-jdbc，Hibernate3，(spring-web)。</p><h4 id="spring-toplink-jar"><a href="#spring-toplink-jar" class="headerlink" title="spring-toplink.jar"></a>spring-toplink.jar</h4><p>对TopLink框架的支持。<br>外部依赖spring-jdbc，TopLink。</p><h4 id="spring-ibatis-jar"><a href="#spring-ibatis-jar" class="headerlink" title="spring-ibatis.jar"></a>spring-ibatis.jar</h4><p>对iBATIS SQL Maps的支持。<br>外部依赖spring-jdbc，iBATIS SQL Maps。</p><p>另外的两个包。</p><h4 id="spring-mock-jar"><a href="#spring-mock-jar" class="headerlink" title="spring-mock.jar"></a>spring-mock.jar</h4><p>这个jar 文件包含Spring 一整套mock 类来辅助应用的测试。Spring 测试套件使用了其中大量mock 类，这样测试就更加简单。模拟HttpServletRequest 和HttpServletResponse 类在Web 应用单元测试是很方便的。并且提供了对JUnit的支持。<br>外部依赖spring-core。</p><h4 id="spring-aspects-jar"><a href="#spring-aspects-jar" class="headerlink" title="spring-aspects.jar"></a>spring-aspects.jar</h4><p>提供对AspectJ的支持，以便可以方便的将面向方面的功能集成进IDE中，比如Eclipse AJDT。<br>外部依赖。</p><p>WEAVER JARS (dist/weavers)说明。</p><h4 id="spring-agent-jar"><a href="#spring-agent-jar" class="headerlink" title="spring-agent.jar"></a>spring-agent.jar</h4><p>Spring的InstrumentationSavingAgent (为InstrumentationLoadTimeWeaver)，一个设备代理包，可以参考JDK1.5的Instrumentation功能获得更多信息。<br>外部依赖none (for use at JVM startup: “-javaagent:spring-agent.jar”)。</p><h4 id="spring-tomcat-weaver-jar"><a href="#spring-tomcat-weaver-jar" class="headerlink" title="spring-tomcat-weaver.jar"></a>spring-tomcat-weaver.jar</h4><p>扩展Tomcat的ClassLoader，使其可以使用instrumentation（设备）类。<br>外部依赖none (for deployment into Tomcat’s “server/lib” directory)。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一个工程需要很多个关于spring的jar包，下面详细说明每个jar的作用。&lt;/p&gt;
    
    </summary>
    
      <category term="Spring In Action" scheme="http://yoursite.com/categories/Spring-In-Action/"/>
    
    
      <category term="Spring" scheme="http://yoursite.com/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>Maven中pom标签详解</title>
    <link href="http://yoursite.com/2017/03/08/Maven%E4%B8%ADpom%E6%A0%87%E7%AD%BE%E8%AF%A6%E8%A7%A3/"/>
    <id>http://yoursite.com/2017/03/08/Maven中pom标签详解/</id>
    <published>2017-03-08T15:02:25.000Z</published>
    <updated>2017-09-28T06:46:28.515Z</updated>
    
    <content type="html"><![CDATA[<p> pom作为项目对象模型。通过xml表示maven项目，使用pom.xml来实现。主要描述了项目：包括配置文件；开发者需要遵循的规则，缺陷管理系统，组织和licenses，项目的url，项目的依赖性，以及其他所有的项目相关因素。<br><a id="more"></a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div><div class="line">178</div><div class="line">179</div><div class="line">180</div><div class="line">181</div><div class="line">182</div><div class="line">183</div><div class="line">184</div><div class="line">185</div><div class="line">186</div><div class="line">187</div><div class="line">188</div><div class="line">189</div><div class="line">190</div><div class="line">191</div><div class="line">192</div><div class="line">193</div><div class="line">194</div><div class="line">195</div><div class="line">196</div><div class="line">197</div><div class="line">198</div><div class="line">199</div><div class="line">200</div><div class="line">201</div><div class="line">202</div><div class="line">203</div><div class="line">204</div><div class="line">205</div><div class="line">206</div><div class="line">207</div><div class="line">208</div><div class="line">209</div><div class="line">210</div><div class="line">211</div><div class="line">212</div><div class="line">213</div><div class="line">214</div><div class="line">215</div><div class="line">216</div><div class="line">217</div><div class="line">218</div><div class="line">219</div><div class="line">220</div><div class="line">221</div><div class="line">222</div><div class="line">223</div><div class="line">224</div><div class="line">225</div><div class="line">226</div><div class="line">227</div><div class="line">228</div><div class="line">229</div><div class="line">230</div><div class="line">231</div><div class="line">232</div><div class="line">233</div><div class="line">234</div><div class="line">235</div><div class="line">236</div><div class="line">237</div><div class="line">238</div><div class="line">239</div><div class="line">240</div><div class="line">241</div><div class="line">242</div><div class="line">243</div><div class="line">244</div><div class="line">245</div><div class="line">246</div><div class="line">247</div><div class="line">248</div><div class="line">249</div><div class="line">250</div><div class="line">251</div><div class="line">252</div><div class="line">253</div><div class="line">254</div><div class="line">255</div><div class="line">256</div><div class="line">257</div><div class="line">258</div><div class="line">259</div><div class="line">260</div><div class="line">261</div><div class="line">262</div><div class="line">263</div><div class="line">264</div><div class="line">265</div><div class="line">266</div><div class="line">267</div><div class="line">268</div><div class="line">269</div><div class="line">270</div><div class="line">271</div><div class="line">272</div><div class="line">273</div><div class="line">274</div><div class="line">275</div><div class="line">276</div><div class="line">277</div><div class="line">278</div><div class="line">279</div><div class="line">280</div><div class="line">281</div><div class="line">282</div><div class="line">283</div><div class="line">284</div><div class="line">285</div><div class="line">286</div><div class="line">287</div><div class="line">288</div><div class="line">289</div><div class="line">290</div><div class="line">291</div><div class="line">292</div><div class="line">293</div><div class="line">294</div><div class="line">295</div><div class="line">296</div><div class="line">297</div><div class="line">298</div><div class="line">299</div><div class="line">300</div><div class="line">301</div><div class="line">302</div><div class="line">303</div><div class="line">304</div><div class="line">305</div><div class="line">306</div><div class="line">307</div><div class="line">308</div><div class="line">309</div><div class="line">310</div><div class="line">311</div><div class="line">312</div><div class="line">313</div><div class="line">314</div><div class="line">315</div><div class="line">316</div><div class="line">317</div><div class="line">318</div><div class="line">319</div><div class="line">320</div><div class="line">321</div><div class="line">322</div><div class="line">323</div><div class="line">324</div><div class="line">325</div><div class="line">326</div><div class="line">327</div><div class="line">328</div><div class="line">329</div><div class="line">330</div><div class="line">331</div><div class="line">332</div><div class="line">333</div><div class="line">334</div><div class="line">335</div><div class="line">336</div><div class="line">337</div><div class="line">338</div><div class="line">339</div><div class="line">340</div><div class="line">341</div><div class="line">342</div><div class="line">343</div><div class="line">344</div><div class="line">345</div><div class="line">346</div><div class="line">347</div><div class="line">348</div><div class="line">349</div><div class="line">350</div><div class="line">351</div><div class="line">352</div><div class="line">353</div><div class="line">354</div><div class="line">355</div><div class="line">356</div><div class="line">357</div><div class="line">358</div><div class="line">359</div><div class="line">360</div><div class="line">361</div><div class="line">362</div><div class="line">363</div><div class="line">364</div><div class="line">365</div><div class="line">366</div><div class="line">367</div><div class="line">368</div><div class="line">369</div><div class="line">370</div><div class="line">371</div><div class="line">372</div><div class="line">373</div><div class="line">374</div><div class="line">375</div><div class="line">376</div><div class="line">377</div><div class="line">378</div><div class="line">379</div><div class="line">380</div><div class="line">381</div><div class="line">382</div><div class="line">383</div><div class="line">384</div><div class="line">385</div><div class="line">386</div><div class="line">387</div><div class="line">388</div><div class="line">389</div><div class="line">390</div><div class="line">391</div><div class="line">392</div><div class="line">393</div><div class="line">394</div><div class="line">395</div><div class="line">396</div><div class="line">397</div><div class="line">398</div><div class="line">399</div><div class="line">400</div><div class="line">401</div><div class="line">402</div><div class="line">403</div><div class="line">404</div><div class="line">405</div><div class="line">406</div><div class="line">407</div><div class="line">408</div><div class="line">409</div><div class="line">410</div><div class="line">411</div><div class="line">412</div><div class="line">413</div><div class="line">414</div><div class="line">415</div><div class="line">416</div><div class="line">417</div><div class="line">418</div><div class="line">419</div><div class="line">420</div><div class="line">421</div><div class="line">422</div><div class="line">423</div><div class="line">424</div><div class="line">425</div><div class="line">426</div><div class="line">427</div><div class="line">428</div><div class="line">429</div><div class="line">430</div><div class="line">431</div><div class="line">432</div><div class="line">433</div><div class="line">434</div><div class="line">435</div><div class="line">436</div><div class="line">437</div><div class="line">438</div><div class="line">439</div><div class="line">440</div><div class="line">441</div><div class="line">442</div><div class="line">443</div><div class="line">444</div><div class="line">445</div><div class="line">446</div><div class="line">447</div><div class="line">448</div><div class="line">449</div><div class="line">450</div><div class="line">451</div><div class="line">452</div><div class="line">453</div><div class="line">454</div><div class="line">455</div><div class="line">456</div><div class="line">457</div><div class="line">458</div><div class="line">459</div><div class="line">460</div><div class="line">461</div><div class="line">462</div><div class="line">463</div><div class="line">464</div><div class="line">465</div><div class="line">466</div><div class="line">467</div><div class="line">468</div><div class="line">469</div><div class="line">470</div><div class="line">471</div><div class="line">472</div><div class="line">473</div><div class="line">474</div><div class="line">475</div><div class="line">476</div><div class="line">477</div><div class="line">478</div><div class="line">479</div><div class="line">480</div><div class="line">481</div><div class="line">482</div><div class="line">483</div><div class="line">484</div><div class="line">485</div><div class="line">486</div><div class="line">487</div><div class="line">488</div><div class="line">489</div><div class="line">490</div><div class="line">491</div><div class="line">492</div><div class="line">493</div><div class="line">494</div><div class="line">495</div><div class="line">496</div><div class="line">497</div><div class="line">498</div><div class="line">499</div><div class="line">500</div><div class="line">501</div><div class="line">502</div><div class="line">503</div><div class="line">504</div><div class="line">505</div><div class="line">506</div><div class="line">507</div><div class="line">508</div><div class="line">509</div><div class="line">510</div><div class="line">511</div><div class="line">512</div><div class="line">513</div><div class="line">514</div><div class="line">515</div><div class="line">516</div><div class="line">517</div><div class="line">518</div><div class="line">519</div><div class="line">520</div><div class="line">521</div><div class="line">522</div><div class="line">523</div><div class="line">524</div><div class="line">525</div><div class="line">526</div><div class="line">527</div><div class="line">528</div><div class="line">529</div><div class="line">530</div><div class="line">531</div><div class="line">532</div><div class="line">533</div><div class="line">534</div><div class="line">535</div><div class="line">536</div><div class="line">537</div><div class="line">538</div><div class="line">539</div><div class="line">540</div><div class="line">541</div><div class="line">542</div><div class="line">543</div><div class="line">544</div><div class="line">545</div><div class="line">546</div><div class="line">547</div><div class="line">548</div><div class="line">549</div><div class="line">550</div><div class="line">551</div><div class="line">552</div><div class="line">553</div><div class="line">554</div><div class="line">555</div><div class="line">556</div><div class="line">557</div><div class="line">558</div><div class="line">559</div><div class="line">560</div><div class="line">561</div><div class="line">562</div><div class="line">563</div><div class="line">564</div><div class="line">565</div><div class="line">566</div><div class="line">567</div><div class="line">568</div><div class="line">569</div><div class="line">570</div><div class="line">571</div><div class="line">572</div><div class="line">573</div><div class="line">574</div><div class="line">575</div><div class="line">576</div><div class="line">577</div><div class="line">578</div><div class="line">579</div><div class="line">580</div><div class="line">581</div><div class="line">582</div><div class="line">583</div><div class="line">584</div><div class="line">585</div><div class="line">586</div><div class="line">587</div><div class="line">588</div><div class="line">589</div><div class="line">590</div><div class="line">591</div><div class="line">592</div><div class="line">593</div><div class="line">594</div><div class="line">595</div><div class="line">596</div><div class="line">597</div><div class="line">598</div><div class="line">599</div><div class="line">600</div><div class="line">601</div></pre></td><td class="code"><pre><div class="line">&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;     </div><div class="line">    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;     </div><div class="line">xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0http://maven.apache.org/maven-v4_0_0.xsd&quot;&gt;     </div><div class="line">    &lt;!--父项目的坐标。如果项目中没有规定某个元素的值，那么父项目中的对应值即为项目的默认值。 坐标包括group ID，artifact ID和 version。--&gt;    </div><div class="line">    &lt;parent&gt;    </div><div class="line">     &lt;!--被继承的父项目的构件标识符--&gt;    </div><div class="line">     &lt;artifactId/&gt;    </div><div class="line">     &lt;!--被继承的父项目的全球唯一标识符--&gt;    </div><div class="line">     &lt;groupId/&gt;    </div><div class="line">     &lt;!--被继承的父项目的版本--&gt;    </div><div class="line">     &lt;version/&gt;    </div><div class="line">     &lt;!-- 父项目的pom.xml文件的相对路径。相对路径允许你选择一个不同的路径。默认值是../pom.xml。Maven首先在构建当前项目的地方寻找父项 目的pom，其次在文件系统的这个位置（relativePath位置），然后在本地仓库，最后在远程仓库寻找父项目的pom。--&gt;    </div><div class="line">     &lt;relativePath/&gt;    </div><div class="line"> &lt;/parent&gt;    </div><div class="line"> &lt;!--声明项目描述符遵循哪一个POM模型版本。模型本身的版本很少改变，虽然如此，但它仍然是必不可少的，这是为了当Maven引入了新的特性或者其他模型变更的时候，确保稳定性。--&gt;       </div><div class="line">    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;     </div><div class="line">    &lt;!--项目的全球唯一标识符，通常使用全限定的包名区分该项目和其他项目。并且构建时生成的路径也是由此生成， 如com.mycompany.app生成的相对路径为：/com/mycompany/app--&gt;     </div><div class="line">    &lt;groupId&gt;asia.banseon&lt;/groupId&gt;     </div><div class="line">    &lt;!-- 构件的标识符，它和group ID一起唯一标识一个构件。换句话说，你不能有两个不同的项目拥有同样的artifact ID和groupID；在某个 特定的group ID下，artifact ID也必须是唯一的。构件是项目产生的或使用的一个东西，Maven为项目产生的构件包括：JARs，源 码，二进制发布和WARs等。--&gt;     </div><div class="line">    &lt;artifactId&gt;banseon-maven2&lt;/artifactId&gt;     </div><div class="line">    &lt;!--项目产生的构件类型，例如jar、war、ear、pom。插件可以创建他们自己的构件类型，所以前面列的不是全部构件类型--&gt;     </div><div class="line">    &lt;packaging&gt;jar&lt;/packaging&gt;     </div><div class="line">    &lt;!--项目当前版本，格式为:主版本.次版本.增量版本-限定版本号--&gt;     </div><div class="line">    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;     </div><div class="line">    &lt;!--项目的名称, Maven产生的文档用--&gt;     </div><div class="line">    &lt;name&gt;banseon-maven&lt;/name&gt;     </div><div class="line">    &lt;!--项目主页的URL, Maven产生的文档用--&gt;     </div><div class="line">    &lt;url&gt;http://www.baidu.com/banseon&lt;/url&gt;     </div><div class="line">    &lt;!-- 项目的详细描述, Maven 产生的文档用。  当这个元素能够用HTML格式描述时（例如，CDATA中的文本会被解析器忽略，就可以包含HTML标 签）， 不鼓励使用纯文本描述。如果你需要修改产生的web站点的索引页面，你应该修改你自己的索引页文件，而不是调整这里的文档。--&gt;     </div><div class="line">    &lt;description&gt;A maven project to study maven.&lt;/description&gt;     </div><div class="line">    &lt;!--描述了这个项目构建环境中的前提条件。--&gt;    </div><div class="line"> &lt;prerequisites&gt;    </div><div class="line">  &lt;!--构建该项目或使用该插件所需要的Maven的最低版本--&gt;    </div><div class="line">    &lt;maven/&gt;    </div><div class="line"> &lt;/prerequisites&gt;    </div><div class="line"> &lt;!--项目的问题管理系统(Bugzilla, Jira, Scarab,或任何你喜欢的问题管理系统)的名称和URL，本例为 jira--&gt;     </div><div class="line">    &lt;issueManagement&gt;    </div><div class="line">     &lt;!--问题管理系统（例如jira）的名字，--&gt;     </div><div class="line">        &lt;system&gt;jira&lt;/system&gt;     </div><div class="line">        &lt;!--该项目使用的问题管理系统的URL--&gt;    </div><div class="line">        &lt;url&gt;http://jira.baidu.com/banseon&lt;/url&gt;     </div><div class="line">    &lt;/issueManagement&gt;     </div><div class="line">    &lt;!--项目持续集成信息--&gt;    </div><div class="line"> &lt;ciManagement&gt;    </div><div class="line">  &lt;!--持续集成系统的名字，例如continuum--&gt;    </div><div class="line">  &lt;system/&gt;    </div><div class="line">  &lt;!--该项目使用的持续集成系统的URL（如果持续集成系统有web接口的话）。--&gt;    </div><div class="line">  &lt;url/&gt;    </div><div class="line">  &lt;!--构建完成时，需要通知的开发者/用户的配置项。包括被通知者信息和通知条件（错误，失败，成功，警告）--&gt;    </div><div class="line">  &lt;notifiers&gt;    </div><div class="line">   &lt;!--配置一种方式，当构建中断时，以该方式通知用户/开发者--&gt;    </div><div class="line">   &lt;notifier&gt;    </div><div class="line">    &lt;!--传送通知的途径--&gt;    </div><div class="line">    &lt;type/&gt;    </div><div class="line">    &lt;!--发生错误时是否通知--&gt;    </div><div class="line">    &lt;sendOnError/&gt;    </div><div class="line">    &lt;!--构建失败时是否通知--&gt;    </div><div class="line">    &lt;sendOnFailure/&gt;    </div><div class="line">    &lt;!--构建成功时是否通知--&gt;    </div><div class="line">    &lt;sendOnSuccess/&gt;    </div><div class="line">    &lt;!--发生警告时是否通知--&gt;    </div><div class="line">    &lt;sendOnWarning/&gt;    </div><div class="line">    &lt;!--不赞成使用。通知发送到哪里--&gt;    </div><div class="line">    &lt;address/&gt;    </div><div class="line">    &lt;!--扩展配置项--&gt;    </div><div class="line">    &lt;configuration/&gt;    </div><div class="line">   &lt;/notifier&gt;    </div><div class="line">  &lt;/notifiers&gt;    </div><div class="line"> &lt;/ciManagement&gt;    </div><div class="line"> &lt;!--项目创建年份，4位数字。当产生版权信息时需要使用这个值。--&gt;    </div><div class="line">    &lt;inceptionYear/&gt;    </div><div class="line">    &lt;!--项目相关邮件列表信息--&gt;     </div><div class="line">    &lt;mailingLists&gt;    </div><div class="line">     &lt;!--该元素描述了项目相关的所有邮件列表。自动产生的网站引用这些信息。--&gt;     </div><div class="line">        &lt;mailingList&gt;     </div><div class="line">         &lt;!--邮件的名称--&gt;    </div><div class="line">            &lt;name&gt;Demo&lt;/name&gt;     </div><div class="line">            &lt;!--发送邮件的地址或链接，如果是邮件地址，创建文档时，mailto: 链接会被自动创建--&gt;     </div><div class="line">            &lt;post&gt;banseon@126.com&lt;/post&gt;     </div><div class="line">            &lt;!--订阅邮件的地址或链接，如果是邮件地址，创建文档时，mailto: 链接会被自动创建--&gt;     </div><div class="line">            &lt;subscribe&gt;banseon@126.com&lt;/subscribe&gt;     </div><div class="line">            &lt;!--取消订阅邮件的地址或链接，如果是邮件地址，创建文档时，mailto: 链接会被自动创建--&gt;     </div><div class="line">            &lt;unsubscribe&gt;banseon@126.com&lt;/unsubscribe&gt;     </div><div class="line">            &lt;!--你可以浏览邮件信息的URL--&gt;    </div><div class="line">            &lt;archive&gt;http:/hi.baidu.com/banseon/demo/dev/&lt;/archive&gt;     </div><div class="line">        &lt;/mailingList&gt;     </div><div class="line">    &lt;/mailingLists&gt;     </div><div class="line">    &lt;!--项目开发者列表--&gt;     </div><div class="line">    &lt;developers&gt;     </div><div class="line">     &lt;!--某个项目开发者的信息--&gt;    </div><div class="line">        &lt;developer&gt;     </div><div class="line">         &lt;!--SCM里项目开发者的唯一标识符--&gt;    </div><div class="line">            &lt;id&gt;HELLO WORLD&lt;/id&gt;     </div><div class="line">            &lt;!--项目开发者的全名--&gt;    </div><div class="line">            &lt;name&gt;banseon&lt;/name&gt;     </div><div class="line">            &lt;!--项目开发者的email--&gt;    </div><div class="line">            &lt;email&gt;banseon@126.com&lt;/email&gt;     </div><div class="line">            &lt;!--项目开发者的主页的URL--&gt;    </div><div class="line">            &lt;url/&gt;    </div><div class="line">            &lt;!--项目开发者在项目中扮演的角色，角色元素描述了各种角色--&gt;    </div><div class="line">            &lt;roles&gt;     </div><div class="line">                &lt;role&gt;Project Manager&lt;/role&gt;     </div><div class="line">                &lt;role&gt;Architect&lt;/role&gt;     </div><div class="line">            &lt;/roles&gt;    </div><div class="line">            &lt;!--项目开发者所属组织--&gt;    </div><div class="line">            &lt;organization&gt;demo&lt;/organization&gt;     </div><div class="line">            &lt;!--项目开发者所属组织的URL--&gt;    </div><div class="line">            &lt;organizationUrl&gt;http://hi.baidu.com/banseon&lt;/organizationUrl&gt;     </div><div class="line">            &lt;!--项目开发者属性，如即时消息如何处理等--&gt;    </div><div class="line">            &lt;properties&gt;     </div><div class="line">                &lt;dept&gt;No&lt;/dept&gt;     </div><div class="line">            &lt;/properties&gt;    </div><div class="line">            &lt;!--项目开发者所在时区， -11到12范围内的整数。--&gt;    </div><div class="line">            &lt;timezone&gt;-5&lt;/timezone&gt;     </div><div class="line">        &lt;/developer&gt;     </div><div class="line">    &lt;/developers&gt;     </div><div class="line">    &lt;!--项目的其他贡献者列表--&gt;     </div><div class="line">    &lt;contributors&gt;    </div><div class="line">     &lt;!--项目的其他贡献者。参见developers/developer元素--&gt;    </div><div class="line">     &lt;contributor&gt;    </div><div class="line">   &lt;name/&gt;&lt;email/&gt;&lt;url/&gt;&lt;organization/&gt;&lt;organizationUrl/&gt;&lt;roles/&gt;&lt;timezone/&gt;&lt;properties/&gt;    </div><div class="line">     &lt;/contributor&gt;         </div><div class="line">    &lt;/contributors&gt;       </div><div class="line">    &lt;!--该元素描述了项目所有License列表。 应该只列出该项目的license列表，不要列出依赖项目的 license列表。如果列出多个license，用户可以选择它们中的一个而不是接受所有license。--&gt;     </div><div class="line">    &lt;licenses&gt;    </div><div class="line">     &lt;!--描述了项目的license，用于生成项目的web站点的license页面，其他一些报表和validation也会用到该元素。--&gt;     </div><div class="line">        &lt;license&gt;    </div><div class="line">         &lt;!--license用于法律上的名称--&gt;    </div><div class="line">            &lt;name&gt;Apache 2&lt;/name&gt;     </div><div class="line">            &lt;!--官方的license正文页面的URL--&gt;    </div><div class="line">            &lt;url&gt;http://www.baidu.com/banseon/LICENSE-2.0.txt&lt;/url&gt;     </div><div class="line">            &lt;!--项目分发的主要方式：    </div><div class="line">              repo，可以从Maven库下载    </div><div class="line">              manual， 用户必须手动下载和安装依赖--&gt;    </div><div class="line">            &lt;distribution&gt;repo&lt;/distribution&gt;     </div><div class="line">            &lt;!--关于license的补充信息--&gt;    </div><div class="line">            &lt;comments&gt;A business-friendly OSS license&lt;/comments&gt;</div><div class="line">        &lt;/license&gt;     </div><div class="line">    &lt;/licenses&gt;     </div><div class="line">    &lt;!--SCM(Source Control Management)标签允许你配置你的代码库，供Maven web站点和其它插件使用。--&gt;     </div><div class="line">    &lt;scm&gt;     </div><div class="line">        &lt;!--SCM的URL,该URL描述了版本库和如何连接到版本库。欲知详情，请看SCMs提供的URL格式和列表。该连接只读。--&gt;     </div><div class="line">        &lt;connection&gt;     </div><div class="line">            scm:svn:http://svn.baidu.com/banseon/maven/banseon/banseon-maven2-trunk(dao-trunk)      </div><div class="line">        &lt;/connection&gt;     </div><div class="line">        &lt;!--给开发者使用的，类似connection元素。即该连接不仅仅只读--&gt;    </div><div class="line">        &lt;developerConnection&gt;     </div><div class="line">            scm:svn:http://svn.baidu.com/banseon/maven/banseon/dao-trunk      </div><div class="line">        &lt;/developerConnection&gt;    </div><div class="line">        &lt;!--当前代码的标签，在开发阶段默认为HEAD--&gt;    </div><div class="line">        &lt;tag/&gt;           </div><div class="line">        &lt;!--指向项目的可浏览SCM库（例如ViewVC或者Fisheye）的URL。--&gt;     </div><div class="line">        &lt;url&gt;http://svn.baidu.com/banseon&lt;/url&gt;     </div><div class="line">    &lt;/scm&gt;     </div><div class="line">    &lt;!--描述项目所属组织的各种属性。Maven产生的文档用--&gt;     </div><div class="line">    &lt;organization&gt;     </div><div class="line">     &lt;!--组织的全名--&gt;    </div><div class="line">        &lt;name&gt;demo&lt;/name&gt;     </div><div class="line">        &lt;!--组织主页的URL--&gt;    </div><div class="line">        &lt;url&gt;http://www.baidu.com/banseon&lt;/url&gt;     </div><div class="line">    &lt;/organization&gt;    </div><div class="line">    &lt;!--构建项目需要的信息--&gt;    </div><div class="line">    &lt;build&gt;    </div><div class="line">     &lt;!--该元素设置了项目源码目录，当构建项目的时候，构建系统会编译目录里的源码。该路径是相对于pom.xml的相对路径。--&gt;    </div><div class="line">  &lt;sourceDirectory/&gt;    </div><div class="line">  &lt;!--该元素设置了项目脚本源码目录，该目录和源码目录不同：绝大多数情况下，该目录下的内容 会被拷贝到输出目录(因为脚本是被解释的，而不是被编译的)。--&gt;    </div><div class="line">  &lt;scriptSourceDirectory/&gt;    </div><div class="line">  &lt;!--该元素设置了项目单元测试使用的源码目录，当测试项目的时候，构建系统会编译目录里的源码。该路径是相对于pom.xml的相对路径。--&gt;    </div><div class="line">  &lt;testSourceDirectory/&gt;    </div><div class="line">  &lt;!--被编译过的应用程序class文件存放的目录。--&gt;    </div><div class="line">  &lt;outputDirectory/&gt;    </div><div class="line">  &lt;!--被编译过的测试class文件存放的目录。--&gt;    </div><div class="line">  &lt;testOutputDirectory/&gt;    </div><div class="line">  &lt;!--使用来自该项目的一系列构建扩展--&gt;    </div><div class="line">  &lt;extensions&gt;    </div><div class="line">   &lt;!--描述使用到的构建扩展。--&gt;    </div><div class="line">   &lt;extension&gt;    </div><div class="line">    &lt;!--构建扩展的groupId--&gt;    </div><div class="line">    &lt;groupId/&gt;    </div><div class="line">    &lt;!--构建扩展的artifactId--&gt;    </div><div class="line">    &lt;artifactId/&gt;    </div><div class="line">    &lt;!--构建扩展的版本--&gt;    </div><div class="line">    &lt;version/&gt;    </div><div class="line">   &lt;/extension&gt;    </div><div class="line">  &lt;/extensions&gt;    </div><div class="line">  &lt;!--当项目没有规定目标（Maven2 叫做阶段）时的默认值--&gt;    </div><div class="line">  &lt;defaultGoal/&gt;    </div><div class="line">  &lt;!--这个元素描述了项目相关的所有资源路径列表，例如和项目相关的属性文件，这些资源被包含在最终的打包文件里。--&gt;    </div><div class="line">  &lt;resources&gt;    </div><div class="line">   &lt;!--这个元素描述了项目相关或测试相关的所有资源路径--&gt;    </div><div class="line">   &lt;resource&gt;    </div><div class="line">    &lt;!-- 描述了资源的目标路径。该路径相对target/classes目录（例如$&#123;project.build.outputDirectory&#125;）。举个例 子，如果你想资源在特定的包里(org.apache.maven.messages)，你就必须该元素设置为org/apache/maven /messages。然而，如果你只是想把资源放到源码目录结构里，就不需要该配置。--&gt;    </div><div class="line">    &lt;targetPath/&gt;    </div><div class="line">    &lt;!--是否使用参数值代替参数名。参数值取自properties元素或者文件里配置的属性，文件在filters元素里列出。--&gt;    </div><div class="line">    &lt;filtering/&gt;    </div><div class="line">    &lt;!--描述存放资源的目录，该路径相对POM路径--&gt;    </div><div class="line">    &lt;directory/&gt;    </div><div class="line">    &lt;!--包含的模式列表，例如**/*.xml.--&gt;    </div><div class="line">    &lt;includes/&gt;    </div><div class="line">    &lt;!--排除的模式列表，例如**/*.xml--&gt;    </div><div class="line">    &lt;excludes/&gt;    </div><div class="line">   &lt;/resource&gt;    </div><div class="line">  &lt;/resources&gt;    </div><div class="line">  &lt;!--这个元素描述了单元测试相关的所有资源路径，例如和单元测试相关的属性文件。--&gt;    </div><div class="line">  &lt;testResources&gt;    </div><div class="line">   &lt;!--这个元素描述了测试相关的所有资源路径，参见build/resources/resource元素的说明--&gt;    </div><div class="line">   &lt;testResource&gt;    </div><div class="line">    &lt;targetPath/&gt;&lt;filtering/&gt;&lt;directory/&gt;&lt;includes/&gt;&lt;excludes/&gt;    </div><div class="line">   &lt;/testResource&gt;    </div><div class="line">  &lt;/testResources&gt;    </div><div class="line">  &lt;!--构建产生的所有文件存放的目录--&gt;    </div><div class="line">  &lt;directory/&gt;    </div><div class="line">  &lt;!--产生的构件的文件名，默认值是$&#123;artifactId&#125;-$&#123;version&#125;。--&gt;    </div><div class="line">  &lt;finalName/&gt;    </div><div class="line">  &lt;!--当filtering开关打开时，使用到的过滤器属性文件列表--&gt;    </div><div class="line">  &lt;filters/&gt;    </div><div class="line">  &lt;!--子项目可以引用的默认插件信息。该插件配置项直到被引用时才会被解析或绑定到生命周期。给定插件的任何本地配置都会覆盖这里的配置--&gt;    </div><div class="line">  &lt;pluginManagement&gt;    </div><div class="line">   &lt;!--使用的插件列表 。--&gt;    </div><div class="line">   &lt;plugins&gt;    </div><div class="line">    &lt;!--plugin元素包含描述插件所需要的信息。--&gt;    </div><div class="line">    &lt;plugin&gt;    </div><div class="line">     &lt;!--插件在仓库里的group ID--&gt;    </div><div class="line">     &lt;groupId/&gt;    </div><div class="line">     &lt;!--插件在仓库里的artifact ID--&gt;    </div><div class="line">     &lt;artifactId/&gt;    </div><div class="line">     &lt;!--被使用的插件的版本（或版本范围）--&gt;    </div><div class="line">     &lt;version/&gt;    </div><div class="line">     &lt;!--是否从该插件下载Maven扩展（例如打包和类型处理器），由于性能原因，只有在真需要下载时，该元素才被设置成enabled。--&gt;    </div><div class="line">     &lt;extensions/&gt;    </div><div class="line">     &lt;!--在构建生命周期中执行一组目标的配置。每个目标可能有不同的配置。--&gt;    </div><div class="line">     &lt;executions&gt;    </div><div class="line">      &lt;!--execution元素包含了插件执行需要的信息--&gt;    </div><div class="line">      &lt;execution&gt;    </div><div class="line">       &lt;!--执行目标的标识符，用于标识构建过程中的目标，或者匹配继承过程中需要合并的执行目标--&gt;    </div><div class="line">       &lt;id/&gt;    </div><div class="line">       &lt;!--绑定了目标的构建生命周期阶段，如果省略，目标会被绑定到源数据里配置的默认阶段--&gt;    </div><div class="line">       &lt;phase/&gt;    </div><div class="line">       &lt;!--配置的执行目标--&gt;    </div><div class="line">       &lt;goals/&gt;    </div><div class="line">       &lt;!--配置是否被传播到子POM--&gt;    </div><div class="line">       &lt;inherited/&gt;    </div><div class="line">       &lt;!--作为DOM对象的配置--&gt;    </div><div class="line">       &lt;configuration/&gt;    </div><div class="line">      &lt;/execution&gt;    </div><div class="line">     &lt;/executions&gt;    </div><div class="line">     &lt;!--项目引入插件所需要的额外依赖--&gt;    </div><div class="line">     &lt;dependencies&gt;    </div><div class="line">      &lt;!--参见dependencies/dependency元素--&gt;    </div><div class="line">      &lt;dependency&gt;    </div><div class="line">       ......    </div><div class="line">      &lt;/dependency&gt;    </div><div class="line">     &lt;/dependencies&gt;         </div><div class="line">     &lt;!--任何配置是否被传播到子项目--&gt;    </div><div class="line">     &lt;inherited/&gt;    </div><div class="line">     &lt;!--作为DOM对象的配置--&gt;    </div><div class="line">     &lt;configuration/&gt;    </div><div class="line">    &lt;/plugin&gt;    </div><div class="line">   &lt;/plugins&gt;    </div><div class="line">  &lt;/pluginManagement&gt;    </div><div class="line">  &lt;!--使用的插件列表--&gt;    </div><div class="line">  &lt;plugins&gt;    </div><div class="line">   &lt;!--参见build/pluginManagement/plugins/plugin元素--&gt;    </div><div class="line">   &lt;plugin&gt;    </div><div class="line">    &lt;groupId/&gt;&lt;artifactId/&gt;&lt;version/&gt;&lt;extensions/&gt;    </div><div class="line">    &lt;executions&gt;    </div><div class="line">     &lt;execution&gt;    </div><div class="line">      &lt;id/&gt;&lt;phase/&gt;&lt;goals/&gt;&lt;inherited/&gt;&lt;configuration/&gt;    </div><div class="line">     &lt;/execution&gt;    </div><div class="line">    &lt;/executions&gt;    </div><div class="line">    &lt;dependencies&gt;    </div><div class="line">     &lt;!--参见dependencies/dependency元素--&gt;    </div><div class="line">     &lt;dependency&gt;    </div><div class="line">      ......    </div><div class="line">     &lt;/dependency&gt;    </div><div class="line">    &lt;/dependencies&gt;    </div><div class="line">    &lt;goals/&gt;&lt;inherited/&gt;&lt;configuration/&gt;    </div><div class="line">   &lt;/plugin&gt;    </div><div class="line">  &lt;/plugins&gt;    </div><div class="line"> &lt;/build&gt;    </div><div class="line"> &lt;!--在列的项目构建profile，如果被激活，会修改构建处理--&gt;    </div><div class="line"> &lt;profiles&gt;    </div><div class="line">  &lt;!--根据环境参数或命令行参数激活某个构建处理--&gt;    </div><div class="line">  &lt;profile&gt;    </div><div class="line">   &lt;!--构建配置的唯一标识符。即用于命令行激活，也用于在继承时合并具有相同标识符的profile。--&gt;    </div><div class="line">   &lt;id/&gt;    </div><div class="line">   &lt;!--自动触发profile的条件逻辑。Activation是profile的开启钥匙。profile的力量来自于它    </div><div class="line">   能够在某些特定的环境中自动使用某些特定的值；这些环境通过activation元素指定。activation元素并不是激活profile的唯一方式。--&gt;    </div><div class="line">   &lt;activation&gt;    </div><div class="line">    &lt;!--profile默认是否激活的标志--&gt;    </div><div class="line">    &lt;activeByDefault/&gt;    </div><div class="line">    &lt;!--当匹配的jdk被检测到，profile被激活。例如，1.4激活JDK1.4，1.4.0_2，而!1.4激活所有版本不是以1.4开头的JDK。--&gt;    </div><div class="line">    &lt;jdk/&gt;    </div><div class="line">    &lt;!--当匹配的操作系统属性被检测到，profile被激活。os元素可以定义一些操作系统相关的属性。--&gt;    </div><div class="line">    &lt;os&gt;    </div><div class="line">     &lt;!--激活profile的操作系统的名字--&gt;    </div><div class="line">     &lt;name&gt;Windows XP&lt;/name&gt;    </div><div class="line">     &lt;!--激活profile的操作系统所属家族(如 &apos;windows&apos;)--&gt;    </div><div class="line">     &lt;family&gt;Windows&lt;/family&gt;    </div><div class="line">     &lt;!--激活profile的操作系统体系结构 --&gt;    </div><div class="line">     &lt;arch&gt;x86&lt;/arch&gt;    </div><div class="line">     &lt;!--激活profile的操作系统版本--&gt;    </div><div class="line">     &lt;version&gt;5.1.2600&lt;/version&gt;    </div><div class="line">    &lt;/os&gt;    </div><div class="line">    &lt;!--如果Maven检测到某一个属性（其值可以在POM中通过$&#123;名称&#125;引用），其拥有对应的名称和值，Profile就会被激活。如果值    </div><div class="line">    字段是空的，那么存在属性名称字段就会激活profile，否则按区分大小写方式匹配属性值字段--&gt;    </div><div class="line">    &lt;property&gt;    </div><div class="line">     &lt;!--激活profile的属性的名称--&gt;    </div><div class="line">     &lt;name&gt;mavenVersion&lt;/name&gt;    </div><div class="line">     &lt;!--激活profile的属性的值--&gt;    </div><div class="line">     &lt;value&gt;2.0.3&lt;/value&gt;    </div><div class="line">    &lt;/property&gt;    </div><div class="line">    &lt;!--提供一个文件名，通过检测该文件的存在或不存在来激活profile。missing检查文件是否存在，如果不存在则激活    </div><div class="line">    profile。另一方面，exists则会检查文件是否存在，如果存在则激活profile。--&gt;    </div><div class="line">    &lt;file&gt;    </div><div class="line">     &lt;!--如果指定的文件存在，则激活profile。--&gt;    </div><div class="line">     &lt;exists&gt;/usr/local/hudson/hudson-home/jobs/maven-guide-zh-to-production/workspace/&lt;/exists&gt;    </div><div class="line">     &lt;!--如果指定的文件不存在，则激活profile。--&gt;    </div><div class="line">     &lt;missing&gt;/usr/local/hudson/hudson-home/jobs/maven-guide-zh-to-production/workspace/&lt;/missing&gt;    </div><div class="line">    &lt;/file&gt;    </div><div class="line">   &lt;/activation&gt;    </div><div class="line">   &lt;!--构建项目所需要的信息。参见build元素--&gt;    </div><div class="line">   &lt;build&gt;    </div><div class="line">    &lt;defaultGoal/&gt;    </div><div class="line">    &lt;resources&gt;    </div><div class="line">     &lt;resource&gt;    </div><div class="line">      &lt;targetPath/&gt;&lt;filtering/&gt;&lt;directory/&gt;&lt;includes/&gt;&lt;excludes/&gt;    </div><div class="line">     &lt;/resource&gt;    </div><div class="line">    &lt;/resources&gt;    </div><div class="line">    &lt;testResources&gt;    </div><div class="line">     &lt;testResource&gt;    </div><div class="line">      &lt;targetPath/&gt;&lt;filtering/&gt;&lt;directory/&gt;&lt;includes/&gt;&lt;excludes/&gt;    </div><div class="line">     &lt;/testResource&gt;    </div><div class="line">    &lt;/testResources&gt;    </div><div class="line">    &lt;directory/&gt;&lt;finalName/&gt;&lt;filters/&gt;    </div><div class="line">    &lt;pluginManagement&gt;    </div><div class="line">     &lt;plugins&gt;    </div><div class="line">      &lt;!--参见build/pluginManagement/plugins/plugin元素--&gt;    </div><div class="line">      &lt;plugin&gt;    </div><div class="line">       &lt;groupId/&gt;&lt;artifactId/&gt;&lt;version/&gt;&lt;extensions/&gt;    </div><div class="line">       &lt;executions&gt;    </div><div class="line">        &lt;execution&gt;    </div><div class="line">         &lt;id/&gt;&lt;phase/&gt;&lt;goals/&gt;&lt;inherited/&gt;&lt;configuration/&gt;    </div><div class="line">        &lt;/execution&gt;    </div><div class="line">       &lt;/executions&gt;    </div><div class="line">       &lt;dependencies&gt;    </div><div class="line">        &lt;!--参见dependencies/dependency元素--&gt;    </div><div class="line">        &lt;dependency&gt;    </div><div class="line">         ......    </div><div class="line">        &lt;/dependency&gt;    </div><div class="line">       &lt;/dependencies&gt;    </div><div class="line">       &lt;goals/&gt;&lt;inherited/&gt;&lt;configuration/&gt;    </div><div class="line">      &lt;/plugin&gt;    </div><div class="line">     &lt;/plugins&gt;    </div><div class="line">    &lt;/pluginManagement&gt;    </div><div class="line">    &lt;plugins&gt;    </div><div class="line">     &lt;!--参见build/pluginManagement/plugins/plugin元素--&gt;    </div><div class="line">     &lt;plugin&gt;    </div><div class="line">      &lt;groupId/&gt;&lt;artifactId/&gt;&lt;version/&gt;&lt;extensions/&gt;    </div><div class="line">      &lt;executions&gt;    </div><div class="line">       &lt;execution&gt;    </div><div class="line">        &lt;id/&gt;&lt;phase/&gt;&lt;goals/&gt;&lt;inherited/&gt;&lt;configuration/&gt;    </div><div class="line">       &lt;/execution&gt;    </div><div class="line">      &lt;/executions&gt;    </div><div class="line">      &lt;dependencies&gt;    </div><div class="line">       &lt;!--参见dependencies/dependency元素--&gt;    </div><div class="line">       &lt;dependency&gt;    </div><div class="line">        ......    </div><div class="line">       &lt;/dependency&gt;    </div><div class="line">      &lt;/dependencies&gt;    </div><div class="line">      &lt;goals/&gt;&lt;inherited/&gt;&lt;configuration/&gt;    </div><div class="line">     &lt;/plugin&gt;    </div><div class="line">    &lt;/plugins&gt;    </div><div class="line">   &lt;/build&gt;    </div><div class="line">   &lt;!--模块（有时称作子项目） 被构建成项目的一部分。列出的每个模块元素是指向该模块的目录的相对路径--&gt;    </div><div class="line">   &lt;modules/&gt;    </div><div class="line">   &lt;!--发现依赖和扩展的远程仓库列表。--&gt;    </div><div class="line">   &lt;repositories&gt;    </div><div class="line">    &lt;!--参见repositories/repository元素--&gt;    </div><div class="line">    &lt;repository&gt;    </div><div class="line">     &lt;releases&gt;    </div><div class="line">      &lt;enabled/&gt;&lt;updatePolicy/&gt;&lt;checksumPolicy/&gt;    </div><div class="line">     &lt;/releases&gt;    </div><div class="line">     &lt;snapshots&gt;    </div><div class="line">      &lt;enabled/&gt;&lt;updatePolicy/&gt;&lt;checksumPolicy/&gt;    </div><div class="line">     &lt;/snapshots&gt;    </div><div class="line">     &lt;id/&gt;&lt;name/&gt;&lt;url/&gt;&lt;layout/&gt;    </div><div class="line">    &lt;/repository&gt;    </div><div class="line">   &lt;/repositories&gt;    </div><div class="line">   &lt;!--发现插件的远程仓库列表，这些插件用于构建和报表--&gt;    </div><div class="line">   &lt;pluginRepositories&gt;    </div><div class="line">    &lt;!--包含需要连接到远程插件仓库的信息.参见repositories/repository元素--&gt;        </div><div class="line">    &lt;pluginRepository&gt;    </div><div class="line">     &lt;releases&gt;    </div><div class="line">      &lt;enabled/&gt;&lt;updatePolicy/&gt;&lt;checksumPolicy/&gt;    </div><div class="line">     &lt;/releases&gt;    </div><div class="line">     &lt;snapshots&gt;    </div><div class="line">      &lt;enabled/&gt;&lt;updatePolicy/&gt;&lt;checksumPolicy/&gt;    </div><div class="line">     &lt;/snapshots&gt;    </div><div class="line">     &lt;id/&gt;&lt;name/&gt;&lt;url/&gt;&lt;layout/&gt;    </div><div class="line">    &lt;/pluginRepository&gt;    </div><div class="line">   &lt;/pluginRepositories&gt;    </div><div class="line">   &lt;!--该元素描述了项目相关的所有依赖。 这些依赖组成了项目构建过程中的一个个环节。它们自动从项目定义的仓库中下载。要获取更多信息，请看项目依赖机制。--&gt;    </div><div class="line">   &lt;dependencies&gt;    </div><div class="line">    &lt;!--参见dependencies/dependency元素--&gt;    </div><div class="line">    &lt;dependency&gt;    </div><div class="line">     ......    </div><div class="line">    &lt;/dependency&gt;    </div><div class="line">   &lt;/dependencies&gt;    </div><div class="line">   &lt;!--不赞成使用. 现在Maven忽略该元素.--&gt;    </div><div class="line">   &lt;reports/&gt;       </div><div class="line">   &lt;!--该元素包括使用报表插件产生报表的规范。当用户执行“mvn site”，这些报表就会运行。 在页面导航栏能看到所有报表的链接。参见reporting元素--&gt;    </div><div class="line">   &lt;reporting&gt;    </div><div class="line">    ......    </div><div class="line">   &lt;/reporting&gt;    </div><div class="line">   &lt;!--参见dependencyManagement元素--&gt;    </div><div class="line">   &lt;dependencyManagement&gt;    </div><div class="line">    &lt;dependencies&gt;    </div><div class="line">     &lt;!--参见dependencies/dependency元素--&gt;    </div><div class="line">     &lt;dependency&gt;    </div><div class="line">      ......    </div><div class="line">     &lt;/dependency&gt;    </div><div class="line">    &lt;/dependencies&gt;    </div><div class="line">   &lt;/dependencyManagement&gt;    </div><div class="line">   &lt;!--参见distributionManagement元素--&gt;    </div><div class="line">   &lt;distributionManagement&gt;    </div><div class="line">    ......    </div><div class="line">   &lt;/distributionManagement&gt;    </div><div class="line">   &lt;!--参见properties元素--&gt;    </div><div class="line">   &lt;properties/&gt;    </div><div class="line">  &lt;/profile&gt;    </div><div class="line"> &lt;/profiles&gt;    </div><div class="line"> &lt;!--模块（有时称作子项目） 被构建成项目的一部分。列出的每个模块元素是指向该模块的目录的相对路径--&gt;    </div><div class="line"> &lt;modules/&gt;    </div><div class="line">    &lt;!--发现依赖和扩展的远程仓库列表。--&gt;     </div><div class="line">    &lt;repositories&gt;     </div><div class="line">     &lt;!--包含需要连接到远程仓库的信息--&gt;    </div><div class="line">        &lt;repository&gt;    </div><div class="line">         &lt;!--如何处理远程仓库里发布版本的下载--&gt;    </div><div class="line">         &lt;releases&gt;    </div><div class="line">          &lt;!--true或者false表示该仓库是否为下载某种类型构件（发布版，快照版）开启。 --&gt;    </div><div class="line">    &lt;enabled/&gt;    </div><div class="line">    &lt;!--该元素指定更新发生的频率。Maven会比较本地POM和远程POM的时间戳。这里的选项是：always（一直），daily（默认，每日），interval：X（这里X是以分钟为单位的时间间隔），或者never（从不）。--&gt;    </div><div class="line">    &lt;updatePolicy/&gt;    </div><div class="line">    &lt;!--当Maven验证构件校验文件失败时该怎么做：ignore（忽略），fail（失败），或者warn（警告）。--&gt;    </div><div class="line">    &lt;checksumPolicy/&gt;    </div><div class="line">   &lt;/releases&gt;    </div><div class="line">   &lt;!-- 如何处理远程仓库里快照版本的下载。有了releases和snapshots这两组配置，POM就可以在每个单独的仓库中，为每种类型的构件采取不同的 策略。例如，可能有人会决定只为开发目的开启对快照版本下载的支持。参见repositories/repository/releases元素 --&gt;    </div><div class="line">   &lt;snapshots&gt;    </div><div class="line">    &lt;enabled/&gt;&lt;updatePolicy/&gt;&lt;checksumPolicy/&gt;    </div><div class="line">   &lt;/snapshots&gt;    </div><div class="line">   &lt;!--远程仓库唯一标识符。可以用来匹配在settings.xml文件里配置的远程仓库--&gt;    </div><div class="line">   &lt;id&gt;banseon-repository-proxy&lt;/id&gt;     </div><div class="line">   &lt;!--远程仓库名称--&gt;    </div><div class="line">            &lt;name&gt;banseon-repository-proxy&lt;/name&gt;     </div><div class="line">            &lt;!--远程仓库URL，按protocol://hostname/path形式--&gt;    </div><div class="line">            &lt;url&gt;http://192.168.1.169:9999/repository/&lt;/url&gt;     </div><div class="line">            &lt;!-- 用于定位和排序构件的仓库布局类型-可以是default（默认）或者legacy（遗留）。Maven 2为其仓库提供了一个默认的布局；然 而，Maven 1.x有一种不同的布局。我们可以使用该元素指定布局是default（默认）还是legacy（遗留）。--&gt;    </div><div class="line">            &lt;layout&gt;default&lt;/layout&gt;               </div><div class="line">        &lt;/repository&gt;     </div><div class="line">    &lt;/repositories&gt;    </div><div class="line">    &lt;!--发现插件的远程仓库列表，这些插件用于构建和报表--&gt;    </div><div class="line">    &lt;pluginRepositories&gt;    </div><div class="line">     &lt;!--包含需要连接到远程插件仓库的信息.参见repositories/repository元素--&gt;    </div><div class="line">  &lt;pluginRepository&gt;    </div><div class="line">   ......    </div><div class="line">  &lt;/pluginRepository&gt;    </div><div class="line"> &lt;/pluginRepositories&gt;    </div><div class="line">       </div><div class="line">    &lt;!--该元素描述了项目相关的所有依赖。 这些依赖组成了项目构建过程中的一个个环节。它们自动从项目定义的仓库中下载。要获取更多信息，请看项目依赖机制。--&gt;     </div><div class="line">    &lt;dependencies&gt;     </div><div class="line">        &lt;dependency&gt;    </div><div class="line">   &lt;!--依赖的group ID--&gt;    </div><div class="line">            &lt;groupId&gt;org.apache.maven&lt;/groupId&gt;     </div><div class="line">            &lt;!--依赖的artifact ID--&gt;    </div><div class="line">            &lt;artifactId&gt;maven-artifact&lt;/artifactId&gt;     </div><div class="line">            &lt;!--依赖的版本号。 在Maven 2里, 也可以配置成版本号的范围。--&gt;    </div><div class="line">            &lt;version&gt;3.8.1&lt;/version&gt;     </div><div class="line">            &lt;!-- 依赖类型，默认类型是jar。它通常表示依赖的文件的扩展名，但也有例外。一个类型可以被映射成另外一个扩展名或分类器。类型经常和使用的打包方式对应， 尽管这也有例外。一些类型的例子：jar，war，ejb-client和test-jar。如果设置extensions为 true，就可以在 plugin里定义新的类型。所以前面的类型的例子不完整。--&gt;    </div><div class="line">            &lt;type&gt;jar&lt;/type&gt;    </div><div class="line">            &lt;!-- 依赖的分类器。分类器可以区分属于同一个POM，但不同构建方式的构件。分类器名被附加到文件名的版本号后面。例如，如果你想要构建两个单独的构件成 JAR，一个使用Java 1.4编译器，另一个使用Java 6编译器，你就可以使用分类器来生成两个单独的JAR构件。--&gt;    </div><div class="line">            &lt;classifier&gt;&lt;/classifier&gt;    </div><div class="line">            &lt;!--依赖范围。在项目发布过程中，帮助决定哪些构件被包括进来。欲知详情请参考依赖机制。    </div><div class="line">                - compile ：默认范围，用于编译      </div><div class="line">                - provided：类似于编译，但支持你期待jdk或者容器提供，类似于classpath      </div><div class="line">                - runtime: 在执行时需要使用      </div><div class="line">                - test:    用于test任务时使用      </div><div class="line">                - system: 需要外在提供相应的元素。通过systemPath来取得      </div><div class="line">                - systemPath: 仅用于范围为system。提供相应的路径      </div><div class="line">                - optional:   当项目自身被依赖时，标注依赖是否传递。用于连续依赖时使用--&gt;     </div><div class="line">            &lt;scope&gt;test&lt;/scope&gt;       </div><div class="line">            &lt;!--仅供system范围使用。注意，不鼓励使用这个元素，并且在新的版本中该元素可能被覆盖掉。该元素为依赖规定了文件系统上的路径。需要绝对路径而不是相对路径。推荐使用属性匹配绝对路径，例如$&#123;java.home&#125;。--&gt;    </div><div class="line">            &lt;systemPath&gt;&lt;/systemPath&gt;     </div><div class="line">            &lt;!--当计算传递依赖时， 从依赖构件列表里，列出被排除的依赖构件集。即告诉maven你只依赖指定的项目，不依赖项目的依赖。此元素主要用于解决版本冲突问题--&gt;    </div><div class="line">            &lt;exclusions&gt;    </div><div class="line">             &lt;exclusion&gt;     </div><div class="line">                    &lt;artifactId&gt;spring-core&lt;/artifactId&gt;     </div><div class="line">                    &lt;groupId&gt;org.springframework&lt;/groupId&gt;     </div><div class="line">                &lt;/exclusion&gt;     </div><div class="line">            &lt;/exclusions&gt;       </div><div class="line">            &lt;!--可选依赖，如果你在项目B中把C依赖声明为可选，你就需要在依赖于B的项目（例如项目A）中显式的引用对C的依赖。可选依赖阻断依赖的传递性。--&gt;     </div><div class="line">            &lt;optional&gt;true&lt;/optional&gt;    </div><div class="line">        &lt;/dependency&gt;    </div><div class="line">    &lt;/dependencies&gt;    </div><div class="line">    &lt;!--不赞成使用. 现在Maven忽略该元素.--&gt;    </div><div class="line">    &lt;reports&gt;&lt;/reports&gt;    </div><div class="line">    &lt;!--该元素描述使用报表插件产生报表的规范。当用户执行“mvn site”，这些报表就会运行。 在页面导航栏能看到所有报表的链接。--&gt;    </div><div class="line"> &lt;reporting&gt;    </div><div class="line">  &lt;!--true，则，网站不包括默认的报表。这包括“项目信息”菜单中的报表。--&gt;    </div><div class="line">  &lt;excludeDefaults/&gt;    </div><div class="line">  &lt;!--所有产生的报表存放到哪里。默认值是$&#123;project.build.directory&#125;/site。--&gt;    </div><div class="line">  &lt;outputDirectory/&gt;    </div><div class="line">  &lt;!--使用的报表插件和他们的配置。--&gt;    </div><div class="line">  &lt;plugins&gt;    </div><div class="line">   &lt;!--plugin元素包含描述报表插件需要的信息--&gt;    </div><div class="line">   &lt;plugin&gt;    </div><div class="line">    &lt;!--报表插件在仓库里的group ID--&gt;    </div><div class="line">    &lt;groupId/&gt;    </div><div class="line">    &lt;!--报表插件在仓库里的artifact ID--&gt;    </div><div class="line">    &lt;artifactId/&gt;    </div><div class="line">    &lt;!--被使用的报表插件的版本（或版本范围）--&gt;    </div><div class="line">    &lt;version/&gt;    </div><div class="line">    &lt;!--任何配置是否被传播到子项目--&gt;    </div><div class="line">    &lt;inherited/&gt;    </div><div class="line">    &lt;!--报表插件的配置--&gt;    </div><div class="line">    &lt;configuration/&gt;    </div><div class="line">    &lt;!--一组报表的多重规范，每个规范可能有不同的配置。一个规范（报表集）对应一个执行目标 。例如，有1，2，3，4，5，6，7，8，9个报表。1，2，5构成A报表集，对应一个执行目标。2，5，8构成B报表集，对应另一个执行目标--&gt;    </div><div class="line">    &lt;reportSets&gt;    </div><div class="line">     &lt;!--表示报表的一个集合，以及产生该集合的配置--&gt;    </div><div class="line">     &lt;reportSet&gt;    </div><div class="line">      &lt;!--报表集合的唯一标识符，POM继承时用到--&gt;    </div><div class="line">      &lt;id/&gt;    </div><div class="line">      &lt;!--产生报表集合时，被使用的报表的配置--&gt;    </div><div class="line">      &lt;configuration/&gt;    </div><div class="line">      &lt;!--配置是否被继承到子POMs--&gt;    </div><div class="line">      &lt;inherited/&gt;    </div><div class="line">      &lt;!--这个集合里使用到哪些报表--&gt;    </div><div class="line">      &lt;reports/&gt;    </div><div class="line">     &lt;/reportSet&gt;    </div><div class="line">    &lt;/reportSets&gt;    </div><div class="line">   &lt;/plugin&gt;    </div><div class="line">  &lt;/plugins&gt;    </div><div class="line"> &lt;/reporting&gt;    </div><div class="line"> &lt;!-- 继承自该项目的所有子项目的默认依赖信息。这部分的依赖信息不会被立即解析,而是当子项目声明一个依赖（必须描述group ID和 artifact ID信息），如果group ID和artifact ID以外的一些信息没有描述，则通过group ID和artifact ID 匹配到这里的依赖，并使用这里的依赖信息。--&gt;    </div><div class="line"> &lt;dependencyManagement&gt;    </div><div class="line">  &lt;dependencies&gt;    </div><div class="line">   &lt;!--参见dependencies/dependency元素--&gt;    </div><div class="line">   &lt;dependency&gt;    </div><div class="line">    ......    </div><div class="line">   &lt;/dependency&gt;    </div><div class="line">  &lt;/dependencies&gt;    </div><div class="line"> &lt;/dependencyManagement&gt;       </div><div class="line">    &lt;!--项目分发信息，在执行mvn deploy后表示要发布的位置。有了这些信息就可以把网站部署到远程服务器或者把构件部署到远程仓库。--&gt;     </div><div class="line">    &lt;distributionManagement&gt;    </div><div class="line">        &lt;!--部署项目产生的构件到远程仓库需要的信息--&gt;    </div><div class="line">        &lt;repository&gt;    </div><div class="line">         &lt;!--是分配给快照一个唯一的版本号（由时间戳和构建流水号）？还是每次都使用相同的版本号？参见repositories/repository元素--&gt;    </div><div class="line">   &lt;uniqueVersion/&gt;    </div><div class="line">   &lt;id&gt;banseon-maven2&lt;/id&gt;     </div><div class="line">   &lt;name&gt;banseon maven2&lt;/name&gt;     </div><div class="line">            &lt;url&gt;file://$&#123;basedir&#125;/target/deploy&lt;/url&gt;     </div><div class="line">            &lt;layout/&gt;    </div><div class="line">  &lt;/repository&gt;    </div><div class="line">  &lt;!--构件的快照部署到哪里？如果没有配置该元素，默认部署到repository元素配置的仓库，参见distributionManagement/repository元素--&gt;     </div><div class="line">  &lt;snapshotRepository&gt;    </div><div class="line">   &lt;uniqueVersion/&gt;    </div><div class="line">   &lt;id&gt;banseon-maven2&lt;/id&gt;    </div><div class="line">            &lt;name&gt;Banseon-maven2 Snapshot Repository&lt;/name&gt;    </div><div class="line">            &lt;url&gt;scp://svn.baidu.com/banseon:/usr/local/maven-snapshot&lt;/url&gt;     </div><div class="line">   &lt;layout/&gt;    </div><div class="line">  &lt;/snapshotRepository&gt;    </div><div class="line">  &lt;!--部署项目的网站需要的信息--&gt;     </div><div class="line">        &lt;site&gt;    </div><div class="line">         &lt;!--部署位置的唯一标识符，用来匹配站点和settings.xml文件里的配置--&gt;     </div><div class="line">            &lt;id&gt;banseon-site&lt;/id&gt;     </div><div class="line">            &lt;!--部署位置的名称--&gt;    </div><div class="line">            &lt;name&gt;business api website&lt;/name&gt;     </div><div class="line">            &lt;!--部署位置的URL，按protocol://hostname/path形式--&gt;    </div><div class="line">            &lt;url&gt;     </div><div class="line">                scp://svn.baidu.com/banseon:/var/www/localhost/banseon-web      </div><div class="line">            &lt;/url&gt;     </div><div class="line">        &lt;/site&gt;    </div><div class="line">  &lt;!--项目下载页面的URL。如果没有该元素，用户应该参考主页。使用该元素的原因是：帮助定位那些不在仓库里的构件（由于license限制）。--&gt;    </div><div class="line">  &lt;downloadUrl/&gt;    </div><div class="line">  &lt;!--如果构件有了新的group ID和artifact ID（构件移到了新的位置），这里列出构件的重定位信息。--&gt;    </div><div class="line">  &lt;relocation&gt;    </div><div class="line">   &lt;!--构件新的group ID--&gt;    </div><div class="line">   &lt;groupId/&gt;    </div><div class="line">   &lt;!--构件新的artifact ID--&gt;    </div><div class="line">   &lt;artifactId/&gt;    </div><div class="line">   &lt;!--构件新的版本号--&gt;    </div><div class="line">   &lt;version/&gt;    </div><div class="line">   &lt;!--显示给用户的，关于移动的额外信息，例如原因。--&gt;    </div><div class="line">   &lt;message/&gt;    </div><div class="line">  &lt;/relocation&gt;    </div><div class="line">  &lt;!-- 给出该构件在远程仓库的状态。不得在本地项目中设置该元素，因为这是工具自动更新的。有效的值有：none（默认），converted（仓库管理员从 Maven 1 POM转换过来），partner（直接从伙伴Maven 2仓库同步过来），deployed（从Maven 2实例部 署），verified（被核实时正确的和最终的）。--&gt;    </div><div class="line">  &lt;status/&gt;           </div><div class="line">    &lt;/distributionManagement&gt;    </div><div class="line">    &lt;!--以值替代名称，Properties可以在整个POM中使用，也可以作为触发条件（见settings.xml配置文件里activation元素的说明）。格式是&lt;name&gt;value&lt;/name&gt;。--&gt;    </div><div class="line">    &lt;properties/&gt;    </div><div class="line">&lt;/project&gt;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt; pom作为项目对象模型。通过xml表示maven项目，使用pom.xml来实现。主要描述了项目：包括配置文件；开发者需要遵循的规则，缺陷管理系统，组织和licenses，项目的url，项目的依赖性，以及其他所有的项目相关因素。&lt;br&gt;
    
    </summary>
    
      <category term="Maven" scheme="http://yoursite.com/categories/Maven/"/>
    
    
      <category term="Maven" scheme="http://yoursite.com/tags/Maven/"/>
    
  </entry>
  
  <entry>
    <title>Jar包添加到maven本地仓库</title>
    <link href="http://yoursite.com/2017/03/07/Jar%E5%8C%85%E6%B7%BB%E5%8A%A0%E5%88%B0maven%E6%9C%AC%E5%9C%B0%E4%BB%93%E5%BA%93/"/>
    <id>http://yoursite.com/2017/03/07/Jar包添加到maven本地仓库/</id>
    <published>2017-03-07T13:02:25.000Z</published>
    <updated>2017-09-28T08:10:04.299Z</updated>
    
    <content type="html"><![CDATA[<p> maven在应用的过程中，有 maven在应用的过程中，有些jar包在仓库上面是没法找到的，这需要我们自己手动导入到仓库中，些jar包在仓库上面是没法找到的，这需要我们自己手动导入到仓库中。</p><a id="more"></a><h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><p>zxing-3.21.jar是根据github上面项目<a href="https://github.com/zxing" target="_blank" rel="external">ZXing Project</a>自己生成的jar包，该包主要应用于二维码生成，下面讲述怎么把怎么把zxing-3.21.jar添加到本地的maven仓库中。</p><h3 id="环境要求"><a href="#环境要求" class="headerlink" title="环境要求"></a>环境要求</h3><p>需要配置JDK和maven环境，完成后以管理员身份打开命令提示符窗口(cmd),再输入下面相关的语法。</p><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">mvn install:install-file -Dfile=jar包的位置(参数一) -DgroupId=groupId(参数二) -DartifactId=artifactId(参数三) -Dversion=version(参数四) -Dpackaging=jar</div><div class="line"></div><div class="line">eg:</div><div class="line">mvn install:install-file -Dfile=&quot;C:\Users\eric\Desktop\zxing\3.21\zxing-3.21.jar&quot; -DgroupId=com.eric -DartifactId=zxing -Dversion=3.21 -Dpackaging=jar</div><div class="line"></div><div class="line">result：</div><div class="line">[INFO] Scanning for projects...</div><div class="line">[INFO]</div><div class="line">[INFO] ------------------------------------------------------------------------</div><div class="line">[INFO] Building Maven Stub Project (No POM) 1</div><div class="line">[INFO] ------------------------------------------------------------------------</div><div class="line">[INFO]</div><div class="line">[INFO] --- maven-install-plugin:2.4:install-file (default-cli) @ standalone-pom ---</div><div class="line">[INFO] Installing C:\Users\eric\Desktop\zxing\3.21\zxing-3.21.jar to C:\Users\eric\.m2\repository\com\eric\zxing\3.21\zxing-3.21.jar</div><div class="line">[INFO] Installing C:\Users\eric\AppData\Local\Temp\mvninstall6543969167446403883.pom to C:\Users\eric\.m2\repository\com\eric\zxing\3.21\zxing-3.21.pom</div><div class="line">[INFO] ------------------------------------------------------------------------</div><div class="line">[INFO] BUILD SUCCESS</div><div class="line">[INFO] ------------------------------------------------------------------------</div><div class="line">[INFO] Total time: 0.836 s</div><div class="line">[INFO] Finished at: 2017-03-08T00:24:12+08:00</div><div class="line">[INFO] Final Memory: 7M/117M</div><div class="line">[INFO] ------------------------------------------------------------------------</div><div class="line">(添加成功！)</div></pre></td></tr></table></figure><p><strong>注意：地址+jar包名,即C:\Users\eric\Desktop\zxing\3.21\zxing-3.21.jar要加引号””,”参数二\参数三\参数四”这也是jar包在仓库中的地址。</strong></p><h3 id="查看生成的依赖"><a href="#查看生成的依赖" class="headerlink" title="查看生成的依赖"></a>查看生成的依赖</h3><p>查看添加的zxing-3.21.jar的dependency</p><ul><li>通过设置的对应参数获取.即</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">-DgroupId=groupId(参数二) -DartifactId=artifactId(参数三) -Dversion=version(参数四)</div></pre></td></tr></table></figure><ul><li>参看本地仓库中pom文件C:\Users\eric.m2\repository\com\eric\zxing\3.21\zxing-3.21.pom，可以看到:</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;groupId&gt;com.eric&lt;/groupId&gt;</div><div class="line">&lt;artifactId&gt;zxing&lt;/artifactId&gt;</div><div class="line">&lt;version&gt;3.21&lt;/version&gt;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt; maven在应用的过程中，有 maven在应用的过程中，有些jar包在仓库上面是没法找到的，这需要我们自己手动导入到仓库中，些jar包在仓库上面是没法找到的，这需要我们自己手动导入到仓库中。&lt;/p&gt;
    
    </summary>
    
      <category term="Maven" scheme="http://yoursite.com/categories/Maven/"/>
    
    
      <category term="Maven" scheme="http://yoursite.com/tags/Maven/"/>
    
  </entry>
  
  <entry>
    <title>Redis数据类型--String（字符串）</title>
    <link href="http://yoursite.com/2017/03/06/Redis%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B--String%EF%BC%88%E5%AD%97%E7%AC%A6%E4%B8%B2%EF%BC%89/"/>
    <id>http://yoursite.com/2017/03/06/Redis数据类型--String（字符串）/</id>
    <published>2017-03-06T13:02:25.000Z</published>
    <updated>2017-09-28T09:36:40.330Z</updated>
    
    <content type="html"><![CDATA[<p>Redis的字符串和其他编程语言或者其他键值存储提供的字符串非常相似。一个key对应一个value。<br>string类型是二进制安全的，可以包含任何数据，比如jpg图片或者序列化的对象。从内部实现来看其实string可以看作byte数组，最大上限1G字节。<br>另外string类型可以被部分命令按int处理，比如incr等命令。<br>文档目前描述的内容以 Redis 2.8 版本为准。<br><a id="more"></a></p><h3 id="SET"><a href="#SET" class="headerlink" title="SET"></a><strong>SET</strong></h3><p><strong>SET key value [EX seconds] [PX milliseconds] [NX|XX]</strong><br> 将字符串值 value 关联到 key 。<br> 如果 key 已经持有其他值， SET 就覆写旧值，无视类型。<br> 对于某个原本带有生存时间（TTL）的键来说， 当 SET 命令成功在这个键上执行时， 这个键原有的 TTL 将被清除。</p><h4 id="可选参数"><a href="#可选参数" class="headerlink" title="可选参数"></a>可选参数</h4><p> <strong>EX second ：</strong>设置键的过期时间为 second 秒。 SET key value EX second 效果等同于 SETEX key second value 。<br> <strong>PX millisecond ：</strong>设置键的过期时间为 millisecond 毫秒。 SET key value PX millisecond 效果等同于 PSETEX key millisecond value 。<br> <strong>NX ：</strong>只在键不存在时，才对键进行设置操作。 SET key value NX 效果等同于 SETNX key value 。<br> <strong>XX ：</strong>只在键已经存在时，才对键进行设置操作。</p><h4 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h4><p> SET 在设置操作成功完成时，才返回 OK 。如果设置了 NX 或者 XX ，但因为条件没达到而造成设置操作未执行，那么命令返回空批量回复（NULL Bulk Reply）。</p><h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">127.0.0.1:6379&gt; SET key &quot;value&quot;</div><div class="line">OK</div><div class="line">127.0.0.1:6379&gt; SET key &quot;value1&quot; EX 10086 XX</div><div class="line">OK</div><div class="line">127.0.0.1:6379&gt; SET key &quot;value1&quot; PX 10086 NX</div><div class="line">(nil)</div></pre></td></tr></table></figure><h3 id="SETBIT"><a href="#SETBIT" class="headerlink" title="SETBIT"></a><strong>SETBIT</strong></h3><p><strong>SETBIT key offset value</strong><br> 对 key 所储存的字符串值，设置或清除指定偏移量上的位(bit)。<br> 位的设置或清除取决于 value 参数，可以是 0 也可以是 1 。<br> 当 key 不存在时，自动生成一个新的字符串值。<br> 字符串会进行伸展(grown)以确保它可以将 value 保存在指定的偏移量上。当字符串值进行伸展时，空白位置以 0 填充。<br> offset 参数必须大于或等于 0 ，小于 2^32 (bit 映射被限制在 512 MB 之内)。</p><h4 id="返回值-1"><a href="#返回值-1" class="headerlink" title="返回值"></a>返回值</h4><p>指定偏移量原来储存的位。</p><h4 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">127.0.0.1:6379&gt; SETBIT bit 50 1</div><div class="line">(integer) 0</div><div class="line">127.0.0.1:6379&gt; GETBIT bit 50</div><div class="line">(integer) 1</div><div class="line">127.0.0.1:6379&gt; GETBIT bit 40</div><div class="line">(integer) 0</div></pre></td></tr></table></figure><h3 id="SETEX"><a href="#SETEX" class="headerlink" title="SETEX"></a><strong>SETEX</strong></h3><p><strong>SETEX key seconds value</strong><br> 将值 value 关联到 key ，并将 key 的生存时间设为 seconds (以秒为单位)。<br> 如果 key 已经存在， SETEX 命令将覆写旧值。</p><h4 id="返回值-2"><a href="#返回值-2" class="headerlink" title="返回值"></a>返回值</h4><p>设置成功时返回 OK 。当 seconds 参数不合法时，返回一个错误。</p><h4 id="示例-2"><a href="#示例-2" class="headerlink" title="示例"></a>示例</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">127.0.0.1:6379&gt; SETEX key 50 &quot;value&quot;</div><div class="line">OK</div><div class="line">127.0.0.1:6379&gt; GET key</div><div class="line">&quot;value&quot;</div><div class="line">127.0.0.1:6379&gt; TTL key</div><div class="line">(integer) 29</div></pre></td></tr></table></figure><h3 id="SETNX"><a href="#SETNX" class="headerlink" title="SETNX"></a><strong>SETNX</strong></h3><p><strong>SETNX key value</strong><br> 将 key 的值设为 value ，当且仅当 key 不存在。<br> 若给定的 key 已经存在，则 SETNX 不做任何动作。<br> SETNX 是『SET if Not eXists』(如果不存在，则 SET)的简写。</p><h4 id="返回值-3"><a href="#返回值-3" class="headerlink" title="返回值"></a>返回值</h4><p>设置成功，返回 1 。设置失败，返回 0 。</p><h4 id="示例-3"><a href="#示例-3" class="headerlink" title="示例"></a>示例</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">127.0.0.1:6379&gt; SETNX key &quot;value&quot;</div><div class="line">(integer) 1</div><div class="line">127.0.0.1:6379&gt; SETNX key &quot;value1&quot;</div><div class="line">(integer) 0</div></pre></td></tr></table></figure><h3 id="SETRANGE"><a href="#SETRANGE" class="headerlink" title="SETRANGE"></a><strong>SETRANGE</strong></h3><p><strong>SETRANGE key offset value</strong><br> 用 value 参数覆写(overwrite)给定 key 所储存的字符串值，从偏移量 offset 开始。<br> 不存在的 key 当作空白字符串处理。<br> SETRANGE 命令会确保字符串足够长以便将 value 设置在指定的偏移量上，如果给定 key 原来储存的字符串长度比偏移量小(比如字符串只有 5 个字符长，但你设置的 offset 是 10 )，那么原字符和偏移量之间的空白将用零字节(zerobytes, “\x00” )来填充。<br> 注意你能使用的最大偏移量是 2^29-1(536870911) ，因为 Redis 字符串的大小被限制在 512 兆(megabytes)以内。如果你需要使用比这更大的空间，你可以使用多个 key 。</p><p><strong>注意：</strong>当生成一个很长的字符串时，Redis 需要分配内存空间，该操作有时候可能会造成服务器阻塞(block)。在2010年的Macbook Pro上，设置偏移量为 536870911(512MB 内存分配)，耗费约 300 毫秒， 设置偏移量为 134217728(128MB 内存分配)，耗费约 80 毫秒，设置偏移量 33554432(32MB 内存分配)，耗费约 30 毫秒，设置偏移量为 8388608(8MB 内存分配)，耗费约 8 毫秒。 注意若首次内存分配成功之后，再对同一个 key 调用 SETRANGE 操作，无须再重新内存。</p><h4 id="返回值-4"><a href="#返回值-4" class="headerlink" title="返回值"></a>返回值</h4><p>被 SETRANGE 修改之后，字符串的长度。</p><h4 id="示例-4"><a href="#示例-4" class="headerlink" title="示例"></a>示例</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">127.0.0.1:6379&gt; EXISTS empty_key</div><div class="line">(integer) 0</div><div class="line">127.0.0.1:6379&gt; SETRANGE empty_key 5 &quot;Redis!&quot;</div><div class="line">(integer) 11</div><div class="line">127.0.0.1:6379&gt; GET empty_key</div><div class="line">&quot;\x00\x00\x00\x00\x00Redis!&quot;</div><div class="line">127.0.0.1:6379&gt;</div></pre></td></tr></table></figure><h3 id="GET"><a href="#GET" class="headerlink" title="GET"></a><strong>GET</strong></h3><p><strong>GET key</strong><br> 返回 key 所关联的字符串值。<br> 如果 key 不存在那么返回特殊值 nil 。<br> 假如 key 储存的值不是字符串类型，返回一个错误，因为 GET 只能用于处理字符串值。</p><h4 id="返回值-5"><a href="#返回值-5" class="headerlink" title="返回值"></a>返回值</h4><p>当 key 不存在时，返回 nil ，否则，返回 key 的值。如果 key 不是字符串类型，那么返回一个错误。</p><h4 id="示例-5"><a href="#示例-5" class="headerlink" title="示例"></a>示例</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">127.0.0.1:6379&gt; SET key &quot;value&quot;</div><div class="line">OK</div><div class="line">127.0.0.1:6379&gt; GET key</div><div class="line">&quot;value&quot;</div></pre></td></tr></table></figure><h3 id="GETBIT"><a href="#GETBIT" class="headerlink" title="GETBIT"></a><strong>GETBIT</strong></h3><p><strong>GETBIT key offset</strong><br> 对 key 所储存的字符串值，获取指定偏移量上的位(bit)。<br> 当 offset 比字符串值的长度大，或者 key 不存在时，返回 0 。</p><h4 id="返回值-6"><a href="#返回值-6" class="headerlink" title="返回值"></a>返回值</h4><p>字符串值指定偏移量上的位(bit)。对不存在的 key 或者不存在的 offset 进行 GETBIT， 返回 0。</p><h4 id="示例-6"><a href="#示例-6" class="headerlink" title="示例"></a>示例</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">127.0.0.1:6379&gt; EXISTS bits</div><div class="line">(integer) 0</div><div class="line">127.0.0.1:6379&gt; GETBIT bits 100</div><div class="line">(integer) 0</div><div class="line">127.0.0.1:6379&gt; SETBIT bits 101 1</div><div class="line">(integer) 0</div><div class="line">127.0.0.1:6379&gt; GETBIT bits 101</div><div class="line">(integer) 1</div></pre></td></tr></table></figure><h3 id="GETRANGE"><a href="#GETRANGE" class="headerlink" title="GETRANGE"></a><strong>GETRANGE</strong></h3><p><strong>GETRANGE key start end</strong><br> 返回 key 中字符串值的子字符串，字符串的截取范围由 start 和 end 两个偏移量决定(包括 start 和 end 在内)。<br> 负数偏移量表示从字符串最后开始计数， -1 表示最后一个字符， -2 表示倒数第二个，以此类推。<br> GETRANGE 通过保证子字符串的值域(range)不超过实际字符串的值域来处理超出范围的值域请求。</p><h4 id="返回值-7"><a href="#返回值-7" class="headerlink" title="返回值"></a>返回值</h4><p>截取得出的子字符串。</p><h4 id="示例-7"><a href="#示例-7" class="headerlink" title="示例"></a>示例</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">127.0.0.1:6379&gt; SET greeting &quot;hello, my friend&quot;</div><div class="line">OK</div><div class="line">127.0.0.1:6379&gt; GETRANGE greeting 0 4          # 返回索引0-4的字符，包括4。</div><div class="line">&quot;hello&quot;</div><div class="line">127.0.0.1:6379&gt; GETRANGE greeting -1 -5        # 不支持回绕操作</div><div class="line">&quot;&quot;</div><div class="line">127.0.0.1:6379&gt; GETRANGE greeting -3 -1        # 负数索引</div><div class="line">&quot;end&quot;</div><div class="line">127.0.0.1:6379&gt; GETRANGE greeting 0 -1         # 从第一个到最后一个</div><div class="line">&quot;hello, my friend&quot;</div><div class="line">127.0.0.1:6379&gt; GETRANGE greeting 0 1008611    # 值域超出部分被符略</div><div class="line">&quot;hello, my friend&quot;</div></pre></td></tr></table></figure><h3 id="GETSET"><a href="#GETSET" class="headerlink" title="GETSET"></a><strong>GETSET</strong></h3><p><strong>GETSET key value</strong><br> 将给定 key 的值设为 value ，并返回 key 的旧值(old value)。<br> 当 key 存在但不是字符串类型时，返回一个错误。</p><h4 id="可用版本"><a href="#可用版本" class="headerlink" title="可用版本"></a>可用版本</h4><p>   版本&gt;= 1.0.0</p><h4 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><p>O(1)</p><h4 id="返回值-8"><a href="#返回值-8" class="headerlink" title="返回值"></a>返回值</h4><p> 返回给定 key 的旧值。<br> 当 key 没有旧值时，也即是， key 不存在时，返回 nil 。</p><h4 id="示例-8"><a href="#示例-8" class="headerlink" title="示例"></a>示例</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">redis&gt; GETSET db mongodb    # 没有旧值，返回 nil</div><div class="line">(nil)</div><div class="line">redis&gt; GET db</div><div class="line">&quot;mongodb&quot;</div><div class="line">redis&gt; GETSET db redis      # 返回旧值 mongodb</div><div class="line">&quot;mongodb&quot;</div><div class="line">redis&gt; GET db</div><div class="line">&quot;redis&quot;</div></pre></td></tr></table></figure><h3 id="APPEND"><a href="#APPEND" class="headerlink" title="APPEND"></a><strong>APPEND</strong></h3><p><strong>APPEND key value</strong><br> 如果 key 已经存在并且是一个字符串， APPEND 命令将 value 追加到 key 原来的值的末尾。<br> 如果 key 不存在， APPEND 就简单地将给定 key 设为 value ，就像执行 SET key value 一样。</p><h4 id="可用版本-1"><a href="#可用版本-1" class="headerlink" title="可用版本"></a>可用版本</h4><blockquote><p>= 2.0.0</p><h4 id="时间复杂度-1"><a href="#时间复杂度-1" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><p>平摊O(1)</p><h4 id="返回值-9"><a href="#返回值-9" class="headerlink" title="返回值"></a>返回值</h4><p>追加 value 之后， key 中字符串的长度。</p></blockquote><h4 id="示例-9"><a href="#示例-9" class="headerlink" title="示例"></a>示例</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"># 对不存在的 key 执行 APPEND</div><div class="line">redis&gt; EXISTS myphone               # 确保 myphone 不存在</div><div class="line">(integer) 0</div><div class="line">redis&gt; APPEND myphone &quot;nokia&quot;       # 对不存在的 key 进行 APPEND  ，等同于 SET myphone &quot;nokia&quot;</div><div class="line">(integer) 5                         # 字符长度</div><div class="line"># 对已存在的字符串进行 APPEND</div><div class="line">redis&gt; APPEND myphone &quot; - 1110&quot;     # 长度从 5 个字符增加到 12 个字符</div><div class="line">(integer) 12</div><div class="line">redis&gt; GET myphone</div><div class="line">&quot;nokia - 1110&quot;</div></pre></td></tr></table></figure><h3 id="BITCOUNT"><a href="#BITCOUNT" class="headerlink" title="BITCOUNT"></a><strong>BITCOUNT</strong></h3><p><strong>BITCOUNT key [start] [end]</strong><br> 计算给定字符串中，被设置为 1 的比特位的数量。<br> 一般情况下，给定的整个字符串都会被进行计数，通过指定额外的 start 或 end 参数，可以让计数只在特定的位上进行。<br> start 和 end 参数的设置和 GETRANGE 命令类似，都可以使用负数值：比如 -1 表示最后一个位，而 -2 表示倒数第二个位，以此类推。<br> 不存在的 key 被当成是空字符串来处理，因此对一个不存在的 key 进行 BITCOUNT 操作，结果为 0 。</p><h4 id="可用版本-2"><a href="#可用版本-2" class="headerlink" title="可用版本"></a>可用版本</h4><p>版本&gt;= 2.6.0</p><h4 id="时间复杂度-2"><a href="#时间复杂度-2" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><p>O(N)</p><h4 id="返回值-10"><a href="#返回值-10" class="headerlink" title="返回值"></a>返回值</h4><p>被设置为 1 的位的数量。</p><h4 id="示例-10"><a href="#示例-10" class="headerlink" title="示例"></a>示例</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">redis&gt; BITCOUNT bits</div><div class="line">(integer) 0</div><div class="line">redis&gt; SETBIT bits 0 1          # 0001</div><div class="line">(integer) 0</div><div class="line">redis&gt; BITCOUNT bits</div><div class="line">(integer) 1</div><div class="line">redis&gt; SETBIT bits 3 1          # 1001</div><div class="line">(integer) 0</div><div class="line">redis&gt; BITCOUNT bits</div><div class="line">(integer) 2</div></pre></td></tr></table></figure><h3 id="BITOP"><a href="#BITOP" class="headerlink" title="BITOP"></a><strong>BITOP</strong></h3><p><strong>BITOP operation destkey key [key …]</strong><br> 对一个或多个保存二进制位的字符串 key 进行位元操作，并将结果保存到 destkey 上。<br> operation 可以是 AND 、 OR 、 NOT 、 XOR 这四种操作中的任意一种：</p><ul><li>BITOP AND destkey key [key …] ，对一个或多个 key 求逻辑并，并将结果保存到 destkey 。</li><li>BITOP OR destkey key [key …] ，对一个或多个 key 求逻辑或，并将结果保存到 destkey 。</li><li>BITOP XOR destkey key [key …] ，对一个或多个 key 求逻辑异或，并将结果保存到 destkey 。</li><li>BITOP NOT destkey key ，对给定 key 求逻辑非，并将结果保存到 destkey 。</li></ul><p> 除了 NOT 操作之外，其他操作都可以接受一个或多个 key 作为输入。</p><h4 id="处理不同长度的字符串"><a href="#处理不同长度的字符串" class="headerlink" title="处理不同长度的字符串"></a>处理不同长度的字符串</h4><p>当 BITOP 处理不同长度的字符串时，较短的那个字符串所缺少的部分会被看作 0 。空的 key 也被看作是包含 0 的字符串序列。</p><h4 id="可用版本-3"><a href="#可用版本-3" class="headerlink" title="可用版本"></a>可用版本</h4><p>版本&gt;= 2.6.0</p><h4 id="时间复杂度-3"><a href="#时间复杂度-3" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><p>O(N)</p><h4 id="返回值-11"><a href="#返回值-11" class="headerlink" title="返回值"></a>返回值</h4><p>保存到 destkey 的字符串的长度，和输入 key 中最长的字符串长度相等。</p><p><strong>注意：</strong> BITOP 的复杂度为 O(N) ，当处理大型矩阵(matrix)或者进行大数据量的统计时，最好将任务指派到附属节点(slave)进行，避免阻塞主节点。</p><h4 id="示例-11"><a href="#示例-11" class="headerlink" title="示例"></a>示例</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">redis&gt; SETBIT bits-1 0 1        # bits-1 = 1001</div><div class="line">(integer) 0</div><div class="line">redis&gt; SETBIT bits-1 3 1</div><div class="line">(integer) 0</div><div class="line">redis&gt; SETBIT bits-2 0 1        # bits-2 = 1011</div><div class="line">(integer) 0</div><div class="line">redis&gt; SETBIT bits-2 1 1</div><div class="line">(integer) 0</div><div class="line">redis&gt; SETBIT bits-2 3 1</div><div class="line">(integer) 0</div><div class="line">redis&gt; BITOP AND and-result bits-1 bits-2</div><div class="line">(integer) 1</div><div class="line">redis&gt; GETBIT and-result 0      # and-result = 1001</div><div class="line">(integer) 1</div><div class="line">redis&gt; GETBIT and-result 1</div><div class="line">(integer) 0</div><div class="line">redis&gt; GETBIT and-result 2</div><div class="line">(integer) 0</div><div class="line">redis&gt; GETBIT and-result 3</div><div class="line">(integer) 1</div></pre></td></tr></table></figure><h3 id="DECR"><a href="#DECR" class="headerlink" title="DECR"></a><strong>DECR</strong></h3><p><strong>DECR key</strong><br> 将 key 中储存的数字值减一。<br> 如果 key 不存在，那么 key 的值会先被初始化为 0 ，然后再执行 DECR 操作。<br> 如果值包含错误的类型，或字符串类型的值不能表示为数字，那么返回一个错误。<br> 本操作的值限制在 64 位(bit)有符号数字表示之内。</p><h4 id="可用版本-4"><a href="#可用版本-4" class="headerlink" title="可用版本"></a>可用版本</h4><p>版本&gt;= 1.0.0</p><h4 id="时间复杂度-4"><a href="#时间复杂度-4" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><p>O(1)</p><h4 id="返回值-12"><a href="#返回值-12" class="headerlink" title="返回值"></a>返回值</h4><p>执行 DECR 命令之后 key 的值。</p><h4 id="示例-12"><a href="#示例-12" class="headerlink" title="示例"></a>示例</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"># 对存在的数字值 key 进行 DECR</div><div class="line">redis&gt; SET failure_times 10</div><div class="line">OK</div><div class="line">redis&gt; DECR failure_times</div><div class="line">(integer) 9</div><div class="line"># 对不存在的 key 值进行 DECR</div><div class="line">redis&gt; EXISTS count</div><div class="line">(integer) 0</div><div class="line">redis&gt; DECR count</div><div class="line">(integer) -1</div><div class="line"># 对存在但不是数值的 key 进行 DECR</div><div class="line">redis&gt; SET company YOUR_CODE_SUCKS.LLC</div><div class="line">OK</div><div class="line">redis&gt; DECR company</div><div class="line">(error) ERR value is not an integer or out of range</div></pre></td></tr></table></figure><h3 id="DECRBY"><a href="#DECRBY" class="headerlink" title="DECRBY"></a><strong>DECRBY</strong></h3><p><strong>DECRBY key decrement</strong><br> 将 key 所储存的值减去减量 decrement 。<br> 如果 key 不存在，那么 key 的值会先被初始化为 0 ，然后再执行 DECRBY 操作。<br> 如果值包含错误的类型，或字符串类型的值不能表示为数字，那么返回一个错误。<br> 本操作的值限制在 64 位(bit)有符号数字表示之内。</p><h4 id="可用版本-5"><a href="#可用版本-5" class="headerlink" title="可用版本"></a>可用版本</h4><p>版本&gt;= 1.0.0</p><h4 id="时间复杂度-5"><a href="#时间复杂度-5" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><p>O(1)</p><h4 id="返回值-13"><a href="#返回值-13" class="headerlink" title="返回值"></a>返回值</h4><p>减去 decrement 之后， key 的值。</p><h3 id="示例-13"><a href="#示例-13" class="headerlink" title="示例"></a>示例</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"># 对已存在的 key 进行 DECRBY</div><div class="line">redis&gt; SET count 100</div><div class="line">OK</div><div class="line">redis&gt; DECRBY count 20</div><div class="line">(integer) 80</div><div class="line"># 对不存在的 key 进行DECRBY</div><div class="line">redis&gt; EXISTS pages</div><div class="line">(integer) 0</div><div class="line">redis&gt; DECRBY pages 10</div><div class="line">(integer) -10</div></pre></td></tr></table></figure><h3 id="INCR"><a href="#INCR" class="headerlink" title="INCR"></a><strong>INCR</strong></h3><p><strong>INCR key</strong><br> 将 key 中储存的数字值增一。<br> 如果 key 不存在，那么 key 的值会先被初始化为 0 ，然后再执行 INCR 操作。<br> 如果值包含错误的类型，或字符串类型的值不能表示为数字，那么返回一个错误。<br> 本操作的值限制在 64 位(bit)有符号数字表示之内。</p><p><strong>注意：</strong>这是一个针对字符串的操作，因为 Redis 没有专用的整数类型，所以 key 内储存的字符串被解释为十进制 64 位有符号整数来执行 INCR 操作。</p><h4 id="可用版本-6"><a href="#可用版本-6" class="headerlink" title="可用版本"></a>可用版本</h4><p>版本&gt;= 1.0.0</p><h4 id="时间复杂度-6"><a href="#时间复杂度-6" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><p>O(1)</p><h4 id="返回值-14"><a href="#返回值-14" class="headerlink" title="返回值"></a>返回值</h4><p>执行 INCR 命令之后 key 的值。</p><h4 id="示例-14"><a href="#示例-14" class="headerlink" title="示例"></a>示例</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">redis&gt; SET page_view 20</div><div class="line">OK</div><div class="line">redis&gt; INCR page_view</div><div class="line">(integer) 21</div><div class="line">redis&gt; GET page_view    # 数字值在 Redis 中以字符串的形式保存</div><div class="line">&quot;21&quot;</div></pre></td></tr></table></figure><h3 id="INCRBY"><a href="#INCRBY" class="headerlink" title="INCRBY"></a><strong>INCRBY</strong></h3><p><strong>INCRBY key increment</strong><br> 将 key 所储存的值加上增量 increment 。<br> 如果 key 不存在，那么 key 的值会先被初始化为 0 ，然后再执行 INCRBY 命令。<br> 如果值包含错误的类型，或字符串类型的值不能表示为数字，那么返回一个错误。<br> 本操作的值限制在 64 位(bit)有符号数字表示之内。</p><h4 id="可用版本-7"><a href="#可用版本-7" class="headerlink" title="可用版本"></a>可用版本</h4><p>版本&gt;= 1.0.0</p><h4 id="时间复杂度-7"><a href="#时间复杂度-7" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><p>O(1)</p><h4 id="返回值-15"><a href="#返回值-15" class="headerlink" title="返回值"></a>返回值</h4><p>加上 increment 之后， key 的值。</p><h4 id="示例-15"><a href="#示例-15" class="headerlink" title="示例"></a>示例</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"># key 存在且是数字值</div><div class="line">redis&gt; SET rank 50</div><div class="line">OK</div><div class="line">redis&gt; INCRBY rank 20</div><div class="line">(integer) 70</div><div class="line">redis&gt; GET rank</div><div class="line">&quot;70&quot;</div><div class="line"># key 不存在时</div><div class="line">redis&gt; EXISTS counter</div><div class="line">(integer) 0</div><div class="line">redis&gt; INCRBY counter 30</div><div class="line">(integer) 30</div><div class="line">redis&gt; GET counter</div><div class="line">&quot;30&quot;</div><div class="line"># key 不是数字值时</div><div class="line">redis&gt; SET book &quot;long long ago...&quot;</div><div class="line">OK</div><div class="line">redis&gt; INCRBY book 200</div><div class="line">(error) ERR value is not an integer or out of range</div></pre></td></tr></table></figure><h3 id="INCRBYFLOAT"><a href="#INCRBYFLOAT" class="headerlink" title="INCRBYFLOAT"></a><strong>INCRBYFLOAT</strong></h3><p><strong>INCRBYFLOAT key increment</strong><br> 为 key 中所储存的值加上浮点数增量 increment 。<br> 如果 key 不存在，那么 INCRBYFLOAT 会先将 key 的值设为 0 ，再执行加法操作。<br> 如果命令执行成功，那么 key 的值会被更新为（执行加法之后的）新值，并且新值会以字符串的形式返回给调用者。<br> 无论是 key 的值，还是增量 increment ，都可以使用像 2.0e7 、 3e5 、 90e-2 那样的指数符号(exponential notation)来表示，但是，执行 INCRBYFLOAT 命令之后的值总是以同样的形式储存，也即是，它们总是由一个数字，一个（可选的）小数点和一个任意位的小数部分组成（比如 3.14 、 69.768 ，诸如此类)，小数部分尾随的 0 会被移除，如果有需要的话，还会将浮点数改为整数（比如 3.0 会被保存成 3 ）。<br> 除此之外，无论加法计算所得的浮点数的实际精度有多长， INCRBYFLOAT 的计算结果也最多只能表示小数点的后十七位。</p><p>当以下任意一个条件发生时，返回一个错误：</p><ul><li>key 的值不是字符串类型(因为 Redis 中的数字和浮点数都以字符串的形式保存，所以它们都属于字符串类型）</li><li>key 当前的值或者给定的增量 increment 不能解释(parse)为双精度浮点数(double precision floating point number）</li></ul><h4 id="可用版本-8"><a href="#可用版本-8" class="headerlink" title="可用版本"></a>可用版本</h4><p>版本&gt;= 2.6.0</p><h4 id="时间复杂度-8"><a href="#时间复杂度-8" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><p>O(1)</p><h4 id="返回值-16"><a href="#返回值-16" class="headerlink" title="返回值"></a>返回值</h4><p>执行命令之后 key 的值。</p><h4 id="示例-16"><a href="#示例-16" class="headerlink" title="示例"></a>示例</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"># 值和增量都不是指数符号</div><div class="line">redis&gt; SET mykey 10.50</div><div class="line">OK</div><div class="line">redis&gt; INCRBYFLOAT mykey 0.1</div><div class="line">&quot;10.6&quot;</div><div class="line"># 值和增量都是指数符号</div><div class="line">redis&gt; SET mykey 314e-2</div><div class="line">OK</div><div class="line">redis&gt; GET mykey                # 用 SET 设置的值可以是指数符号</div><div class="line">&quot;314e-2&quot;</div><div class="line">redis&gt; INCRBYFLOAT mykey 0      # 但执行 INCRBYFLOAT 之后格式会被改成非指数符号</div><div class="line">&quot;3.14&quot;</div><div class="line"># 可以对整数类型执行</div><div class="line">redis&gt; SET mykey 3</div><div class="line">OK</div><div class="line">redis&gt; INCRBYFLOAT mykey 1.1</div><div class="line">&quot;4.1&quot;</div><div class="line"># 后跟的 0 会被移除</div><div class="line">redis&gt; SET mykey 3.0</div><div class="line">OK</div><div class="line">redis&gt; GET mykey                                    # SET 设置的值小数部分可以是 0</div><div class="line">&quot;3.0&quot;</div><div class="line">redis&gt; INCRBYFLOAT mykey 1.000000000000000000000    # 但 INCRBYFLOAT 会将无用的 0 忽略掉，有需要的话，将浮点变为整数</div><div class="line">&quot;4&quot;</div><div class="line">redis&gt; GET mykey</div><div class="line">&quot;4&quot;</div></pre></td></tr></table></figure><h3 id="MGET"><a href="#MGET" class="headerlink" title="MGET"></a><strong>MGET</strong></h3><p><strong>MGET key [key …]</strong><br> 返回所有(一个或多个)给定 key 的值。<br> 如果给定的 key 里面，有某个 key 不存在，那么这个 key 返回特殊值 nil 。因此，该命令永不失败。</p><h4 id="可用版本-9"><a href="#可用版本-9" class="headerlink" title="可用版本"></a>可用版本</h4><p>版本&gt;= 1.0.0</p><h4 id="时间复杂度-9"><a href="#时间复杂度-9" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><p>O(N) , N 为给定 key 的数量。</p><h4 id="返回值-17"><a href="#返回值-17" class="headerlink" title="返回值"></a>返回值</h4><p>一个包含所有给定 key 的值的列表。</p><h4 id="示例-17"><a href="#示例-17" class="headerlink" title="示例"></a>示例</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">redis&gt; SET redis redis.com</div><div class="line">OK</div><div class="line">redis&gt; SET mongodb mongodb.org</div><div class="line">OK</div><div class="line">redis&gt; MGET redis mongodb</div><div class="line">1) &quot;redis.com&quot;</div><div class="line">2) &quot;mongodb.org&quot;</div><div class="line">redis&gt; MGET redis mongodb mysql     # 不存在的 mysql 返回 nil</div><div class="line">1) &quot;redis.com&quot;</div><div class="line">2) &quot;mongodb.org&quot;</div><div class="line">3) (nil)</div></pre></td></tr></table></figure><h3 id="MSET"><a href="#MSET" class="headerlink" title="MSET"></a><strong>MSET</strong></h3><p><strong>MSET key value [key value …]</strong><br> 同时设置一个或多个 key-value 对。<br> 如果某个给定 key 已经存在，那么 MSET 会用新值覆盖原来的旧值，如果这不是你所希望的效果，请考虑使用 MSETNX 命令：它只会在所有给定 key 都不存在的情况下进行设置操作。<br> MSET 是一个原子性(atomic)操作，所有给定 key 都会在同一时间内被设置，某些给定 key 被更新而另一些给定 key 没有改变的情况，不可能发生。</p><h4 id="可用版本-10"><a href="#可用版本-10" class="headerlink" title="可用版本"></a>可用版本</h4><p>版本&gt;= 1.0.1</p><h4 id="时间复杂度-10"><a href="#时间复杂度-10" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><p>O(N)， N 为要设置的 key 数量。</p><h4 id="返回值-18"><a href="#返回值-18" class="headerlink" title="返回值"></a>返回值</h4><p>总是返回 OK (因为 MSET 不可能失败)</p><h4 id="示例-18"><a href="#示例-18" class="headerlink" title="示例"></a>示例</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">redis&gt; MSET date &quot;2012.3.30&quot; time &quot;11:00 a.m.&quot; weather &quot;sunny&quot;</div><div class="line">OK</div><div class="line">redis&gt; MGET date time weather</div><div class="line">1) &quot;2012.3.30&quot;</div><div class="line">2) &quot;11:00 a.m.&quot;</div><div class="line">3) &quot;sunny&quot;</div><div class="line"># MSET 覆盖旧值例子</div><div class="line">redis&gt; SET google &quot;google.hk&quot;</div><div class="line">OK</div><div class="line">redis&gt; MSET google &quot;google.com&quot;</div><div class="line">OK</div><div class="line">redis&gt; GET google</div><div class="line">&quot;google.com&quot;</div></pre></td></tr></table></figure><h3 id="MSETNX"><a href="#MSETNX" class="headerlink" title="MSETNX"></a><strong>MSETNX</strong></h3><p><strong>MSETNX key value [key value …]</strong><br> 同时设置一个或多个 key-value 对，当且仅当所有给定 key 都不存在。<br> 即使只有一个给定 key 已存在， MSETNX 也会拒绝执行所有给定 key 的设置操作。<br> MSETNX 是原子性的，因此它可以用作设置多个不同 key 表示不同字段(field)的唯一性逻辑对象(unique logic object)，所有字段要么全被设置，要么全不被设置。</p><h4 id="可用版本-11"><a href="#可用版本-11" class="headerlink" title="可用版本"></a>可用版本</h4><p>版本&gt;= 1.0.1</p><h4 id="时间复杂度-11"><a href="#时间复杂度-11" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><p>O(N)， N 为要设置的 key 的数量。</p><h4 id="返回值-19"><a href="#返回值-19" class="headerlink" title="返回值"></a>返回值</h4><p>当所有 key 都成功设置，返回 1 。<br>如果所有给定 key 都设置失败(至少有一个 key 已经存在)，那么返回 0 。</p><h4 id="示例-19"><a href="#示例-19" class="headerlink" title="示例"></a>示例</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"># 对不存在的 key 进行 MSETNX</div><div class="line">redis&gt; MSETNX rmdbs &quot;MySQL&quot; nosql &quot;MongoDB&quot; key-value-store &quot;redis&quot;</div><div class="line">(integer) 1</div><div class="line">redis&gt; MGET rmdbs nosql key-value-store</div><div class="line">1) &quot;MySQL&quot;</div><div class="line">2) &quot;MongoDB&quot;</div><div class="line">3) &quot;redis&quot;</div><div class="line"># MSET 的给定 key 当中有已存在的 key</div><div class="line">redis&gt; MSETNX rmdbs &quot;Sqlite&quot; language &quot;python&quot;  # rmdbs 键已经存在，操作失败</div><div class="line">(integer) 0</div><div class="line">redis&gt; EXISTS language                          # 因为 MSET 是原子性操作，language 没有被设置</div><div class="line">(integer) 0</div><div class="line">redis&gt; GET rmdbs                                # rmdbs 也没有被修改</div><div class="line">&quot;MySQL&quot;</div></pre></td></tr></table></figure><h3 id="PSETEX"><a href="#PSETEX" class="headerlink" title="PSETEX"></a><strong>PSETEX</strong></h3><p><strong>PSETEX key milliseconds value</strong><br>  这个命令和 SETEX 命令相似，但它以毫秒为单位设置 key 的生存时间，而不是像 SETEX 命令那样，以秒为单位。</p><h4 id="可用版本-12"><a href="#可用版本-12" class="headerlink" title="可用版本"></a>可用版本</h4><p>版本&gt;= 2.6.0</p><h4 id="时间复杂度-12"><a href="#时间复杂度-12" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><p>O(1)</p><h4 id="返回值-20"><a href="#返回值-20" class="headerlink" title="返回值"></a>返回值</h4><p>设置成功时返回 OK 。</p><h4 id="示例-20"><a href="#示例-20" class="headerlink" title="示例"></a>示例</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">redis&gt; PSETEX mykey 1000 &quot;Hello&quot;</div><div class="line">OK</div><div class="line">redis&gt; PTTL mykey</div><div class="line">(integer) 999</div><div class="line">redis&gt; GET mykey</div><div class="line">&quot;Hello&quot;</div></pre></td></tr></table></figure><h3 id="STRLEN"><a href="#STRLEN" class="headerlink" title="STRLEN"></a><strong>STRLEN</strong></h3><p><strong>STRLEN key</strong><br> 返回 key 所储存的字符串值的长度。<br> 当 key 储存的不是字符串值时，返回一个错误。</p><h4 id="可用版本-13"><a href="#可用版本-13" class="headerlink" title="可用版本"></a>可用版本</h4><p>版本&gt;= 2.2.0</p><h4 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h4><p>O(1)</p><h4 id="返回值-21"><a href="#返回值-21" class="headerlink" title="返回值"></a>返回值</h4><p>字符串值的长度。<br>当 key 不存在时，返回 0 。</p><h4 id="示例-21"><a href="#示例-21" class="headerlink" title="示例"></a>示例</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"># 获取字符串的长度</div><div class="line">redis&gt; SET mykey &quot;Hello world&quot;</div><div class="line">OK</div><div class="line">redis&gt; STRLEN mykey</div><div class="line">(integer) 11</div><div class="line"># 不存在的 key 长度为 0</div><div class="line">redis&gt; STRLEN nonexisting</div><div class="line">(integer) 0</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Redis的字符串和其他编程语言或者其他键值存储提供的字符串非常相似。一个key对应一个value。&lt;br&gt;string类型是二进制安全的，可以包含任何数据，比如jpg图片或者序列化的对象。从内部实现来看其实string可以看作byte数组，最大上限1G字节。&lt;br&gt;另外string类型可以被部分命令按int处理，比如incr等命令。&lt;br&gt;文档目前描述的内容以 Redis 2.8 版本为准。&lt;br&gt;
    
    </summary>
    
      <category term="Redis" scheme="http://yoursite.com/categories/Redis/"/>
    
    
      <category term="Redis" scheme="http://yoursite.com/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Redis数据类型--Set（集合）</title>
    <link href="http://yoursite.com/2017/03/06/Redis%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B--Set%EF%BC%88%E9%9B%86%E5%90%88%EF%BC%89/"/>
    <id>http://yoursite.com/2017/03/06/Redis数据类型--Set（集合）/</id>
    <published>2017-03-06T13:02:25.000Z</published>
    <updated>2017-09-28T09:36:40.316Z</updated>
    
    <content type="html"><![CDATA[<p>Redis的集合和列表都可以存储多个字符串，它们之间的不同在于，列表可以存储多个不同的字符串，而集合则通过使用散列来保证自己存储的每个字符串都是各不相同的。包含字符串的无序收集器（unordered collection）,并且被包含的每个字符串都是独一无二、各不相同的。<br>结构的读写：<br> 添加、读取、移除单个元素<br> 检查一个元素是否存在于集合中<br> 计算交集、并集、差集<br> 从集合中随机获取元素<br><a id="more"></a></p><h3 id="SADD"><a href="#SADD" class="headerlink" title="SADD"></a><strong>SADD</strong></h3><p><strong>SADD key member [member …]</strong><br> 将一个或多个 member 元素加入到集合 key 当中，已经存在于集合的 member 元素将被忽略。<br> 假如 key 不存在，则创建一个只包含 member 元素作成员的集合。<br> 当 key 不是集合类型时，返回一个错误。<br> 在Redis2.4版本以前， SADD 只接受单个 member 值。</p><h4 id="可用版本"><a href="#可用版本" class="headerlink" title="可用版本"></a>可用版本</h4><p>版本&gt;= 1.0.0</p><h4 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><p>O(N)， N 是被添加的元素的数量。</p><h4 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h4><p>被添加到集合中的新元素的数量，不包括被忽略的元素。</p><h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"># 添加单个元素</div><div class="line">redis&gt; SADD bbs &quot;discuz.net&quot;</div><div class="line">(integer) 1</div><div class="line"># 添加重复元素</div><div class="line">redis&gt; SADD bbs &quot;discuz.net&quot;</div><div class="line">(integer) 0</div><div class="line"># 添加多个元素</div><div class="line">redis&gt; SADD bbs &quot;tianya.cn&quot; &quot;groups.google.com&quot;</div><div class="line">(integer) 2</div><div class="line">redis&gt; SMEMBERS bbs</div><div class="line">1) &quot;discuz.net&quot;</div><div class="line">2) &quot;groups.google.com&quot;</div><div class="line">3) &quot;tianya.cn&quot;</div></pre></td></tr></table></figure><h3 id="SCARD"><a href="#SCARD" class="headerlink" title="SCARD"></a><strong>SCARD</strong></h3><p><strong>SCARD key</strong><br> 返回集合 key 的基数(集合中元素的数量)。</p><h4 id="可用版本-1"><a href="#可用版本-1" class="headerlink" title="可用版本"></a>可用版本</h4><p>版本&gt;= 1.0.0</p><h4 id="时间复杂度-1"><a href="#时间复杂度-1" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><p>O(1)</p><h4 id="返回值-1"><a href="#返回值-1" class="headerlink" title="返回值"></a>返回值</h4><p>集合的基数。<br>当 key 不存在时，返回 0 。</p><h4 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">redis&gt; SADD tool pc printer phone</div><div class="line">(integer) 3</div><div class="line">redis&gt; SCARD tool   # 非空集合</div><div class="line">(integer) 3</div><div class="line">redis&gt; DEL tool</div><div class="line">(i</div><div class="line">redis&gt; SCARD tool   # 空集合</div><div class="line">(integer) 0</div></pre></td></tr></table></figure><h3 id="SDIFF"><a href="#SDIFF" class="headerlink" title="SDIFF"></a><strong>SDIFF</strong></h3><p><strong>SDIFF key [key …]</strong><br> 返回一个集合的全部成员，该集合是所有给定集合之间的差集。<br> 不存在的 key 被视为空集。</p><h4 id="可用版本-2"><a href="#可用版本-2" class="headerlink" title="可用版本"></a>可用版本</h4><p>版本&gt;= 1.0.0</p><h4 id="时间复杂度-2"><a href="#时间复杂度-2" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><p>O(N)， N 是所有给定集合的成员数量之和。</p><h4 id="返回值-2"><a href="#返回值-2" class="headerlink" title="返回值"></a>返回值</h4><p>交集成员的列表。</p><h4 id="示例-2"><a href="#示例-2" class="headerlink" title="示例"></a>示例</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">redis&gt; SMEMBERS peter&apos;s_movies</div><div class="line">1) &quot;bet man&quot;</div><div class="line">2) &quot;start war&quot;</div><div class="line">3) &quot;2012&quot;</div><div class="line">redis&gt; SMEMBERS joe&apos;s_movies</div><div class="line">1) &quot;hi, lady&quot;</div><div class="line">2) &quot;Fast Five&quot;</div><div class="line">3) &quot;2012&quot;</div><div class="line">redis&gt; SDIFF peter&apos;s_movies joe&apos;s_movies</div><div class="line">1) &quot;bet man&quot;</div><div class="line">2) &quot;start war&quot;</div></pre></td></tr></table></figure><h3 id="SDIFFSTORE"><a href="#SDIFFSTORE" class="headerlink" title="SDIFFSTORE"></a><strong>SDIFFSTORE</strong></h3><p><strong>SDIFFSTORE destination key [key …]</strong><br> 这个命令的作用和 SDIFF 类似，但它将结果保存到 destination 集合，而不是简单地返回结果集。<br> 如果 destination 集合已经存在，则将其覆盖。<br> destination 可以是 key 本身。</p><h4 id="可用版本-3"><a href="#可用版本-3" class="headerlink" title="可用版本"></a>可用版本</h4><p>版本&gt;= 1.0.0</p><h4 id="时间复杂度-3"><a href="#时间复杂度-3" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><p>O(N)， N 是所有给定集合的成员数量之和。</p><h4 id="返回值-3"><a href="#返回值-3" class="headerlink" title="返回值"></a>返回值</h4><p>结果集中的元素数量。</p><h4 id="示例-3"><a href="#示例-3" class="headerlink" title="示例"></a>示例</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">redis&gt; SMEMBERS joe&apos;s_movies</div><div class="line">1) &quot;hi, lady&quot;</div><div class="line">2) &quot;Fast Five&quot;</div><div class="line">3) &quot;2012&quot;</div><div class="line">redis&gt; SMEMBERS peter&apos;s_movies</div><div class="line">1) &quot;bet man&quot;</div><div class="line">2) &quot;start war&quot;</div><div class="line">3) &quot;2012&quot;</div><div class="line">redis&gt; SDIFFSTORE joe_diff_peter joe&apos;s_movies peter&apos;s_movies</div><div class="line">(integer) 2</div><div class="line">redis&gt; SMEMBERS joe_diff_peter</div><div class="line">1) &quot;hi, lady&quot;</div><div class="line">2) &quot;Fast Five&quot;</div></pre></td></tr></table></figure><h3 id="SINTER"><a href="#SINTER" class="headerlink" title="SINTER"></a><strong>SINTER</strong></h3><p><strong>SINTER key [key …]</strong><br> 返回一个集合的全部成员，该集合是所有给定集合的交集。<br> 不存在的 key 被视为空集。<br> 当给定集合当中有一个空集时，结果也为空集(根据集合运算定律)。</p><h4 id="可用版本-4"><a href="#可用版本-4" class="headerlink" title="可用版本"></a>可用版本</h4><p>版本&gt;= 1.0.0</p><h4 id="时间复杂度-4"><a href="#时间复杂度-4" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><p>O(N * M)， N 为给定集合当中基数最小的集合， M 为给定集合的个数。</p><h4 id="返回值-4"><a href="#返回值-4" class="headerlink" title="返回值"></a>返回值</h4><p>交集成员的列表。</p><h4 id="示例-4"><a href="#示例-4" class="headerlink" title="示例"></a>示例</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">redis&gt; SMEMBERS group_1</div><div class="line">1) &quot;LI LEI&quot;</div><div class="line">2) &quot;TOM&quot;</div><div class="line">3) &quot;JACK&quot;</div><div class="line">redis&gt; SMEMBERS group_2</div><div class="line">1) &quot;HAN MEIMEI&quot;</div><div class="line">2) &quot;JACK&quot;</div><div class="line">redis&gt; SINTER group_1 group_2</div><div class="line">1) &quot;JACK&quot;</div></pre></td></tr></table></figure><h3 id="SINTERSTORE"><a href="#SINTERSTORE" class="headerlink" title="SINTERSTORE"></a><strong>SINTERSTORE</strong></h3><p><strong>SINTERSTORE destination key [key …]</strong></p><p> 这个命令类似于 SINTER 命令，但它将结果保存到 destination 集合，而不是简单地返回结果集。<br> 如果 destination 集合已经存在，则将其覆盖。<br> destination 可以是 key 本身。</p><h4 id="可用版本-5"><a href="#可用版本-5" class="headerlink" title="可用版本"></a>可用版本</h4><p>版本&gt;= 1.0.0</p><h4 id="时间复杂度-5"><a href="#时间复杂度-5" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><p>O(N * M)， N 为给定集合当中基数最小的集合， M 为给定集合的个数。</p><h4 id="返回值-5"><a href="#返回值-5" class="headerlink" title="返回值"></a>返回值</h4><p>结果集中的成员数量。</p><h4 id="示例-5"><a href="#示例-5" class="headerlink" title="示例"></a>示例</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">redis&gt; SMEMBERS songs</div><div class="line">1) &quot;good bye joe&quot;</div><div class="line">2) &quot;hello,peter&quot;</div><div class="line">redis&gt; SMEMBERS my_songs</div><div class="line">1) &quot;good bye joe&quot;</div><div class="line">2) &quot;falling&quot;</div><div class="line">redis&gt; SINTERSTORE song_interset songs my_songs</div><div class="line">(integer) 1</div><div class="line">redis&gt; SMEMBERS song_interset</div><div class="line">1) &quot;good bye joe&quot;</div></pre></td></tr></table></figure><h3 id="SISMEMBER"><a href="#SISMEMBER" class="headerlink" title="SISMEMBER"></a><strong>SISMEMBER</strong></h3><p><strong>SISMEMBER key member</strong><br> 判断 member 元素是否集合 key 的成员。</p><h4 id="可用版本-6"><a href="#可用版本-6" class="headerlink" title="可用版本"></a>可用版本</h4><p>版本&gt;= 1.0.0</p><h4 id="时间复杂度-6"><a href="#时间复杂度-6" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><p>O(1)</p><h4 id="返回值-6"><a href="#返回值-6" class="headerlink" title="返回值"></a>返回值</h4><p>如果 member 元素是集合的成员，返回 1 。<br>如果 member 元素不是集合的成员，或 key 不存在，返回 0 。</p><h4 id="示例-6"><a href="#示例-6" class="headerlink" title="示例"></a>示例</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">redis&gt; SMEMBERS joe&apos;s_movies</div><div class="line">1) &quot;hi, lady&quot;</div><div class="line">2) &quot;Fast Five&quot;</div><div class="line">3) &quot;2012&quot;</div><div class="line">redis&gt; SISMEMBER joe&apos;s_movies &quot;bet man&quot;</div><div class="line">(integer) 0</div><div class="line">redis&gt; SISMEMBER joe&apos;s_movies &quot;Fast Five&quot;</div><div class="line">(integer) 1</div></pre></td></tr></table></figure><h3 id="SMEMBERS"><a href="#SMEMBERS" class="headerlink" title="SMEMBERS"></a><strong>SMEMBERS</strong></h3><p><strong>SMEMBERS key</strong><br> 返回集合 key 中的所有成员。<br> 不存在的 key 被视为空集合。</p><h4 id="可用版本-7"><a href="#可用版本-7" class="headerlink" title="可用版本"></a>可用版本</h4><p>版本&gt;= 1.0.0</p><h4 id="时间复杂度-7"><a href="#时间复杂度-7" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><p>O(N)， N 为集合的基数。</p><h4 id="返回值-7"><a href="#返回值-7" class="headerlink" title="返回值"></a>返回值</h4><p>集合中的所有成员。</p><h4 id="示例-7"><a href="#示例-7" class="headerlink" title="示例"></a>示例</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"># key 不存在或集合为空</div><div class="line">redis&gt; EXISTS not_exists_key</div><div class="line">(integer) 0</div><div class="line">redis&gt; SMEMBERS not_exists_key</div><div class="line">(empty list or set)</div><div class="line"># 非空集合</div><div class="line">redis&gt; SADD language Ruby Python Clojure</div><div class="line">(integer) 3</div><div class="line">redis&gt; SMEMBERS language</div><div class="line">1) &quot;Python&quot;</div><div class="line">2) &quot;Ruby&quot;</div><div class="line">3) &quot;Clojure&quot;</div></pre></td></tr></table></figure><h3 id="SMOVE"><a href="#SMOVE" class="headerlink" title="SMOVE"></a><strong>SMOVE</strong></h3><p><strong>SMOVE source destination member</strong><br> 将 member 元素从 source 集合移动到 destination 集合。<br> SMOVE 是原子性操作。<br> 如果 source 集合不存在或不包含指定的 member 元素，则 SMOVE 命令不执行任何操作，仅返回 0 。否则， member 元素从 source 集合中被移除，并添加到 destination 集合中去。<br> 当 destination 集合已经包含 member 元素时， SMOVE 命令只是简单地将 source 集合中的 member 元素删除。<br> 当 source 或 destination 不是集合类型时，返回一个错误。</p><h4 id="可用版本-8"><a href="#可用版本-8" class="headerlink" title="可用版本"></a>可用版本</h4><p>版本&gt;= 1.0.0</p><h4 id="时间复杂度-8"><a href="#时间复杂度-8" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><p>O(1)</p><h4 id="返回值-8"><a href="#返回值-8" class="headerlink" title="返回值"></a>返回值</h4><p>如果 member 元素被成功移除，返回 1 。<br>如果 member 元素不是 source 集合的成员，并且没有任何操作对 destination 集合执行，那么返回 0 。</p><h4 id="示例-8"><a href="#示例-8" class="headerlink" title="示例"></a>示例</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">redis&gt; SMEMBERS songs</div><div class="line">1) &quot;Billie Jean&quot;</div><div class="line">2) &quot;Believe Me&quot;</div><div class="line">redis&gt; SMEMBERS my_songs</div><div class="line">(empty list or set)</div><div class="line">redis&gt; SMOVE songs my_songs &quot;Believe Me&quot;</div><div class="line">(integer) 1</div><div class="line">redis&gt; SMEMBERS songs</div><div class="line">1) &quot;Billie Jean&quot;</div><div class="line">redis&gt; SMEMBERS my_songs</div><div class="line">1) &quot;Believe Me&quot;</div></pre></td></tr></table></figure><h3 id="SPOP"><a href="#SPOP" class="headerlink" title="SPOP"></a><strong>SPOP</strong></h3><p><strong>SPOP key</strong><br> 移除并返回集合中的一个随机元素。<br> 如果只想获取一个随机元素，但不想该元素从集合中被移除的话，可以使用 SRANDMEMBER 命令。</p><h4 id="可用版本-9"><a href="#可用版本-9" class="headerlink" title="可用版本"></a>可用版本</h4><p>版本&gt;= 1.0.0</p><h4 id="时间复杂度-9"><a href="#时间复杂度-9" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><p>O(1)</p><h4 id="返回值-9"><a href="#返回值-9" class="headerlink" title="返回值"></a>返回值</h4><p>被移除的随机元素。<br>当 key 不存在或 key 是空集时，返回 nil 。</p><h4 id="示例-9"><a href="#示例-9" class="headerlink" title="示例"></a>示例</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">redis&gt; SMEMBERS db</div><div class="line">1) &quot;MySQL&quot;</div><div class="line">2) &quot;MongoDB&quot;</div><div class="line">3) &quot;Redis&quot;</div><div class="line">redis&gt; SPOP db</div><div class="line">&quot;Redis&quot;</div><div class="line">redis&gt; SMEMBERS db</div><div class="line">1) &quot;MySQL&quot;</div><div class="line">2) &quot;MongoDB&quot;</div><div class="line">redis&gt; SPOP db</div><div class="line">&quot;MySQL&quot;</div><div class="line">redis&gt; SMEMBERS db</div><div class="line">1) &quot;MongoDB&quot;</div></pre></td></tr></table></figure><h3 id="SRANDMEMBER"><a href="#SRANDMEMBER" class="headerlink" title="SRANDMEMBER"></a><strong>SRANDMEMBER</strong></h3><p><strong>SRANDMEMBER key [count]</strong></p><p> 如果命令执行时，只提供了 key 参数，那么返回集合中的一个随机元素。</p><p> 从 Redis 2.6 版本开始， SRANDMEMBER 命令接受可选的 count 参数：</p><ul><li>如果 count 为正数，且小于集合基数，那么命令返回一个包含 count 个元素的数组，数组中的元素各不相同。如果 count大于等于集合基数，那么返回整个集合。</li><li>如果 count 为负数，那么命令返回一个数组，数组中的元素可能会重复出现多次，而数组的长度为 count 的绝对值。</li></ul><p> 该操作和 SPOP 相似，但 SPOP 将随机元素从集合中移除并返回，而 SRANDMEMBER 则仅仅返回随机元素，而不对集合进行任何改动。</p><h4 id="可用版本-10"><a href="#可用版本-10" class="headerlink" title="可用版本"></a>可用版本</h4><p>版本&gt;= 1.0.0</p><h4 id="时间复杂度-10"><a href="#时间复杂度-10" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><p>只提供 key 参数时为 O(1) 。<br>如果提供了 count 参数，那么为 O(N) ，N 为返回数组的元素个数。</p><h4 id="返回值-10"><a href="#返回值-10" class="headerlink" title="返回值"></a>返回值</h4><p>只提供 key 参数时，返回一个元素；如果集合为空，返回 nil 。<br>如果提供了 count 参数，那么返回一个数组；如果集合为空，返回空数组。</p><h4 id="示例-10"><a href="#示例-10" class="headerlink" title="示例"></a>示例</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div></pre></td><td class="code"><pre><div class="line"># 添加元素</div><div class="line">redis&gt; SADD fruit apple banana cherry</div><div class="line">(integer) 3</div><div class="line"># 只给定 key 参数，返回一个随机元素</div><div class="line">redis&gt; SRANDMEMBER fruit</div><div class="line">&quot;cherry&quot;</div><div class="line">redis&gt; SRANDMEMBER fruit</div><div class="line">&quot;apple&quot;</div><div class="line"># 给定 3 为 count 参数，返回 3 个随机元素</div><div class="line"># 每个随机元素都不相同</div><div class="line">redis&gt; SRANDMEMBER fruit 3</div><div class="line">1) &quot;apple&quot;</div><div class="line">2) &quot;banana&quot;</div><div class="line">3) &quot;cherry&quot;</div><div class="line"># 给定 -3 为 count 参数，返回 3 个随机元素</div><div class="line"># 元素可能会重复出现多次</div><div class="line">redis&gt; SRANDMEMBER fruit -3</div><div class="line">1) &quot;banana&quot;</div><div class="line">2) &quot;cherry&quot;</div><div class="line">3) &quot;apple&quot;</div><div class="line">redis&gt; SRANDMEMBER fruit -3</div><div class="line">1) &quot;apple&quot;</div><div class="line">2) &quot;apple&quot;</div><div class="line">3) &quot;cherry&quot;</div><div class="line"># 如果 count 是整数，且大于等于集合基数，那么返回整个集合</div><div class="line">redis&gt; SRANDMEMBER fruit 10</div><div class="line">1) &quot;apple&quot;</div><div class="line">2) &quot;banana&quot;</div><div class="line">3) &quot;cherry&quot;</div><div class="line"># 如果 count 是负数，且 count 的绝对值大于集合的基数</div><div class="line"># 那么返回的数组的长度为 count 的绝对值</div><div class="line">redis&gt; SRANDMEMBER fruit -10</div><div class="line">1) &quot;banana&quot;</div><div class="line">2) &quot;apple&quot;</div><div class="line">3) &quot;banana&quot;</div><div class="line">4) &quot;cherry&quot;</div><div class="line">5) &quot;apple&quot;</div><div class="line">6) &quot;apple&quot;</div><div class="line">7) &quot;cherry&quot;</div><div class="line">8) &quot;apple&quot;</div><div class="line">9) &quot;apple&quot;</div><div class="line">10) &quot;banana&quot;</div><div class="line"># SRANDMEMBER 并不会修改集合内容</div><div class="line">redis&gt; SMEMBERS fruit</div><div class="line">1) &quot;apple&quot;</div><div class="line">2) &quot;cherry&quot;</div><div class="line">3) &quot;banana&quot;</div><div class="line"># 集合为空时返回 nil 或者空数组</div><div class="line">redis&gt; SRANDMEMBER not-exists</div><div class="line">(nil)</div><div class="line">redis&gt; SRANDMEMBER not-eixsts 10</div><div class="line">(empty list or set)</div></pre></td></tr></table></figure><h3 id="SREM"><a href="#SREM" class="headerlink" title="SREM"></a><strong>SREM</strong></h3><p><strong>SREM key member [member …]</strong><br> 移除集合 key 中的一个或多个 member 元素，不存在的 member 元素会被忽略。<br> 当 key 不是集合类型，返回一个错误。<br> 在 Redis 2.4 版本以前， SREM 只接受单个 member 值。</p><h4 id="可用版本-11"><a href="#可用版本-11" class="headerlink" title="可用版本"></a>可用版本</h4><p>版本&gt;= 1.0.0</p><h4 id="时间复杂度-11"><a href="#时间复杂度-11" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><p>O(N)， N 为给定 member 元素的数量。</p><h4 id="返回值-11"><a href="#返回值-11" class="headerlink" title="返回值"></a>返回值</h4><p>被成功移除的元素的数量，不包括被忽略的元素。</p><h4 id="示例-11"><a href="#示例-11" class="headerlink" title="示例"></a>示例</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"># 测试数据</div><div class="line">redis&gt; SMEMBERS languages</div><div class="line">1) &quot;c&quot;</div><div class="line">2) &quot;lisp&quot;</div><div class="line">3) &quot;python&quot;</div><div class="line">4) &quot;ruby&quot;</div><div class="line"># 移除单个元素</div><div class="line">redis&gt; SREM languages ruby</div><div class="line">(integer) 1</div><div class="line"># 移除不存在元素</div><div class="line">redis&gt; SREM languages non-exists-language</div><div class="line">(integer) 0</div><div class="line"># 移除多个元素</div><div class="line">redis&gt; SREM languages lisp python c</div><div class="line">(integer) 3</div><div class="line">redis&gt; SMEMBERS languages</div><div class="line">(empty list or set)</div></pre></td></tr></table></figure><h3 id="SUNION"><a href="#SUNION" class="headerlink" title="SUNION"></a><strong>SUNION</strong></h3><p><strong>SUNION key [key …]</strong><br> 返回一个集合的全部成员，该集合是所有给定集合的并集。<br> 不存在的 key 被视为空集。</p><h4 id="可用版本-12"><a href="#可用版本-12" class="headerlink" title="可用版本"></a>可用版本</h4><p>版本&gt;= 1.0.0</p><h4 id="时间复杂度-12"><a href="#时间复杂度-12" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><p>O(N)， N 是所有给定集合的成员数量之和。</p><h4 id="返回值-12"><a href="#返回值-12" class="headerlink" title="返回值"></a>返回值</h4><p>并集成员的列表。</p><h4 id="示例-12"><a href="#示例-12" class="headerlink" title="示例"></a>示例</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">redis&gt; SMEMBERS songs</div><div class="line">1) &quot;Billie Jean&quot;</div><div class="line">redis&gt; SMEMBERS my_songs</div><div class="line">1) &quot;Believe Me&quot;</div><div class="line">redis&gt; SUNION songs my_songs</div><div class="line">1) &quot;Billie Jean&quot;</div><div class="line">2) &quot;Believe Me&quot;</div></pre></td></tr></table></figure><h3 id="SUNIONSTORE"><a href="#SUNIONSTORE" class="headerlink" title="SUNIONSTORE"></a><strong>SUNIONSTORE</strong></h3><p><strong>SUNIONSTORE destination key [key …]</strong><br> 这个命令类似于 SUNION 命令，但它将结果保存到 destination 集合，而不是简单地返回结果集。<br> 如果 destination 已经存在，则将其覆盖。<br> destination 可以是 key 本身。</p><h4 id="可用版本-13"><a href="#可用版本-13" class="headerlink" title="可用版本"></a>可用版本</h4><p>版本&gt;= 1.0.0</p><h4 id="时间复杂度-13"><a href="#时间复杂度-13" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><p>O(N)， N 是所有给定集合的成员数量之和。</p><h4 id="返回值-13"><a href="#返回值-13" class="headerlink" title="返回值"></a>返回值</h4><p>结果集中的元素数量。</p><h4 id="示例-13"><a href="#示例-13" class="headerlink" title="示例"></a>示例</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">redis&gt; SMEMBERS NoSQL</div><div class="line">1) &quot;MongoDB&quot;</div><div class="line">2) &quot;Redis&quot;</div><div class="line">redis&gt; SMEMBERS SQL</div><div class="line">1) &quot;sqlite&quot;</div><div class="line">2) &quot;MySQL&quot;</div><div class="line">redis&gt; SUNIONSTORE db NoSQL SQL</div><div class="line">(integer) 4</div><div class="line">redis&gt; SMEMBERS db</div><div class="line">1) &quot;MySQL&quot;</div><div class="line">2) &quot;sqlite&quot;</div><div class="line">3) &quot;MongoDB&quot;</div><div class="line">4) &quot;Redis&quot;</div></pre></td></tr></table></figure><h3 id="SSCAN"><a href="#SSCAN" class="headerlink" title="SSCAN"></a><strong>SSCAN</strong></h3><p><strong>SSCAN key cursor [MATCH pattern] [COUNT count]</strong><br> 详细信息请参考 SCAN 命令。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Redis的集合和列表都可以存储多个字符串，它们之间的不同在于，列表可以存储多个不同的字符串，而集合则通过使用散列来保证自己存储的每个字符串都是各不相同的。包含字符串的无序收集器（unordered collection）,并且被包含的每个字符串都是独一无二、各不相同的。&lt;br&gt;结构的读写：&lt;br&gt; 添加、读取、移除单个元素&lt;br&gt; 检查一个元素是否存在于集合中&lt;br&gt; 计算交集、并集、差集&lt;br&gt; 从集合中随机获取元素&lt;br&gt;
    
    </summary>
    
      <category term="Redis" scheme="http://yoursite.com/categories/Redis/"/>
    
    
      <category term="Redis" scheme="http://yoursite.com/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Redis数据类型--SortedSet（有序集合）</title>
    <link href="http://yoursite.com/2017/03/06/Redis%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B--SortedSet%EF%BC%88%E6%9C%89%E5%BA%8F%E9%9B%86%E5%90%88%EF%BC%89/"/>
    <id>http://yoursite.com/2017/03/06/Redis数据类型--SortedSet（有序集合）/</id>
    <published>2017-03-06T13:02:25.000Z</published>
    <updated>2017-09-28T09:35:43.367Z</updated>
    
    <content type="html"><![CDATA[<p>有序集合和散列一样，都用于存储键值对：有序集合的键被称为成员（member），每个成员都是各不相同；而有序集合的值则被称为分值（score），分值必须为浮点数。有序集合是Redis里面唯一一个既可以根据成员访问元素（这一点和散列一样），又可以根据分值以及分值的排列顺序来访问元素的结构。字符串成员（member）与浮点数分值（score）之间的有序映射，元素的排列顺序由分值的大小决定。<br>结构的读写：<br> 添加、获取、删除单个元素<br> 根据分值范围（range）或者成员来获取元素<br><a id="more"></a></p><h3 id="ZADD"><a href="#ZADD" class="headerlink" title="ZADD"></a><strong>ZADD</strong></h3><p><strong>ZADD key score member [[score member] [score member] …]</strong></p><p> 将一个或多个 member 元素及其 score 值加入到有序集 key 当中。<br> 如果某个 member 已经是有序集的成员，那么更新这个 member 的 score 值，并通过重新插入这个 member 元素，来保证该 member 在正确的位置上。<br> score 值可以是整数值或双精度浮点数。<br> 如果 key 不存在，则创建一个空的有序集并执行 ZADD 操作。<br> 当 key 存在但不是有序集类型时，返回一个错误。<br> 在 Redis 2.4 版本以前， ZADD 每次只能添加一个元素。</p><h4 id="可用版本"><a href="#可用版本" class="headerlink" title="可用版本"></a>可用版本</h4><p>版本&gt;= 1.2.0</p><h4 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><p>O(M*log(N))， N 是有序集的基数， M 为成功添加的新成员的数量。</p><h4 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h4><p>被成功添加的新成员的数量，不包括那些被更新的、已经存在的成员。</p><h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"># 添加单个元素</div><div class="line">redis&gt; ZADD page_rank 10 google.com</div><div class="line">(integer) 1</div><div class="line"># 添加多个元素</div><div class="line">redis&gt; ZADD page_rank 9 baidu.com 8 bing.com</div><div class="line">(integer) 2</div><div class="line">redis&gt; ZRANGE page_rank 0 -1 WITHSCORES</div><div class="line">1) &quot;bing.com&quot;</div><div class="line">2) &quot;8&quot;</div><div class="line">3) &quot;baidu.com&quot;</div><div class="line">4) &quot;9&quot;</div><div class="line">5) &quot;google.com&quot;</div><div class="line">6) &quot;10&quot;</div><div class="line"># 添加已存在元素，且 score 值不变</div><div class="line">redis&gt; ZADD page_rank 10 google.com</div><div class="line">(integer) 0</div><div class="line">redis&gt; ZRANGE page_rank 0 -1 WITHSCORES  # 没有改变</div><div class="line">1) &quot;bing.com&quot;</div><div class="line">2) &quot;8&quot;</div><div class="line">3) &quot;baidu.com&quot;</div><div class="line">4) &quot;9&quot;</div><div class="line">5) &quot;google.com&quot;</div><div class="line">6) &quot;10&quot;</div><div class="line"># 添加已存在元素，但是改变 score 值</div><div class="line">redis&gt; ZADD page_rank 6 bing.com</div><div class="line">(integer) 0</div><div class="line">redis&gt; ZRANGE page_rank 0 -1 WITHSCORES  # bing.com 元素的 score 值被改变</div><div class="line">1) &quot;bing.com&quot;</div><div class="line">2) &quot;6&quot;</div><div class="line">3) &quot;baidu.com&quot;</div><div class="line">4) &quot;9&quot;</div><div class="line">5) &quot;google.com&quot;</div><div class="line">6) &quot;10&quot;</div></pre></td></tr></table></figure><h3 id="ZCARD"><a href="#ZCARD" class="headerlink" title="ZCARD"></a><strong>ZCARD</strong></h3><p><strong>ZCARD key</strong></p><p> 返回有序集 key 的基数。</p><h4 id="可用版本-1"><a href="#可用版本-1" class="headerlink" title="可用版本"></a>可用版本</h4><p>版本&gt;= 1.2.0</p><h4 id="时间复杂度-1"><a href="#时间复杂度-1" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><p>O(1)</p><h4 id="返回值-1"><a href="#返回值-1" class="headerlink" title="返回值"></a>返回值</h4><p>当 key 存在且是有序集类型时，返回有序集的基数。<br>当 key 不存在时，返回 0 。</p><h4 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">redis &gt; ZADD salary 2000 tom    # 添加一个成员</div><div class="line">(integer) 1</div><div class="line">redis &gt; ZCARD salary</div><div class="line">(integer) 1</div><div class="line">redis &gt; ZADD salary 5000 jack   # 再添加一个成员</div><div class="line">(integer) 1</div><div class="line">redis &gt; ZCARD salary</div><div class="line">(integer) 2</div><div class="line">redis &gt; EXISTS non_exists_key   # 对不存在的 key 进行 ZCARD 操作</div><div class="line">(integer) 0</div><div class="line">redis &gt; ZCARD non_exists_key</div><div class="line">(integer) 0</div></pre></td></tr></table></figure><h3 id="ZCOUNT"><a href="#ZCOUNT" class="headerlink" title="ZCOUNT"></a><strong>ZCOUNT</strong></h3><p><strong>ZCOUNT key min max</strong></p><p> 返回有序集 key 中， score 值在 min 和 max 之间(默认包括 score 值等于 min 或 max )的成员的数量。</p><h4 id="可用版本-2"><a href="#可用版本-2" class="headerlink" title="可用版本"></a>可用版本</h4><p>版本&gt;= 2.0.0</p><h4 id="时间复杂度-2"><a href="#时间复杂度-2" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><p>O(log(N)+M)， N 为有序集的基数， M 为值在 min 和 max 之间的元素的数量。</p><h4 id="返回值-2"><a href="#返回值-2" class="headerlink" title="返回值"></a>返回值</h4><p>score 值在 min 和 max 之间的成员的数量。</p><h4 id="示例-2"><a href="#示例-2" class="headerlink" title="示例"></a>示例</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">redis&gt; ZRANGE salary 0 -1 WITHSCORES    # 测试数据</div><div class="line">1) &quot;jack&quot;</div><div class="line">2) &quot;2000&quot;</div><div class="line">3) &quot;peter&quot;</div><div class="line">4) &quot;3500&quot;</div><div class="line">5) &quot;tom&quot;</div><div class="line">6) &quot;5000&quot;</div><div class="line">redis&gt; ZCOUNT salary 2000 5000          # 计算薪水在 2000-5000 之间的人数</div><div class="line">(integer) 3</div><div class="line">redis&gt; ZCOUNT salary 3000 5000          # 计算薪水在 3000-5000 之间的人数</div><div class="line">(integer) 2</div></pre></td></tr></table></figure><h3 id="ZINCRBY"><a href="#ZINCRBY" class="headerlink" title="ZINCRBY"></a><strong>ZINCRBY</strong></h3><p><strong>ZINCRBY key increment member</strong></p><p> 为有序集 key 的成员 member 的 score 值加上增量 increment 。<br> 可以通过传递一个负数值 increment ，让 score 减去相应的值，比如 ZINCRBY key -5 member ，就是让 member 的 score 值减去 5 。<br> 当 key 不存在，或 member 不是 key 的成员时， ZINCRBY key increment member 等同于 ZADD key increment member 。<br> 当 key 不是有序集类型时，返回一个错误。<br> score 值可以是整数值或双精度浮点数。</p><h4 id="可用版本-3"><a href="#可用版本-3" class="headerlink" title="可用版本"></a>可用版本</h4><p>版本&gt;= 1.2.0</p><h4 id="时间复杂度-3"><a href="#时间复杂度-3" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><p>O(log(N))</p><h4 id="返回值-3"><a href="#返回值-3" class="headerlink" title="返回值"></a>返回值</h4><p>member 成员的新 score 值，以字符串形式表示。</p><h4 id="示例-3"><a href="#示例-3" class="headerlink" title="示例"></a>示例</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">redis&gt; ZSCORE salary tom</div><div class="line">&quot;2000&quot;</div><div class="line">redis&gt; ZINCRBY salary 2000 tom   # tom 加薪啦！</div><div class="line">&quot;4000&quot;</div></pre></td></tr></table></figure><h3 id="ZRANGE"><a href="#ZRANGE" class="headerlink" title="ZRANGE"></a><strong>ZRANGE</strong></h3><p><strong>ZRANGE key start stop [WITHSCORES]</strong></p><p> 返回有序集 key 中，指定区间内的成员。<br> 其中成员的位置按 score 值递增(从小到大)来排序。<br> 具有相同 score 值的成员按字典序(lexicographical order )来排列。<br> 如果你需要成员按 score 值递减(从大到小)来排列，请使用 ZREVRANGE 命令。<br> 下标参数 start 和 stop 都以 0 为底，也就是说，以 0 表示有序集第一个成员，以 1 表示有序集第二个成员，以此类推。<br>你也可以使用负数下标，以 -1 表示最后一个成员， -2 表示倒数第二个成员，以此类推。<br> 超出范围的下标并不会引起错误。</p><ul><li>比如说，当 start 的值比有序集的最大下标还要大，或是 start &gt; stop 时， ZRANGE 命令只是简单地返回一个空列表。</li><li>另一方面，假如 stop 参数的值比有序集的最大下标还要大，那么 Redis 将 stop 当作最大下标来处理。</li></ul><p> 可以通过使用 WITHSCORES 选项，来让成员和它的 score 值一并返回，返回列表以 value1,score1, …, valueN,scoreN 的格式表示。<br> 客户端库可能会返回一些更复杂的数据类型，比如数组、元组等。</p><h4 id="可用版本-4"><a href="#可用版本-4" class="headerlink" title="可用版本"></a>可用版本</h4><p>版本&gt;= 1.2.0</p><h4 id="时间复杂度-4"><a href="#时间复杂度-4" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><p>O(log(N)+M)， N 为有序集的基数，而 M 为结果集的基数。</p><h4 id="返回值-4"><a href="#返回值-4" class="headerlink" title="返回值"></a>返回值</h4><p>指定区间内，带有 score 值(可选)的有序集成员的列表。</p><h4 id="示例-4"><a href="#示例-4" class="headerlink" title="示例"></a>示例</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">redis &gt; ZRANGE salary 0 -1 WITHSCORES             # 显示整个有序集成员</div><div class="line">1) &quot;jack&quot;</div><div class="line">2) &quot;3500&quot;</div><div class="line">3) &quot;tom&quot;</div><div class="line">4) &quot;5000&quot;</div><div class="line">5) &quot;boss&quot;</div><div class="line">6) &quot;10086&quot;</div><div class="line">redis &gt; ZRANGE salary 1 2 WITHSCORES              # 显示有序集下标区间 1 至 2 的成员</div><div class="line">1) &quot;tom&quot;</div><div class="line">2) &quot;5000&quot;</div><div class="line">3) &quot;boss&quot;</div><div class="line">4) &quot;10086&quot;</div><div class="line">redis &gt; ZRANGE salary 0 200000 WITHSCORES         # 测试 end 下标超出最大下标时的情况</div><div class="line">1) &quot;jack&quot;</div><div class="line">2) &quot;3500&quot;</div><div class="line">3) &quot;tom&quot;</div><div class="line">4) &quot;5000&quot;</div><div class="line">5) &quot;boss&quot;</div><div class="line">6) &quot;10086&quot;</div><div class="line">redis &gt; ZRANGE salary 200000 3000000 WITHSCORES   # 测试当给定区间不存在于有序集时的情况</div><div class="line">(empty list or set)</div></pre></td></tr></table></figure><h3 id="ZRANGEBYSCORE"><a href="#ZRANGEBYSCORE" class="headerlink" title="ZRANGEBYSCORE"></a><strong>ZRANGEBYSCORE</strong></h3><p><strong>ZRANGEBYSCORE key min max [WITHSCORES] [LIMIT offset count]</strong></p><p> 返回有序集 key 中，所有 score 值介于 min 和 max 之间(包括等于 min 或 max )的成员。有序集成员按 score 值递增(从小到大)次序排列。<br> 具有相同 score 值的成员按字典序(lexicographical order)来排列(该属性是有序集提供的，不需要额外的计算)。<br> 可选的 LIMIT 参数指定返回结果的数量及区间(就像SQL中的 SELECT LIMIT offset, count )，注意当 offset 很大时，定位 offset 的操作可能需要遍历整个有序集，此过程最坏复杂度为 O(N) 时间。<br> 可选的 WITHSCORES 参数决定结果集是单单返回有序集的成员，还是将有序集成员及其 score 值一起返回。<br> 该选项自 Redis 2.0 版本起可用。</p><p><strong>区间及无限</strong></p><p> min 和 max 可以是 -inf 和 +inf ，这样一来，你就可以在不知道有序集的最低和最高 score 值的情况下，使用 ZRANGEBYSCORE 这类命令。<br> 默认情况下，区间的取值使用闭区间 (小于等于或大于等于)，你也可以通过给参数前增加 ( 符号来使用可选的开区间 (小于或大于)。</p><p><strong>举个例子</strong></p><p> ZRANGEBYSCORE zset (1 5  返回所有符合条件 1 &lt; score &lt;= 5 的成员，而<br> ZRANGEBYSCORE zset (5 (10 则返回所有符合条件 5 &lt; score &lt; 10 的成员。</p><h4 id="可用版本-5"><a href="#可用版本-5" class="headerlink" title="可用版本"></a>可用版本</h4><p>版本&gt;= 1.0.5</p><h4 id="时间复杂度-5"><a href="#时间复杂度-5" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><p>O(log(N)+M)， N 为有序集的基数， M 为被结果集的基数。</p><h4 id="返回值-5"><a href="#返回值-5" class="headerlink" title="返回值"></a>返回值</h4><p>指定区间内，带有 score 值(可选)的有序集成员的列表。</p><h4 id="示例-5"><a href="#示例-5" class="headerlink" title="示例"></a>示例</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">redis&gt; ZADD salary 2500 jack                        # 测试数据</div><div class="line">(integer) 0</div><div class="line">redis&gt; ZADD salary 5000 tom</div><div class="line">(integer) 0</div><div class="line">redis&gt; ZADD salary 12000 peter</div><div class="line">(integer) 0</div><div class="line">redis&gt; ZRANGEBYSCORE salary -inf +inf               # 显示整个有序集</div><div class="line">1) &quot;jack&quot;</div><div class="line">2) &quot;tom&quot;</div><div class="line">3) &quot;peter&quot;</div><div class="line">redis&gt; ZRANGEBYSCORE salary -inf +inf WITHSCORES    # 显示整个有序集及成员的 score 值</div><div class="line">1) &quot;jack&quot;</div><div class="line">2) &quot;2500&quot;</div><div class="line">3) &quot;tom&quot;</div><div class="line">4) &quot;5000&quot;</div><div class="line">5) &quot;peter&quot;</div><div class="line">6) &quot;12000&quot;</div><div class="line">redis&gt; ZRANGEBYSCORE salary -inf 5000 WITHSCORES    # 显示工资 &lt;=5000 的所有成员</div><div class="line">1) &quot;jack&quot;</div><div class="line">2) &quot;2500&quot;</div><div class="line">3) &quot;tom&quot;</div><div class="line">4) &quot;5000&quot;</div><div class="line">redis&gt; ZRANGEBYSCORE salary (5000 400000            # 显示工资大于 5000 小于等于 400000 的成员</div><div class="line">1) &quot;peter&quot;</div></pre></td></tr></table></figure><h3 id="ZRANK"><a href="#ZRANK" class="headerlink" title="ZRANK"></a><strong>ZRANK</strong></h3><p><strong>ZRANK key member</strong></p><p> 返回有序集 key 中成员 member 的排名。其中有序集成员按 score 值递增(从小到大)顺序排列。<br> 排名以 0 为底，也就是说， score 值最小的成员排名为 0 。<br> 使用 ZREVRANK 命令可以获得成员按 score 值递减(从大到小)排列的排名。</p><h4 id="可用版本-6"><a href="#可用版本-6" class="headerlink" title="可用版本"></a>可用版本</h4><p>版本&gt;= 2.0.0</p><h4 id="时间复杂度-6"><a href="#时间复杂度-6" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><p>O(log(N))</p><h4 id="返回值-6"><a href="#返回值-6" class="headerlink" title="返回值"></a>返回值</h4><p>如果 member 是有序集 key 的成员，返回 member 的排名。<br>如果 member 不是有序集 key 的成员，返回 nil 。</p><h4 id="示例-6"><a href="#示例-6" class="headerlink" title="示例"></a>示例</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">redis&gt; ZRANGE salary 0 -1 WITHSCORES        # 显示所有成员及其 score 值</div><div class="line">1) &quot;peter&quot;</div><div class="line">2) &quot;3500&quot;</div><div class="line">3) &quot;tom&quot;</div><div class="line">4) &quot;4000&quot;</div><div class="line">5) &quot;jack&quot;</div><div class="line">6) &quot;5000&quot;</div><div class="line">redis&gt; ZRANK salary tom                     # 显示 tom 的薪水排名，第二</div><div class="line">(integer) 1</div></pre></td></tr></table></figure><h3 id="ZREM"><a href="#ZREM" class="headerlink" title="ZREM"></a><strong>ZREM</strong></h3><p><strong>ZREM key member [member …]</strong></p><p> 移除有序集 key 中的一个或多个成员，不存在的成员将被忽略。<br> 当 key 存在但不是有序集类型时，返回一个错误。<br> 在 Redis 2.4 版本以前， ZREM 每次只能删除一个元素。</p><h4 id="可用版本-7"><a href="#可用版本-7" class="headerlink" title="可用版本"></a>可用版本</h4><blockquote><p>= 1.2.0</p><h4 id="时间复杂度-7"><a href="#时间复杂度-7" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><p>O(M*log(N))， N 为有序集的基数， M 为被成功移除的成员的数量。</p><h4 id="返回值-7"><a href="#返回值-7" class="headerlink" title="返回值"></a>返回值</h4><p>被成功移除的成员的数量，不包括被忽略的成员。</p><h4 id="示例-7"><a href="#示例-7" class="headerlink" title="示例"></a>示例</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"># 测试数据</div><div class="line">redis&gt; ZRANGE page_rank 0 -1 WITHSCORES</div><div class="line">1) &quot;bing.com&quot;</div><div class="line">2) &quot;8&quot;</div><div class="line">3) &quot;baidu.com&quot;</div><div class="line">4) &quot;9&quot;</div><div class="line">5) &quot;google.com&quot;</div><div class="line">6) &quot;10&quot;</div><div class="line"># 移除单个元素</div><div class="line">redis&gt; ZREM page_rank google.com</div><div class="line">(integer) 1</div><div class="line">redis&gt; ZRANGE page_rank 0 -1 WITHSCORES</div><div class="line">1) &quot;bing.com&quot;</div><div class="line">2) &quot;8&quot;</div><div class="line">3) &quot;baidu.com&quot;</div><div class="line">4) &quot;9&quot;</div><div class="line"># 移除多个元素</div><div class="line">redis&gt; ZREM page_rank baidu.com bing.com</div><div class="line">(integer) 2</div><div class="line">redis&gt; ZRANGE page_rank 0 -1 WITHSCORES</div><div class="line">(empty list or set)</div><div class="line"># 移除不存在元素</div><div class="line">redis&gt; ZREM page_rank non-exists-element</div><div class="line">(integer) 0</div></pre></td></tr></table></figure></blockquote><h3 id="ZREMRANGEBYRANK"><a href="#ZREMRANGEBYRANK" class="headerlink" title="ZREMRANGEBYRANK"></a><strong>ZREMRANGEBYRANK</strong></h3><p><strong>ZREMRANGEBYRANK key start stop</strong></p><p> 移除有序集 key 中，指定排名(rank)区间内的所有成员。<br> 区间分别以下标参数 start 和 stop 指出，包含 start 和 stop 在内。<br> 下标参数 start 和 stop 都以 0 为底，也就是说，以 0 表示有序集第一个成员，以 1 表示有序集第二个成员，以此类推。<br> 你也可以使用负数下标，以 -1 表示最后一个成员， -2 表示倒数第二个成员，以此类推。</p><h4 id="可用版本-8"><a href="#可用版本-8" class="headerlink" title="可用版本"></a>可用版本</h4><p>版本&gt;= 2.0.0</p><h4 id="时间复杂度-8"><a href="#时间复杂度-8" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><p>O(log(N)+M)， N 为有序集的基数，而 M 为被移除成员的数量。</p><h4 id="返回值-8"><a href="#返回值-8" class="headerlink" title="返回值"></a>返回值</h4><p>被移除成员的数量。</p><h4 id="示例-8"><a href="#示例-8" class="headerlink" title="示例"></a>示例</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">redis&gt; ZADD salary 2000 jack</div><div class="line">(integer) 1</div><div class="line">redis&gt; ZADD salary 5000 tom</div><div class="line">(integer) 1</div><div class="line">redis&gt; ZADD salary 3500 peter</div><div class="line">(integer) 1</div><div class="line">redis&gt; ZREMRANGEBYRANK salary 0 1       # 移除下标 0 至 1 区间内的成员</div><div class="line">(integer) 2</div><div class="line">redis&gt; ZRANGE salary 0 -1 WITHSCORES    # 有序集只剩下一个成员</div><div class="line">1) &quot;tom&quot;</div><div class="line">2) &quot;5000&quot;</div></pre></td></tr></table></figure><h3 id="ZREMRANGEBYSCORE"><a href="#ZREMRANGEBYSCORE" class="headerlink" title="ZREMRANGEBYSCORE"></a><strong>ZREMRANGEBYSCORE</strong></h3><p><strong>ZREMRANGEBYSCORE key min max</strong></p><p> 移除有序集 key 中，所有 score 值介于 min 和 max 之间(包括等于 min 或 max )的成员。<br> 自版本2.1.6开始， score 值等于 min 或 max 的成员也可以不包括在内，详情请参见 ZRANGEBYSCORE 命令。</p><h4 id="可用版本-9"><a href="#可用版本-9" class="headerlink" title="可用版本"></a>可用版本</h4><p>版本&gt;= 1.2.0</p><h4 id="时间复杂度-9"><a href="#时间复杂度-9" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><p>O(log(N)+M)， N 为有序集的基数，而 M 为被移除成员的数量。</p><h4 id="返回值-9"><a href="#返回值-9" class="headerlink" title="返回值"></a>返回值</h4><p>被移除成员的数量。</p><h4 id="示例-9"><a href="#示例-9" class="headerlink" title="示例"></a>示例</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">redis&gt; ZRANGE salary 0 -1 WITHSCORES          # 显示有序集内所有成员及其 score 值</div><div class="line">1) &quot;tom&quot;</div><div class="line">2) &quot;2000&quot;</div><div class="line">3) &quot;peter&quot;</div><div class="line">4) &quot;3500&quot;</div><div class="line">5) &quot;jack&quot;</div><div class="line">6) &quot;5000&quot;</div><div class="line">redis&gt; ZREMRANGEBYSCORE salary 1500 3500      # 移除所有薪水在 1500 到 3500 内的员工</div><div class="line">(integer) 2</div><div class="line">redis&gt; ZRANGE salary 0 -1 WITHSCORES          # 剩下的有序集成员</div><div class="line">1) &quot;jack&quot;</div><div class="line">2) &quot;5000&quot;</div></pre></td></tr></table></figure><h3 id="ZREVRANGE"><a href="#ZREVRANGE" class="headerlink" title="ZREVRANGE"></a><strong>ZREVRANGE</strong></h3><p><strong>ZREVRANGE key start stop [WITHSCORES]</strong></p><p> 返回有序集 key 中，指定区间内的成员。<br> 其中成员的位置按 score 值递减(从大到小)来排列。<br> 具有相同 score 值的成员按字典序的逆序(reverse lexicographical order)排列。<br> 除了成员按 score 值递减的次序排列这一点外， ZREVRANGE 命令的其他方面和 ZRANGE 命令一样。</p><h4 id="可用版本-10"><a href="#可用版本-10" class="headerlink" title="可用版本"></a>可用版本</h4><p>版本&gt;= 1.2.0</p><h4 id="时间复杂度-10"><a href="#时间复杂度-10" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><p>O(log(N)+M)， N 为有序集的基数，而 M 为结果集的基数。</p><h4 id="返回值-10"><a href="#返回值-10" class="headerlink" title="返回值"></a>返回值</h4><p>指定区间内，带有 score 值(可选)的有序集成员的列表。</p><h4 id="示例-10"><a href="#示例-10" class="headerlink" title="示例"></a>示例</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">redis&gt; ZRANGE salary 0 -1 WITHSCORES        # 递增排列</div><div class="line">1) &quot;peter&quot;</div><div class="line">2) &quot;3500&quot;</div><div class="line">3) &quot;tom&quot;</div><div class="line">4) &quot;4000&quot;</div><div class="line">5) &quot;jack&quot;</div><div class="line">6) &quot;5000&quot;</div><div class="line">redis&gt; ZREVRANGE salary 0 -1 WITHSCORES     # 递减排列</div><div class="line">1) &quot;jack&quot;</div><div class="line">2) &quot;5000&quot;</div><div class="line">3) &quot;tom&quot;</div><div class="line">4) &quot;4000&quot;</div><div class="line">5) &quot;peter&quot;</div><div class="line">6) &quot;3500&quot;</div></pre></td></tr></table></figure><h3 id="ZREVRANGEBYSCORE"><a href="#ZREVRANGEBYSCORE" class="headerlink" title="ZREVRANGEBYSCORE"></a><strong>ZREVRANGEBYSCORE</strong></h3><p><strong>ZREVRANGEBYSCORE key max min [WITHSCORES] [LIMIT offset count]</strong></p><p> 返回有序集 key 中， score 值介于 max 和 min 之间(默认包括等于 max 或 min )的所有的成员。有序集成员按 score 值递减(从大到小)的次序排列。<br> 具有相同 score 值的成员按字典序的逆序(reverse lexicographical order )排列。<br> 除了成员按 score 值递减的次序排列这一点外， ZREVRANGEBYSCORE 命令的其他方面和 ZRANGEBYSCORE 命令一样。</p><h4 id="可用版本-11"><a href="#可用版本-11" class="headerlink" title="可用版本"></a>可用版本</h4><p>版本&gt;= 2.2.0</p><h4 id="时间复杂度-11"><a href="#时间复杂度-11" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><p>O(log(N)+M)， N 为有序集的基数， M 为结果集的基数。</p><h4 id="返回值-11"><a href="#返回值-11" class="headerlink" title="返回值"></a>返回值</h4><p>指定区间内，带有 score 值(可选)的有序集成员的列表。</p><h4 id="示例-11"><a href="#示例-11" class="headerlink" title="示例"></a>示例</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">redis &gt; ZADD salary 10086 jack</div><div class="line">(integer) 1</div><div class="line">redis &gt; ZADD salary 5000 tom</div><div class="line">(integer) 1</div><div class="line">redis &gt; ZADD salary 7500 peter</div><div class="line">(integer) 1</div><div class="line">redis &gt; ZADD salary 3500 joe</div><div class="line">(integer) 1</div><div class="line">redis &gt; ZREVRANGEBYSCORE salary +inf -inf   # 逆序排列所有成员</div><div class="line">1) &quot;jack&quot;</div><div class="line">2) &quot;peter&quot;</div><div class="line">3) &quot;tom&quot;</div><div class="line">4) &quot;joe&quot;</div><div class="line">redis &gt; ZREVRANGEBYSCORE salary 10000 2000  # 逆序排列薪水介于 10000 和 2000 之间的成员</div><div class="line">1) &quot;peter&quot;</div><div class="line">2) &quot;tom&quot;</div><div class="line">3) &quot;joe&quot;</div></pre></td></tr></table></figure><h3 id="ZREVRANK"><a href="#ZREVRANK" class="headerlink" title="ZREVRANK"></a><strong>ZREVRANK</strong></h3><p><strong>ZREVRANK key member</strong></p><p> 返回有序集 key 中成员 member 的排名。其中有序集成员按 score 值递减(从大到小)排序。<br> 排名以 0 为底，也就是说， score 值最大的成员排名为 0 。<br> 使用 ZRANK 命令可以获得成员按 score 值递增(从小到大)排列的排名。</p><h4 id="可用版本-12"><a href="#可用版本-12" class="headerlink" title="可用版本"></a>可用版本</h4><p>版本&gt;= 2.0.0</p><h4 id="时间复杂度-12"><a href="#时间复杂度-12" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><p>O(log(N))</p><h4 id="返回值-12"><a href="#返回值-12" class="headerlink" title="返回值"></a>返回值</h4><p>如果 member 是有序集 key 的成员，返回 member 的排名。<br>如果 member 不是有序集 key 的成员，返回 nil 。</p><h4 id="示例-12"><a href="#示例-12" class="headerlink" title="示例"></a>示例</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">redis 127.0.0.1:6379&gt; ZRANGE salary 0 -1 WITHSCORES     # 测试数据</div><div class="line">1) &quot;jack&quot;</div><div class="line">2) &quot;2000&quot;</div><div class="line">3) &quot;peter&quot;</div><div class="line">4) &quot;3500&quot;</div><div class="line">5) &quot;tom&quot;</div><div class="line">6) &quot;5000&quot;</div><div class="line">redis&gt; ZREVRANK salary peter     # peter 的工资排第二</div><div class="line">(integer) 1</div><div class="line">redis&gt; ZREVRANK salary tom       # tom 的工资最高</div><div class="line">(integer) 0</div></pre></td></tr></table></figure><h3 id="ZSCORE"><a href="#ZSCORE" class="headerlink" title="ZSCORE"></a><strong>ZSCORE</strong></h3><p><strong>ZSCORE key member</strong></p><p> 返回有序集 key 中，成员 member 的 score 值。<br> 如果 member 元素不是有序集 key 的成员，或 key 不存在，返回 nil 。</p><h4 id="可用版本-13"><a href="#可用版本-13" class="headerlink" title="可用版本"></a>可用版本</h4><p>版本&gt;= 1.2.0</p><h4 id="时间复杂度-13"><a href="#时间复杂度-13" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><p>O(1)</p><h4 id="返回值-13"><a href="#返回值-13" class="headerlink" title="返回值"></a>返回值</h4><p>member 成员的 score 值，以字符串形式表示。</p><h4 id="示例-13"><a href="#示例-13" class="headerlink" title="示例"></a>示例</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">redis&gt; ZRANGE salary 0 -1 WITHSCORES    # 测试数据</div><div class="line">1) &quot;tom&quot;</div><div class="line">2) &quot;2000&quot;</div><div class="line">3) &quot;peter&quot;</div><div class="line">4) &quot;3500&quot;</div><div class="line">5) &quot;jack&quot;</div><div class="line">6) &quot;5000&quot;</div><div class="line">redis&gt; ZSCORE salary peter              # 注意返回值是字符串</div><div class="line">&quot;3500&quot;</div></pre></td></tr></table></figure><h3 id="ZUNIONSTORE"><a href="#ZUNIONSTORE" class="headerlink" title="ZUNIONSTORE"></a><strong>ZUNIONSTORE</strong></h3><p><strong>ZUNIONSTORE destination numkeys key [key …] [WEIGHTS weight [weight …]] [AGGREGATE SUM|MIN|MAX]</strong></p><p> 计算给定的一个或多个有序集的并集，其中给定 key 的数量必须以 numkeys 参数指定，并将该并集(结果集)储存到 destination 。<br> 默认情况下，结果集中某个成员的 score 值是所有给定集下该成员 score 值之 和 。</p><p><strong>WEIGHTS</strong></p><p> 使用 WEIGHTS 选项，你可以为 每个 给定有序集 分别 指定一个乘法因子(multiplication factor)，每个给定有序集的所有成员的 score 值在传递给聚合函数(aggregation function)之前都要先乘以该有序集的因子。<br> 如果没有指定 WEIGHTS 选项，乘法因子默认设置为 1 。</p><p><strong>AGGREGATE</strong></p><p> 使用 AGGREGATE 选项，你可以指定并集的结果集的聚合方式。<br> 默认使用的参数 SUM ，可以将所有集合中某个成员的 score 值之 和 作为结果集中该成员的 score 值；使用参数 MIN ，可以将所有集合中某个成员的 最小 score 值作为结果集中该成员的 score 值；而参数 MAX 则是将所有集合中某个成员的 最大 score 值作为结果集中该成员的 score 值。</p><h4 id="可用版本-14"><a href="#可用版本-14" class="headerlink" title="可用版本"></a>可用版本</h4><p>版本&gt;= 2.0.0</p><h4 id="时间复杂度-14"><a href="#时间复杂度-14" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><p>O(N)+O(M log(M))， N 为给定有序集基数的总和， M 为结果集的基数。</p><h4 id="返回值-14"><a href="#返回值-14" class="headerlink" title="返回值"></a>返回值</h4><p>保存到 destination 的结果集的基数。</p><h4 id="示例-14"><a href="#示例-14" class="headerlink" title="示例"></a>示例</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">redis&gt; ZRANGE programmer 0 -1 WITHSCORES</div><div class="line">1) &quot;peter&quot;</div><div class="line">2) &quot;2000&quot;</div><div class="line">3) &quot;jack&quot;</div><div class="line">4) &quot;3500&quot;</div><div class="line">5) &quot;tom&quot;</div><div class="line">6) &quot;5000&quot;</div><div class="line">redis&gt; ZRANGE manager 0 -1 WITHSCORES</div><div class="line">1) &quot;herry&quot;</div><div class="line">2) &quot;2000&quot;</div><div class="line">3) &quot;mary&quot;</div><div class="line">4) &quot;3500&quot;</div><div class="line">5) &quot;bob&quot;</div><div class="line">6) &quot;4000&quot;</div><div class="line">redis&gt; ZUNIONSTORE salary 2 programmer manager WEIGHTS 1 3   # 公司决定加薪。。。除了程序员。。。</div><div class="line">(integer) 6</div><div class="line">redis&gt; ZRANGE salary 0 -1 WITHSCORES</div><div class="line">1) &quot;peter&quot;</div><div class="line">2) &quot;2000&quot;</div><div class="line">3) &quot;jack&quot;</div><div class="line">4) &quot;3500&quot;</div><div class="line">5) &quot;tom&quot;</div><div class="line">6) &quot;5000&quot;</div><div class="line">7) &quot;herry&quot;</div><div class="line">8) &quot;6000&quot;</div><div class="line">9) &quot;mary&quot;</div><div class="line">10) &quot;10500&quot;</div><div class="line">11) &quot;bob&quot;</div><div class="line">12) &quot;12000&quot;</div></pre></td></tr></table></figure><h3 id="ZINTERSTORE"><a href="#ZINTERSTORE" class="headerlink" title="ZINTERSTORE"></a><strong>ZINTERSTORE</strong></h3><p><strong>ZINTERSTORE destination numkeys key [key …] [WEIGHTS weight [weight …]] [AGGREGATE SUM|MIN|MAX]</strong></p><p> 计算给定的一个或多个有序集的交集，其中给定 key 的数量必须以 numkeys 参数指定，并将该交集(结果集)储存到 destination 。<br> 默认情况下，结果集中某个成员的 score 值是所有给定集下该成员 score 值之和.<br> 关于 WEIGHTS 和 AGGREGATE 选项的描述，参见 ZUNIONSTORE 命令。</p><h4 id="可用版本-15"><a href="#可用版本-15" class="headerlink" title="可用版本"></a>可用版本</h4><p>版本&gt;= 2.0.0</p><h4 id="时间复杂度-15"><a href="#时间复杂度-15" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><p>O(N<em>K)+O(M</em>log(M))， N 为给定 key 中基数最小的有序集， K 为给定有序集的数量， M 为结果集的基数。</p><h4 id="返回值-15"><a href="#返回值-15" class="headerlink" title="返回值"></a>返回值</h4><p>保存到 destination 的结果集的基数。</p><h4 id="示例-15"><a href="#示例-15" class="headerlink" title="示例"></a>示例</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">redis &gt; ZADD mid_test 70 &quot;Li Lei&quot;</div><div class="line">(integer) 1</div><div class="line">redis &gt; ZADD mid_test 70 &quot;Han Meimei&quot;</div><div class="line">(integer) 1</div><div class="line">redis &gt; ZADD mid_test 99.5 &quot;Tom&quot;</div><div class="line">(integer) 1</div><div class="line">redis &gt; ZADD fin_test 88 &quot;Li Lei&quot;</div><div class="line">(integer) 1</div><div class="line">redis &gt; ZADD fin_test 75 &quot;Han Meimei&quot;</div><div class="line">(integer) 1</div><div class="line">redis &gt; ZADD fin_test 99.5 &quot;Tom&quot;</div><div class="line">(integer) 1</div><div class="line">redis &gt; ZINTERSTORE sum_point 2 mid_test fin_test</div><div class="line">(integer) 3</div><div class="line">redis &gt; ZRANGE sum_point 0 -1 WITHSCORES     # 显示有序集内所有成员及其 score 值</div><div class="line">1) &quot;Han Meimei&quot;</div><div class="line">2) &quot;145&quot;</div><div class="line">3) &quot;Li Lei&quot;</div><div class="line">4) &quot;158&quot;</div><div class="line">5) &quot;Tom&quot;</div><div class="line">6) &quot;199&quot;</div></pre></td></tr></table></figure><h3 id="ZSCAN"><a href="#ZSCAN" class="headerlink" title="ZSCAN"></a><strong>ZSCAN</strong></h3><p><strong>ZSCAN key cursor [MATCH pattern] [COUNT count]</strong></p><p> 详细信息请参考 SCAN 命令。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;有序集合和散列一样，都用于存储键值对：有序集合的键被称为成员（member），每个成员都是各不相同；而有序集合的值则被称为分值（score），分值必须为浮点数。有序集合是Redis里面唯一一个既可以根据成员访问元素（这一点和散列一样），又可以根据分值以及分值的排列顺序来访问元素的结构。字符串成员（member）与浮点数分值（score）之间的有序映射，元素的排列顺序由分值的大小决定。&lt;br&gt;结构的读写：&lt;br&gt; 添加、获取、删除单个元素&lt;br&gt; 根据分值范围（range）或者成员来获取元素&lt;br&gt;
    
    </summary>
    
      <category term="Redis" scheme="http://yoursite.com/categories/Redis/"/>
    
    
      <category term="Redis" scheme="http://yoursite.com/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>精通Hibernate</title>
    <link href="http://yoursite.com/2017/03/01/%E7%B2%BE%E9%80%9Ahibernate/"/>
    <id>http://yoursite.com/2017/03/01/精通hibernate/</id>
    <published>2017-03-01T13:02:25.000Z</published>
    <updated>2017-09-28T08:24:37.614Z</updated>
    
    <content type="html"><![CDATA[<p>   今天去公司上班了，公司后台框架是hibernate+springMvc,虽然之前看过hibernate，但是没有在实际的开发过程中用到，很多都忘记了，就准备看孙卫琴的《精通Hibernate》。</p><a id="more"></a><h2 id="Java对象持久化技术概论"><a href="#Java对象持久化技术概论" class="headerlink" title="Java对象持久化技术概论"></a>Java对象持久化技术概论</h2><p>从不同的角度解释hibernate：</p><ul><li>它是连接Java应用程序和关系数据库的中间件。</li><li>它对JDBC API进行了封装，负责Java的持久化。</li><li>在分层软件架构中它位于持久化层，封装了所有数据访问细节，使业务逻辑层可以专注与实现业务逻辑。</li><li>它是一只ORM映射工具，能够建立面向对象的域模型和关系数据模型之间的映射。</li></ul><p>本章介绍软件的三种模型：概念模型、域模型和数据模型，然后介绍了Java对象的持久化概念，并介绍了实现对象持久化的几种模式：</p><ul><li>业务逻辑和数据访问耦合</li><li>主动域对象模式</li><li>ORM模式</li><li>JDO模式</li><li>CMP模式</li></ul><h3 id="应用程序的分层体系结构"><a href="#应用程序的分层体系结构" class="headerlink" title="应用程序的分层体系结构"></a>应用程序的分层体系结构</h3><p>四层结构应用软件的结构。</p><ul><li>表述层：提供与用户交互的界面。GUI(图形用户界面)和web页面而是表述层的两个典型的例子。</li><li>业务逻辑层：实现各种业务逻辑。例如当用户发出生产订单的请求时，业务逻辑层负责计算的价格、验证订单的信息。</li><li>持久层：封装数据访问细节，为业务逻辑提供了面向对象的API</li><li>数据库层：负责存放和管理应用的持久性业务数据。例如对于电子商务网站应用，在数据库中保存了客户、订单和商品等业务数据。关系数据库依然是目前最流行的数据库。</li></ul><h4 id="软件分层的优点"><a href="#软件分层的优点" class="headerlink" title="软件分层的优点"></a>软件分层的优点</h4><p>恰当地为软件分层，将会提高软件的以下性能。</p><ul><li>伸缩性：伸缩性指应用程序是否能支持更多的用户。</li><li>可维护性：当发生需求变化，只需修改软件的某一部分，不会影响其他部分的代码。层次越多，可维护性也会不断提高，因为修改软件的某一部分的实现，不会影响其它层。</li><li>可扩展性：是在现有的系统中增加新功能的难易程度。层数越少，添加新功能就越容易破坏现有的程序结构。层数越多，就可以在每个层次中提供扩展点，不会打破应用的整体框架。</li><li>可重复性：程序代码有冗余，同一个程序就能满足多种需求。</li><li>可管理性：管理系统的难易程度。将应用程序分为多层后，可以将工作分解给不同的开发小组，从而便于管理。应用越复杂，规模越大，需要的层就越多。</li></ul><h4 id="软件分层的缺点"><a href="#软件分层的缺点" class="headerlink" title="软件分层的缺点"></a>软件分层的缺点</h4><ul><li>软件分层越多，对软件设计人员的要求就越高。</li><li>在设计阶段，必须花时间构思合理的体系结构。</li><li>开发流程相对复杂，降低开发效率。</li></ul><h4 id="Java应用的持久化层"><a href="#Java应用的持久化层" class="headerlink" title="Java应用的持久化层"></a>Java应用的持久化层</h4><h3 id="Hibernate-API简介"><a href="#Hibernate-API简介" class="headerlink" title="Hibernate API简介"></a>Hibernate API简介</h3><p>hibernate中的接口可分为以下几类：</p><ul><li>提供访问数据库的操作（如保存、更新、删除和查询对象）的接口。这些接口包括：Session、Transaction和Quer接口。</li><li>用于配置Hibernate的接口：Configuration。</li><li>回调接口，使应用程序接受Hibernate内部发生的事件，并做出相应的回应。这些接口包括：Interceptor、Lifecycle和Validatable接口。</li><li>用于扩展Hibernate的功能的接口，如UserType、CompositeUserType和IdentifierGenerator接口，如果需要的话，应用程序可以扩展这些接口。</li></ul><h2 id="Hibernate入门"><a href="#Hibernate入门" class="headerlink" title="Hibernate入门"></a>Hibernate入门</h2><p>Hibernate是Java应用和关系型数据库之间的桥梁，内部封装了通过JDBC访问数据库的操作，向上层应用提供了面向对象的数据访问API。在Java应用中使用hibernate包含以下步骤。</p><ul><li>创建Hibernate的配置文件。</li><li>创建持久化类。</li><li>创建对象-关系映射文件。</li><li>通过HibernateAPI编写访问数据库的代码。</li></ul><h3 id="创建Hibernate的配置文件"><a href="#创建Hibernate的配置文件" class="headerlink" title="创建Hibernate的配置文件"></a>创建Hibernate的配置文件</h3><p>hibernate的配置文件中读取了数据库连接的有关信息，有两种形式：一种是XML格式文件；还有一种是Java属性文件，采用“健=值”的形式。<br>配置文件的属性：<br>hibernate.properties</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">hibernate.dialect=net.sf.hibernate.dialect.MySQLDialct //指定数据库使用SQL方言</div><div class="line">hibernate.connection.driver_class=com.mysql.jdbc.Driver //指定数据库的驱动程序</div><div class="line">hibernate.connection.url=jdbc:mysql://localhost:3306/SAMPLEDB //指定数据库的URL</div><div class="line">hibernate.connection.username=root //指定数据库的连接名</div><div class="line">hibernate.connection.password=root //指定数据库的口令</div><div class="line">hibernate.show_sql=ture //是否在控制台输出SQL语句</div></pre></td></tr></table></figure><h3 id="创建持久化类"><a href="#创建持久化类" class="headerlink" title="创建持久化类"></a>创建持久化类</h3><p>持久化类是指其实例需要被Hibernate持久化到数据库中的类。持久化类通常都是域模型中的实体域类。持久化类符合JavaBean的规范，包含一些属性，以及与之对应的getXXX()和setXXX()方法。下列中定义了一个名为Customer的持久化类。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">package mypack;</div><div class="line"></div><div class="line">import java.io.Serializable;</div><div class="line">import java.sql.Date;</div><div class="line">import java.sql.Timestamp;</div><div class="line"></div><div class="line">public class Customer implements Serializable &#123;</div><div class="line">-</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>持久化类符合JavaBean的规范，包含一些属性，以及与之对应的getXXX()和setXXX()方法。getXXX()和setXXX()方法必须符合特定的命名规范，”get”和”set”后面紧跟属性的名字，并且属性名的首字母为大写，例如name属性的getName(),如果把get方法写为getname()或者getNANE(),会导致Hibernate在运行时抛出以下的异常：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">net.sf.hibernate.PropertNotFountException:Could not find a getter for property name in class mypack.Customer</div></pre></td></tr></table></figure><p>如果为boolean类型可以用isXXX()或者getXXX().<br>Hibernate并不要求持久化类必须实现java.io.Serializable接口，但是对于采用分布式结构的Java应用，当Java对象在不同的进程点之间传输时，这个对象所属的类必须实现Serializable接口，此外，在Java web应用中，如果希望对HttpSession中存放的Java对象进行持久化，那么这个Java对象所属的类也必须实现Serializable接口。<br>Customer持久化类有一个id属性，用来唯一标识Customer类的每个属性。在面向对象术语中，这个id属性称为对象标识符(OID,Object Identifier)。通常为整数也可以为其他类型。<br>Hibernate要求持久化类必须提供一个不带参数的默认构造方法，在程序运行时，Hibernate运用Java反射机制，调用java.lang.reflenct.Constructor.newInstance()方法来构造持久化的实例。如果对这个持久化类使用延迟检索策略，为了使Hibernate能够在运行时为这个持久化类创建动态代理，要求持久化类的默认构造方法的访问级别必须是public或protected类型，而不是default 或private类型。<br>在Customer类中没有引入任何Hibernate API，Customer类不需要继承Hibernate的类或者实现Hibernate的接口，这提高了持久化类的独立性。</p><h3 id="创建数据库Schema"><a href="#创建数据库Schema" class="headerlink" title="创建数据库Schema"></a>创建数据库Schema</h3><p>下面为Customer类对应的数据库表名为CUSTOMERS，它在MySQL数据库中的DDL定义如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">create table CUSTOMERS(</div><div class="line"> ID bigint not null primary key,</div><div class="line"> NAME varchar(15) not null,</div><div class="line"> EMAIL varchar(128) not null,</div><div class="line"> PASSWORD varchar(8) not null,</div><div class="line"> PHONE int,</div><div class="line"> ADDRESS varchar(255),</div><div class="line"> SEX char(1),</div><div class="line"> IS_MARRIED bit,</div><div class="line"> DESCRIPTION text,</div><div class="line"> IMAGE blob,</div><div class="line"> BIRTHDAY date,</div><div class="line"> REGISTERED_TIME timestamp</div><div class="line">);</div></pre></td></tr></table></figure><h3 id="创建对象-关系映射文件"><a href="#创建对象-关系映射文件" class="headerlink" title="创建对象-关系映射文件"></a>创建对象-关系映射文件</h3><p>Hibernate采用XML格式的文件来指定对象和关系数据之间的映射。在运行时，Hibernate将根据这个映射文件来生成各种SQL语句。下面的Customer.hbm.xml把Customer类映射到CUSTOMERS表：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version=&quot;1.0&quot;?&gt;</div><div class="line">&lt;!DOCTYPE hibernate-mapping PUBLIC &quot;-//Hibernate/Hibernate Mapping DTD 2.0//EN&quot;</div><div class="line">&quot;http://hibernate.sourceforge.net/hibernate-mapping-2.0.dtd&quot;&gt; </div><div class="line">&lt;hibernate-mapping&gt;</div><div class="line">&lt;class name=&quot;mypack.Customer&quot; table=&quot;CUSTOMERS&quot;&gt;</div><div class="line">&lt;id name=&quot;id&quot; column=&quot;ID&quot; type=&quot;long&quot;&gt;&lt;generator class=&quot;increment&quot;/&gt;&lt;/id&gt;</div><div class="line">&lt;property name=&quot;name&quot; column=&quot;NAME&quot; type=&quot;string&quot; not-null=&quot;true&quot;/&gt;</div><div class="line">&lt;property name=&quot;email&quot; column=&quot;EMAIL&quot; type=&quot;string&quot; not-null=&quot;true&quot;/&gt;</div><div class="line">&lt;property name=&quot;password&quot; column=&quot;PASSWORD&quot; type=&quot;string&quot; not-null=&quot;true&quot;/&gt;</div><div class="line">&lt;property name=&quot;phone&quot; column=&quot;PHONE&quot; type=&quot;int&quot;/&gt;</div><div class="line">&lt;property name=&quot;address&quot; column=&quot;ADDRESS&quot; type=&quot;string&quot;/&gt;</div><div class="line">&lt;property name=&quot;sex&quot; column=&quot;SEX&quot; type=&quot;character&quot;/&gt;</div><div class="line">&lt;property name=&quot;married&quot; column=&quot;IS_MARRIED&quot; type=&quot;boolean&quot;/&gt;</div><div class="line">&lt;property name=&quot;description&quot; column=&quot;DESCRIPTION&quot; type=&quot;text&quot;/&gt;</div><div class="line">&lt;property name=&quot;image&quot; column=&quot;IMAGE&quot; type=&quot;binary&quot;/&gt;</div><div class="line">&lt;property name=&quot;birthday&quot; column=&quot;BIRTHDAY&quot; type=&quot;date&quot;/&gt;</div><div class="line">&lt;property name=&quot;registeredTime&quot; column=&quot;REGISTEREDTIME&quot; type=&quot;timestamp&quot;/&gt;</div><div class="line">&lt;/class&gt;</div><div class="line">&lt;/hibernate-mapping&gt;</div></pre></td></tr></table></figure><h4 id="映射文件的文档类型定义（DTD）"><a href="#映射文件的文档类型定义（DTD）" class="headerlink" title="映射文件的文档类型定义（DTD）"></a>映射文件的文档类型定义（DTD）</h4><p>Customer.hbm.xml文件的开头定义声明DTD（Document Type Definition,文档类型定义），它对XML文件的语法和格式做了定义。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;   今天去公司上班了，公司后台框架是hibernate+springMvc,虽然之前看过hibernate，但是没有在实际的开发过程中用到，很多都忘记了，就准备看孙卫琴的《精通Hibernate》。&lt;/p&gt;
    
    </summary>
    
      <category term="Hibernate" scheme="http://yoursite.com/categories/Hibernate/"/>
    
    
      <category term="Hibernate" scheme="http://yoursite.com/tags/Hibernate/"/>
    
  </entry>
  
</feed>
