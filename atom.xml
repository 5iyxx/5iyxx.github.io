<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>5IYXX</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2017-06-22T12:31:49.282Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Eric Chen</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Nginx</title>
    <link href="http://yoursite.com/2017/06/22/Red%20Hat%207%20%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"/>
    <id>http://yoursite.com/2017/06/22/Red Hat 7 环境配置/</id>
    <published>2017-06-22T12:04:50.000Z</published>
    <updated>2017-06-22T12:31:49.282Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Red-Hat-7-安装后环境配置"><a href="#Red-Hat-7-安装后环境配置" class="headerlink" title="Red Hat 7 安装后环境配置"></a>Red Hat 7 安装后环境配置</h2><a id="more"></a><h3 id="配置静态的ip地址"><a href="#配置静态的ip地址" class="headerlink" title="配置静态的ip地址"></a>配置静态的ip地址</h3><ul><li>查看系统的使用的网卡<br><code>ifconfig</code> 我本地网卡为eno16777736</li><li>打开配置文件<br><code>vi /etc/sysconfig/network-scripts/ifcfg-eno16777736</code></li><li>静态ip设置，需要根据自己的网络参数修改配置文件<br><code>BOOTPROTO=static</code> 指定地址的获取方式<br><code>IPADDR=192.168.0.225</code> ip地址<br><code>NETMASK=255.255.255.0</code> 子网掩码<br><code>GATEWAY=192.168.0.1</code> 网关</li><li>重启服务<br><code>systemctl  restart network</code></li><li>ping测试<br><code>ping 8.8.8.8</code><br><code>PING 8.8.8.8 (8.8.8.8) 56(84) bytes of data.</code><br><code>64 bytes from 8.8.8.8: icmp_seq=1 ttl=45 time=241 ms</code><br>测试如上结果，成功！</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Red-Hat-7-安装后环境配置&quot;&gt;&lt;a href=&quot;#Red-Hat-7-安装后环境配置&quot; class=&quot;headerlink&quot; title=&quot;Red Hat 7 安装后环境配置&quot;&gt;&lt;/a&gt;Red Hat 7 安装后环境配置&lt;/h2&gt;
    
    </summary>
    
      <category term="operations" scheme="http://yoursite.com/categories/operations/"/>
    
    
      <category term="Linux" scheme="http://yoursite.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Spring中每个jar包的作用</title>
    <link href="http://yoursite.com/2017/03/10/spring%E4%B8%AD%E6%AF%8F%E4%B8%AAjar%E5%8C%85%E7%9A%84%E4%BD%9C%E7%94%A8/"/>
    <id>http://yoursite.com/2017/03/10/spring中每个jar包的作用/</id>
    <published>2017-03-10T01:43:50.000Z</published>
    <updated>2017-09-25T17:52:44.989Z</updated>
    
    <content type="html"><![CDATA[<p>一个工程需要很多个关于spring的jar包，下面详细说明每个jar的作用。</p><a id="more"></a><p><strong>spring.jar</strong><br>包含有完整发布模块的单个jar 包。但是不包括mock.jar, aspects.jar, spring-portlet.jar, and spring-hibernate2.jar。</p><p><strong>spring-src.zip就是所有的源代码压缩包。</strong></p><p>除了spring.jar 文件，Spring 还包括有其它21 个独立的jar 包，各自包含着对应的Spring组件，用户可以根据自己的需要来选择组合自己的jar 包，而不必引入整个spring.jar 的所有类文件。</p><h4 id="spring-core-jar"><a href="#spring-core-jar" class="headerlink" title="spring-core.jar"></a>spring-core.jar</h4><p>这个jar 文件包含Spring 框架基本的核心工具类。Spring 其它组件要都要使用到这个包里的类，是其它组件的基本核心，当然你也可以在自己的应用系统中使用这些工具类。<br>外部依赖Commons Logging， (Log4J)。</p><h4 id="spring-beans-jar"><a href="#spring-beans-jar" class="headerlink" title="spring-beans.jar"></a>spring-beans.jar</h4><p>这个jar 文件是所有应用都要用到的，它包含访问配置文件、创建和管理bean 以及进行Inversion of Control / Dependency Injection（IoC/DI）操作相关的所有类。如果应用只需基本的IoC/DI 支持，引入spring-core.jar 及spring-beans.jar 文件就可以了。<br>外部依赖spring-core，(CGLIB)。</p><h4 id="spring-aop-jar"><a href="#spring-aop-jar" class="headerlink" title="spring-aop.jar"></a>spring-aop.jar</h4><p>这个jar 文件包含在应用中使用Spring 的AOP 特性时所需的类和源码级元数据支持。使用基于AOP 的Spring特性，如声明型事务管理（Declarative Transaction Management），也要在应用里包含这个jar包。<br>外部依赖spring-core， (spring-beans，AOP Alliance， CGLIB，Commons Attributes)。</p><h4 id="spring-context-jar"><a href="#spring-context-jar" class="headerlink" title="spring-context.jar"></a>spring-context.jar</h4><p>这个jar 文件为Spring 核心提供了大量扩展。可以找到使用Spring ApplicationContext特性时所需的全部类，JDNI 所需的全部类，instrumentation组件以及校验Validation 方面的相关类。<br>外部依赖spring-beans, (spring-aop)。</p><h4 id="spring-dao-jar"><a href="#spring-dao-jar" class="headerlink" title="spring-dao.jar"></a>spring-dao.jar</h4><p>这个jar 文件包含Spring DAO、Spring Transaction 进行数据访问的所有类。为了使用声明型事务支持，还需在自己的应用里包含spring-aop.jar。<br>外部依赖spring-core，(spring-aop， spring-context， JTA API)。</p><h4 id="spring-jdbc-jar"><a href="#spring-jdbc-jar" class="headerlink" title="spring-jdbc.jar"></a>spring-jdbc.jar</h4><p>这个jar 文件包含对Spring 对JDBC 数据访问进行封装的所有类。<br>外部依赖spring-beans，spring-dao。</p><h4 id="spring-support-jar"><a href="#spring-support-jar" class="headerlink" title="spring-support.jar"></a>spring-support.jar</h4><p>这个jar 文件包含支持UI模版（Velocity，FreeMarker，JasperReports），邮件服务，脚本服务(JRuby)，缓存Cache（EHCache），任务计划Scheduling（uartz）方面的类。<br>外部依赖spring-context, (spring-jdbc, Velocity, FreeMarker, JasperReports, BSH, Groovy, JRuby, Quartz, EHCache)</p><h4 id="spring-web-jar"><a href="#spring-web-jar" class="headerlink" title="spring-web.jar"></a>spring-web.jar</h4><p>这个jar 文件包含Web 应用开发时，用到Spring 框架时所需的核心类，包括自动载入Web Application Context 特性的类、Struts 与JSF 集成类、文件上传的支持类、Filter 类和大量工具辅助类。<br>外部依赖spring-context, Servlet API, (JSP API, JSTL, Commons FileUpload, COS)。</p><h4 id="spring-webmvc-jar"><a href="#spring-webmvc-jar" class="headerlink" title="spring-webmvc.jar"></a>spring-webmvc.jar</h4><p>这个jar 文件包含Spring MVC 框架相关的所有类。包括框架的Servlets，Web MVC框架，控制器和视图支持。当然，如果你的应用使用了独立的MVC 框架，则无需这个JAR 文件里的任何类。<br>外部依赖spring-web, (spring-support，Tiles，iText，POI)。</p><h4 id="spring-portlet-jar"><a href="#spring-portlet-jar" class="headerlink" title="spring-portlet.jar"></a>spring-portlet.jar</h4><p>spring自己实现的一个类似Spring MVC的框架。包括一个MVC框架和控制器。<br>外部依赖spring-web， Portlet API，(spring-webmvc)。</p><h4 id="spring-struts-jar"><a href="#spring-struts-jar" class="headerlink" title="spring-struts.jar"></a>spring-struts.jar</h4><p>Struts框架支持，可以更方便更容易的集成Struts框架。<br>外部依赖spring-web，Struts。</p><h4 id="spring-remoting-jar"><a href="#spring-remoting-jar" class="headerlink" title="spring-remoting.jar"></a>spring-remoting.jar</h4><p>这个jar 文件包含支持EJB、远程调用Remoting（RMI、Hessian、Burlap、Http Invoker、JAX-RPC）方面的类。<br>外部依赖spring-aop， (spring-context，spring-web，Hessian，Burlap，JAX-RPC，EJB API)。</p><h4 id="spring-jmx-jar"><a href="#spring-jmx-jar" class="headerlink" title="spring-jmx.jar"></a>spring-jmx.jar</h4><p>这个jar包提供了对JMX 1.0/1.2的支持类。<br>外部依赖spring-beans，spring-aop， JMX API。</p><h4 id="spring-jms-jar"><a href="#spring-jms-jar" class="headerlink" title="spring-jms.jar"></a>spring-jms.jar</h4><p>这个jar包提供了对JMS 1.0.2/1.1的支持类。<br>外部依赖spring-beans，spring-dao，JMS API。</p><h4 id="spring-jca-jar"><a href="#spring-jca-jar" class="headerlink" title="spring-jca.jar"></a>spring-jca.jar</h4><p>对JCA 1.0的支持。<br>外部依赖spring-beans，spring-dao， JCA API。</p><h4 id="spring-jdo-jar"><a href="#spring-jdo-jar" class="headerlink" title="spring-jdo.jar"></a>spring-jdo.jar</h4><p>对JDO 1.0/2.0的支持。<br>外部依赖spring-jdbc， JDO API， (spring-web)。</p><h4 id="spring-jpa-jar"><a href="#spring-jpa-jar" class="headerlink" title="spring-jpa.jar"></a>spring-jpa.jar</h4><p>对JPA 1.0的支持。<br>外部依赖spring-jdbc， JPA API， (spring-web)。</p><h4 id="spring-hibernate2-jar"><a href="#spring-hibernate2-jar" class="headerlink" title="spring-hibernate2.jar"></a>spring-hibernate2.jar</h4><p>对Hibernate 2.1的支持，已经不建议使用。<br>外部依赖spring-jdbc，Hibernate2，(spring-web)。</p><h4 id="spring-hibernate3-jar"><a href="#spring-hibernate3-jar" class="headerlink" title="spring-hibernate3.jar"></a>spring-hibernate3.jar</h4><p>对Hibernate 3.0/3.1/3.2的支持。<br>外部依赖spring-jdbc，Hibernate3，(spring-web)。</p><h4 id="spring-toplink-jar"><a href="#spring-toplink-jar" class="headerlink" title="spring-toplink.jar"></a>spring-toplink.jar</h4><p>对TopLink框架的支持。<br>外部依赖spring-jdbc，TopLink。</p><h4 id="spring-ibatis-jar"><a href="#spring-ibatis-jar" class="headerlink" title="spring-ibatis.jar"></a>spring-ibatis.jar</h4><p>对iBATIS SQL Maps的支持。<br>外部依赖spring-jdbc，iBATIS SQL Maps。</p><p>另外的两个包。</p><h4 id="spring-mock-jar"><a href="#spring-mock-jar" class="headerlink" title="spring-mock.jar"></a>spring-mock.jar</h4><p>这个jar 文件包含Spring 一整套mock 类来辅助应用的测试。Spring 测试套件使用了其中大量mock 类，这样测试就更加简单。模拟HttpServletRequest 和HttpServletResponse 类在Web 应用单元测试是很方便的。并且提供了对JUnit的支持。<br>外部依赖spring-core。</p><h4 id="spring-aspects-jar"><a href="#spring-aspects-jar" class="headerlink" title="spring-aspects.jar"></a>spring-aspects.jar</h4><p>提供对AspectJ的支持，以便可以方便的将面向方面的功能集成进IDE中，比如Eclipse AJDT。<br>外部依赖。</p><p>WEAVER JARS (dist/weavers)说明。</p><h4 id="spring-agent-jar"><a href="#spring-agent-jar" class="headerlink" title="spring-agent.jar"></a>spring-agent.jar</h4><p>Spring的InstrumentationSavingAgent (为InstrumentationLoadTimeWeaver)，一个设备代理包，可以参考JDK1.5的Instrumentation功能获得更多信息。<br>外部依赖none (for use at JVM startup: “-javaagent:spring-agent.jar”)。</p><h4 id="spring-tomcat-weaver-jar"><a href="#spring-tomcat-weaver-jar" class="headerlink" title="spring-tomcat-weaver.jar"></a>spring-tomcat-weaver.jar</h4><p>扩展Tomcat的ClassLoader，使其可以使用instrumentation（设备）类。<br>外部依赖none (for deployment into Tomcat’s “server/lib” directory)。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一个工程需要很多个关于spring的jar包，下面详细说明每个jar的作用。&lt;/p&gt;
    
    </summary>
    
      <category term="Spring" scheme="http://yoursite.com/categories/Spring/"/>
    
    
      <category term="blog" scheme="http://yoursite.com/tags/blog/"/>
    
  </entry>
  
  <entry>
    <title>Jar包添加到maven本地仓库</title>
    <link href="http://yoursite.com/2017/03/07/Jar%E5%8C%85%E6%B7%BB%E5%8A%A0%E5%88%B0maven%E6%9C%AC%E5%9C%B0%E4%BB%93%E5%BA%93/"/>
    <id>http://yoursite.com/2017/03/07/Jar包添加到maven本地仓库/</id>
    <published>2017-03-07T15:02:25.000Z</published>
    <updated>2017-09-25T17:55:32.331Z</updated>
    
    <content type="html"><![CDATA[<p> maven在应用的过程中，有 maven在应用的过程中，有些jar包在仓库上面是没法找到的，这需要我们自己手动导入到仓库中，些jar包在仓库上面是没法找到的，这需要我们自己手动导入到仓库中。</p><a id="more"></a><h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><p>zxing-3.21.jar是根据github上面项目<a href="https://github.com/zxing" target="_blank" rel="external">ZXing Project</a>自己生成的jar包，该包主要应用于二维码生成，下面讲述怎么把怎么把zxing-3.21.jar添加到本地的maven仓库中。</p><h3 id="环境要求"><a href="#环境要求" class="headerlink" title="环境要求"></a>环境要求</h3><p>需要配置JDK和maven环境，完成后以管理员身份打开命令提示符窗口(cmd),再输入下面相关的语法。</p><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">mvn install:install-file -Dfile=jar包的位置(参数一) -DgroupId=groupId(参数二) -DartifactId=artifactId(参数三) -Dversion=version(参数四) -Dpackaging=jar</div><div class="line"></div><div class="line">eg:</div><div class="line">mvn install:install-file -Dfile=&quot;C:\Users\eric\Desktop\zxing\3.21\zxing-3.21.jar&quot; -DgroupId=com.eric -DartifactId=zxing -Dversion=3.21 -Dpackaging=jar</div><div class="line"></div><div class="line">result：</div><div class="line">[INFO] Scanning for projects...</div><div class="line">[INFO]</div><div class="line">[INFO] ------------------------------------------------------------------------</div><div class="line">[INFO] Building Maven Stub Project (No POM) 1</div><div class="line">[INFO] ------------------------------------------------------------------------</div><div class="line">[INFO]</div><div class="line">[INFO] --- maven-install-plugin:2.4:install-file (default-cli) @ standalone-pom ---</div><div class="line">[INFO] Installing C:\Users\eric\Desktop\zxing\3.21\zxing-3.21.jar to C:\Users\eric\.m2\repository\com\eric\zxing\3.21\zxing-3.21.jar</div><div class="line">[INFO] Installing C:\Users\eric\AppData\Local\Temp\mvninstall6543969167446403883.pom to C:\Users\eric\.m2\repository\com\eric\zxing\3.21\zxing-3.21.pom</div><div class="line">[INFO] ------------------------------------------------------------------------</div><div class="line">[INFO] BUILD SUCCESS</div><div class="line">[INFO] ------------------------------------------------------------------------</div><div class="line">[INFO] Total time: 0.836 s</div><div class="line">[INFO] Finished at: 2017-03-08T00:24:12+08:00</div><div class="line">[INFO] Final Memory: 7M/117M</div><div class="line">[INFO] ------------------------------------------------------------------------</div><div class="line">(添加成功！)</div></pre></td></tr></table></figure><p><strong>注意：地址+jar包名,即C:\Users\eric\Desktop\zxing\3.21\zxing-3.21.jar要加引号””,”参数二\参数三\参数四”这也是jar包在仓库中的地址。</strong></p><h3 id="查看生成的依赖"><a href="#查看生成的依赖" class="headerlink" title="查看生成的依赖"></a>查看生成的依赖</h3><p>查看添加的zxing-3.21.jar的dependency</p><ul><li>通过设置的对应参数获取.即</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">-DgroupId=groupId(参数二) -DartifactId=artifactId(参数三) -Dversion=version(参数四)</div></pre></td></tr></table></figure><ul><li>参看本地仓库中pom文件C:\Users\eric.m2\repository\com\eric\zxing\3.21\zxing-3.21.pom，可以看到:</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;groupId&gt;com.eric&lt;/groupId&gt;</div><div class="line">&lt;artifactId&gt;zxing&lt;/artifactId&gt;</div><div class="line">&lt;version&gt;3.21&lt;/version&gt;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt; maven在应用的过程中，有 maven在应用的过程中，有些jar包在仓库上面是没法找到的，这需要我们自己手动导入到仓库中，些jar包在仓库上面是没法找到的，这需要我们自己手动导入到仓库中。&lt;/p&gt;
    
    </summary>
    
      <category term="maven" scheme="http://yoursite.com/categories/maven/"/>
    
    
      <category term="blog" scheme="http://yoursite.com/tags/blog/"/>
    
  </entry>
  
  <entry>
    <title>Java核心技术</title>
    <link href="http://yoursite.com/2017/03/06/Java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF/"/>
    <id>http://yoursite.com/2017/03/06/Java核心技术/</id>
    <published>2017-03-06T15:02:25.000Z</published>
    <updated>2017-03-08T09:38:05.969Z</updated>
    
    <content type="html"><![CDATA[<p>   CayS.Horstmann等编著的《Java核心技术》(CoreJava)自第1版出版以来，一直备受广大Java程序设计人员的青睐，畅销不衰，是Java经典书籍。第8版针对JavaSE6平台进行了全面更新，囊括了Java平台标准版(JavaSE/J2SE)的全部基础知识，提供了大量完整且具有实际意义的应用实例，详细介绍了Java语言基础知识、面向对象程序设计、接口与内部类、事件监听器模型、swing图形用户界面程序设计、打包应用程序、异常处理、登录与调试、泛型程序设计、集合框架、多线程等内容。</p><a id="more"></a>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;   CayS.Horstmann等编著的《Java核心技术》(CoreJava)自第1版出版以来，一直备受广大Java程序设计人员的青睐，畅销不衰，是Java经典书籍。第8版针对JavaSE6平台进行了全面更新，囊括了Java平台标准版(JavaSE/J2SE)的全部基础知识，提供了大量完整且具有实际意义的应用实例，详细介绍了Java语言基础知识、面向对象程序设计、接口与内部类、事件监听器模型、swing图形用户界面程序设计、打包应用程序、异常处理、登录与调试、泛型程序设计、集合框架、多线程等内容。&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="Book" scheme="http://yoursite.com/tags/Book/"/>
    
  </entry>
  
  <entry>
    <title>精通Hibernate</title>
    <link href="http://yoursite.com/2017/03/01/%E7%B2%BE%E9%80%9Ahibernate/"/>
    <id>http://yoursite.com/2017/03/01/精通hibernate/</id>
    <published>2017-03-01T13:02:25.000Z</published>
    <updated>2017-03-09T11:57:09.451Z</updated>
    
    <content type="html"><![CDATA[<p>   今天去公司上班了，公司后台框架是hibernate+springMvc,虽然之前看过hibernate，但是没有在实际的开发过程中用到，很多都忘记了，就准备看孙卫琴的《精通Hibernate》。</p><a id="more"></a><h2 id="Java对象持久化技术概论"><a href="#Java对象持久化技术概论" class="headerlink" title="Java对象持久化技术概论"></a>Java对象持久化技术概论</h2><p>从不同的角度解释hibernate：</p><ul><li>它是连接Java应用程序和关系数据库的中间件。</li><li>它对JDBC API进行了封装，负责Java的持久化。</li><li>在分层软件架构中它位于持久化层，封装了所有数据访问细节，使业务逻辑层可以专注与实现业务逻辑。</li><li>它是一只ORM映射工具，能够建立面向对象的域模型和关系数据模型之间的映射。</li></ul><p>本章介绍软件的三种模型：概念模型、域模型和数据模型，然后介绍了Java对象的持久化概念，并介绍了实现对象持久化的几种模式：</p><ul><li>业务逻辑和数据访问耦合</li><li>主动域对象模式</li><li>ORM模式</li><li>JDO模式</li><li>CMP模式</li></ul><h3 id="应用程序的分层体系结构"><a href="#应用程序的分层体系结构" class="headerlink" title="应用程序的分层体系结构"></a>应用程序的分层体系结构</h3><p>四层结构应用软件的结构。</p><ul><li>表述层：提供与用户交互的界面。GUI(图形用户界面)和web页面而是表述层的两个典型的例子。</li><li>业务逻辑层：实现各种业务逻辑。例如当用户发出生产订单的请求时，业务逻辑层负责计算的价格、验证订单的信息。</li><li>持久层：封装数据访问细节，为业务逻辑提供了面向对象的API</li><li>数据库层：负责存放和管理应用的持久性业务数据。例如对于电子商务网站应用，在数据库中保存了客户、订单和商品等业务数据。关系数据库依然是目前最流行的数据库。</li></ul><h4 id="软件分层的优点"><a href="#软件分层的优点" class="headerlink" title="软件分层的优点"></a>软件分层的优点</h4><p>恰当地为软件分层，将会提高软件的以下性能。</p><ul><li>伸缩性：伸缩性指应用程序是否能支持更多的用户。</li><li>可维护性：当发生需求变化，只需修改软件的某一部分，不会影响其他部分的代码。层次越多，可维护性也会不断提高，因为修改软件的某一部分的实现，不会影响其它层。</li><li>可扩展性：是在现有的系统中增加新功能的难易程度。层数越少，添加新功能就越容易破坏现有的程序结构。层数越多，就可以在每个层次中提供扩展点，不会打破应用的整体框架。</li><li>可重复性：程序代码有冗余，同一个程序就能满足多种需求。</li><li>可管理性：管理系统的难易程度。将应用程序分为多层后，可以将工作分解给不同的开发小组，从而便于管理。应用越复杂，规模越大，需要的层就越多。</li></ul><h4 id="软件分层的缺点"><a href="#软件分层的缺点" class="headerlink" title="软件分层的缺点"></a>软件分层的缺点</h4><ul><li>软件分层越多，对软件设计人员的要求就越高。</li><li>在设计阶段，必须花时间构思合理的体系结构。</li><li>开发流程相对复杂，降低开发效率。</li></ul><h4 id="Java应用的持久化层"><a href="#Java应用的持久化层" class="headerlink" title="Java应用的持久化层"></a>Java应用的持久化层</h4><h3 id="Hibernate-API简介"><a href="#Hibernate-API简介" class="headerlink" title="Hibernate API简介"></a>Hibernate API简介</h3><p>hibernate中的接口可分为以下几类：</p><ul><li>提供访问数据库的操作（如保存、更新、删除和查询对象）的接口。这些接口包括：Session、Transaction和Quer接口。</li><li>用于配置Hibernate的接口：Configuration。</li><li>回调接口，使应用程序接受Hibernate内部发生的事件，并做出相应的回应。这些接口包括：Interceptor、Lifecycle和Validatable接口。</li><li>用于扩展Hibernate的功能的接口，如UserType、CompositeUserType和IdentifierGenerator接口，如果需要的话，应用程序可以扩展这些接口。</li></ul><h2 id="Hibernate入门"><a href="#Hibernate入门" class="headerlink" title="Hibernate入门"></a>Hibernate入门</h2><p>Hibernate是Java应用和关系型数据库之间的桥梁，内部封装了通过JDBC访问数据库的操作，向上层应用提供了面向对象的数据访问API。在Java应用中使用hibernate包含以下步骤。</p><ul><li>创建Hibernate的配置文件。</li><li>创建持久化类。</li><li>创建对象-关系映射文件。</li><li>通过HibernateAPI编写访问数据库的代码。</li></ul><h3 id="创建Hibernate的配置文件"><a href="#创建Hibernate的配置文件" class="headerlink" title="创建Hibernate的配置文件"></a>创建Hibernate的配置文件</h3><p>hibernate的配置文件中读取了数据库连接的有关信息，有两种形式：一种是XML格式文件；还有一种是Java属性文件，采用“健=值”的形式。<br>配置文件的属性：<br>hibernate.properties</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">hibernate.dialect=net.sf.hibernate.dialect.MySQLDialct //指定数据库使用SQL方言</div><div class="line">hibernate.connection.driver_class=com.mysql.jdbc.Driver //指定数据库的驱动程序</div><div class="line">hibernate.connection.url=jdbc:mysql://localhost:3306/SAMPLEDB //指定数据库的URL</div><div class="line">hibernate.connection.username=root //指定数据库的连接名</div><div class="line">hibernate.connection.password=root //指定数据库的口令</div><div class="line">hibernate.show_sql=ture //是否在控制台输出SQL语句</div></pre></td></tr></table></figure><h3 id="创建持久化类"><a href="#创建持久化类" class="headerlink" title="创建持久化类"></a>创建持久化类</h3><p>持久化类是指其实例需要被Hibernate持久化到数据库中的类。持久化类通常都是域模型中的实体域类。持久化类符合JavaBean的规范，包含一些属性，以及与之对应的getXXX()和setXXX()方法。下列中定义了一个名为Customer的持久化类。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">package mypack;</div><div class="line"></div><div class="line">import java.io.Serializable;</div><div class="line">import java.sql.Date;</div><div class="line">import java.sql.Timestamp;</div><div class="line"></div><div class="line">public class Customer implements Serializable &#123;</div><div class="line">-</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>持久化类符合JavaBean的规范，包含一些属性，以及与之对应的getXXX()和setXXX()方法。getXXX()和setXXX()方法必须符合特定的命名规范，”get”和”set”后面紧跟属性的名字，并且属性名的首字母为大写，例如name属性的getName(),如果把get方法写为getname()或者getNANE(),会导致Hibernate在运行时抛出以下的异常：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">net.sf.hibernate.PropertNotFountException:Could not find a getter for property name in class mypack.Customer</div></pre></td></tr></table></figure><p>如果为boolean类型可以用isXXX()或者getXXX().<br>Hibernate并不要求持久化类必须实现java.io.Serializable接口，但是对于采用分布式结构的Java应用，当Java对象在不同的进程点之间传输时，这个对象所属的类必须实现Serializable接口，此外，在Java web应用中，如果希望对HttpSession中存放的Java对象进行持久化，那么这个Java对象所属的类也必须实现Serializable接口。<br>Customer持久化类有一个id属性，用来唯一标识Customer类的每个属性。在面向对象术语中，这个id属性称为对象标识符(OID,Object Identifier)。通常为整数也可以为其他类型。<br>Hibernate要求持久化类必须提供一个不带参数的默认构造方法，在程序运行时，Hibernate运用Java反射机制，调用java.lang.reflenct.Constructor.newInstance()方法来构造持久化的实例。如果对这个持久化类使用延迟检索策略，为了使Hibernate能够在运行时为这个持久化类创建动态代理，要求持久化类的默认构造方法的访问级别必须是public或protected类型，而不是default 或private类型。<br>在Customer类中没有引入任何Hibernate API，Customer类不需要继承Hibernate的类或者实现Hibernate的接口，这提高了持久化类的独立性。</p><h3 id="创建数据库Schema"><a href="#创建数据库Schema" class="headerlink" title="创建数据库Schema"></a>创建数据库Schema</h3><p>下面为Customer类对应的数据库表名为CUSTOMERS，它在MySQL数据库中的DDL定义如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">create table CUSTOMERS(</div><div class="line"> ID bigint not null primary key,</div><div class="line"> NAME varchar(15) not null,</div><div class="line"> EMAIL varchar(128) not null,</div><div class="line"> PASSWORD varchar(8) not null,</div><div class="line"> PHONE int,</div><div class="line"> ADDRESS varchar(255),</div><div class="line"> SEX char(1),</div><div class="line"> IS_MARRIED bit,</div><div class="line"> DESCRIPTION text,</div><div class="line"> IMAGE blob,</div><div class="line"> BIRTHDAY date,</div><div class="line"> REGISTERED_TIME timestamp</div><div class="line">);</div></pre></td></tr></table></figure><h3 id="创建对象-关系映射文件"><a href="#创建对象-关系映射文件" class="headerlink" title="创建对象-关系映射文件"></a>创建对象-关系映射文件</h3><p>Hibernate采用XML格式的文件来指定对象和关系数据之间的映射。在运行时，Hibernate将根据这个映射文件来生成各种SQL语句。下面的Customer.hbm.xml把Customer类映射到CUSTOMERS表：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version=&quot;1.0&quot;?&gt;</div><div class="line">&lt;!DOCTYPE hibernate-mapping PUBLIC &quot;-//Hibernate/Hibernate Mapping DTD 2.0//EN&quot;</div><div class="line">&quot;http://hibernate.sourceforge.net/hibernate-mapping-2.0.dtd&quot;&gt; </div><div class="line">&lt;hibernate-mapping&gt;</div><div class="line">&lt;class name=&quot;mypack.Customer&quot; table=&quot;CUSTOMERS&quot;&gt;</div><div class="line">&lt;id name=&quot;id&quot; column=&quot;ID&quot; type=&quot;long&quot;&gt;&lt;generator class=&quot;increment&quot;/&gt;&lt;/id&gt;</div><div class="line">&lt;property name=&quot;name&quot; column=&quot;NAME&quot; type=&quot;string&quot; not-null=&quot;true&quot;/&gt;</div><div class="line">&lt;property name=&quot;email&quot; column=&quot;EMAIL&quot; type=&quot;string&quot; not-null=&quot;true&quot;/&gt;</div><div class="line">&lt;property name=&quot;password&quot; column=&quot;PASSWORD&quot; type=&quot;string&quot; not-null=&quot;true&quot;/&gt;</div><div class="line">&lt;property name=&quot;phone&quot; column=&quot;PHONE&quot; type=&quot;int&quot;/&gt;</div><div class="line">&lt;property name=&quot;address&quot; column=&quot;ADDRESS&quot; type=&quot;string&quot;/&gt;</div><div class="line">&lt;property name=&quot;sex&quot; column=&quot;SEX&quot; type=&quot;character&quot;/&gt;</div><div class="line">&lt;property name=&quot;married&quot; column=&quot;IS_MARRIED&quot; type=&quot;boolean&quot;/&gt;</div><div class="line">&lt;property name=&quot;description&quot; column=&quot;DESCRIPTION&quot; type=&quot;text&quot;/&gt;</div><div class="line">&lt;property name=&quot;image&quot; column=&quot;IMAGE&quot; type=&quot;binary&quot;/&gt;</div><div class="line">&lt;property name=&quot;birthday&quot; column=&quot;BIRTHDAY&quot; type=&quot;date&quot;/&gt;</div><div class="line">&lt;property name=&quot;registeredTime&quot; column=&quot;REGISTEREDTIME&quot; type=&quot;timestamp&quot;/&gt;</div><div class="line">&lt;/class&gt;</div><div class="line">&lt;/hibernate-mapping&gt;</div></pre></td></tr></table></figure><h4 id="映射文件的文档类型定义（DTD）"><a href="#映射文件的文档类型定义（DTD）" class="headerlink" title="映射文件的文档类型定义（DTD）"></a>映射文件的文档类型定义（DTD）</h4><p>Customer.hbm.xml文件的开头定义声明DTD（Document Type Definition,文档类型定义），它对XML文件的语法和格式做了定义。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;   今天去公司上班了，公司后台框架是hibernate+springMvc,虽然之前看过hibernate，但是没有在实际的开发过程中用到，很多都忘记了，就准备看孙卫琴的《精通Hibernate》。&lt;/p&gt;
    
    </summary>
    
      <category term="hibernate" scheme="http://yoursite.com/categories/hibernate/"/>
    
    
  </entry>
  
  <entry>
    <title>MySQL数据库常见面试题目</title>
    <link href="http://yoursite.com/2017/02/20/MySQL%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98%E7%9B%AE/"/>
    <id>http://yoursite.com/2017/02/20/MySQL常见面试题目/</id>
    <published>2017-02-20T13:02:25.000Z</published>
    <updated>2017-02-21T07:57:50.713Z</updated>
    
    <content type="html"><![CDATA[<p>   在准备面试，就在网上收集了一些MySQL面试题目。</p><a id="more"></a><h3 id="如何登陆mysql数据库"><a href="#如何登陆mysql数据库" class="headerlink" title="如何登陆mysql数据库"></a>如何登陆mysql数据库</h3><p>MySQL -u username -p</p><h3 id="如何开启-关闭mysql服务"><a href="#如何开启-关闭mysql服务" class="headerlink" title="如何开启/关闭mysql服务"></a>如何开启/关闭mysql服务</h3><p>service mysql start/stop</p><h3 id="查看mysql的状态"><a href="#查看mysql的状态" class="headerlink" title="查看mysql的状态"></a>查看mysql的状态</h3><p>service mysql status</p><h3 id="如何显示数所有数据库"><a href="#如何显示数所有数据库" class="headerlink" title="如何显示数所有数据库"></a>如何显示数所有数据库</h3><p>show databases</p><h3 id="如何获取表内所有字段对象的名称和类型"><a href="#如何获取表内所有字段对象的名称和类型" class="headerlink" title="如何获取表内所有字段对象的名称和类型"></a>如何获取表内所有字段对象的名称和类型</h3><p>describe table_name;</p><h3 id="MYSQL支持事务吗？"><a href="#MYSQL支持事务吗？" class="headerlink" title="MYSQL支持事务吗？"></a>MYSQL支持事务吗？</h3><p>在缺省模式下，MYSQL是autocommit模式的，所有的数据库更新操作都会即时提交，所以在缺省情况下，mysql是不支持事务的。<br>但是如果你的MYSQL表类型是使用InnoDB Tables 或 BDB tables的话，你的MYSQL就可以使用事务处理,使用SET AUTOCOMMIT=0就可以使MYSQL允许在非autocommit模式，在非autocommit模式下，你必须使用COMMIT来提交你的更改，或者用ROLLBACK来回滚你的更改。<br>示例如下：<br>START TRANSACTION;<br>SELECT @A:=SUM(salary) FROM table1 WHERE type=1;<br>UPDATE table2 SET summmary=@A WHERE type=1;<br>COMMIT;</p><h3 id="MYSQL相比于其他数据库有哪些特点？"><a href="#MYSQL相比于其他数据库有哪些特点？" class="headerlink" title="MYSQL相比于其他数据库有哪些特点？"></a>MYSQL相比于其他数据库有哪些特点？</h3><p>MySQL是一个小型关系型数据库管理系统，开发者为瑞典MySQL AB公司，现在已经被Sun公司收购，支持FreeBSD、Linux、MAC、Windows等多种操作系统与其他的大型数据库例如Oracle、DB2、SQL Server等相比功能稍弱一些<br>1、可以处理拥有上千万条记录的大型数据<br>2、支持常见的SQL语句规范<br>3、可移植行高，安装简单小巧<br>4、良好的运行效率，有丰富信息的网络支持<br>5、调试、管理，优化简单（相对其他大型数据库）</p><h3 id="varchar和char的区别"><a href="#varchar和char的区别" class="headerlink" title="varchar和char的区别"></a>varchar和char的区别</h3><p>Char是一种固定长度的类型，varchar是一种可变长度的类型</p><h3 id="数据库事物有哪几种？"><a href="#数据库事物有哪几种？" class="headerlink" title="数据库事物有哪几种？"></a>数据库事物有哪几种？</h3><p>隔离性、持续性、一致性、原子性</p><h3 id="请简洁地描述下MySQL中InnoDB支持的四种事务隔离级别名称，以及逐级之间的区别？"><a href="#请简洁地描述下MySQL中InnoDB支持的四种事务隔离级别名称，以及逐级之间的区别？" class="headerlink" title="请简洁地描述下MySQL中InnoDB支持的四种事务隔离级别名称，以及逐级之间的区别？"></a>请简洁地描述下MySQL中InnoDB支持的四种事务隔离级别名称，以及逐级之间的区别？</h3><p>SQL标准定义的四个隔离级别为：<br>read uncommited：读取未提交内容<br>read committed：读取提交内容<br>repeatable read：可重读<br>serializable：可串行化<br>详细解释如下：<br>Read Uncommitted（读取未提交内容）<br>在该隔离级别，所有事务都可以看到其他未提交事务的执行结果。本隔离级别很少用于实际应用，因为它的性能也不比其他级别好多少。读取未提交的数据，也被称之为脏读（Dirty Read）。<br>Read Committed（读取提交内容）<br>这是大多数数据库系统的默认隔离级别（但不是MySQL默认的）。它满足了隔离的简单定义：一个事务只能看见已经提交事务所做的改变。这种隔离级别也支持所谓的不可重复读（Nonrepeatable Read），因为同一事务的其他实例在该实例处理其间可能会有新的commit，所以同一select可能返回不同结果。<br>Repeatable Read（可重读）<br>这是MySQL的默认事务隔离级别，它确保同一事务的多个实例在并发读取数据时，会看到同样的数据行。不过理论上，这会导致另一个棘手的问题：幻读（Phantom Read）。简单的说，幻读指当用户读取某一范围的数据行时，另一个事务又在该范围内插入了新行，当用户再读取该范围的数据行时，会发现有新的“幻影” 行。InnoDB和Falcon存储引擎通过多版本并发控制（MVCC，Multiversion Concurrency Control 间隙锁）机制解决了该问题。注：其实多版本只是解决不可重复读问题，而加上间隙锁（也就是它这里所谓的并发控制）才解决了幻读问题。<br>Serializable（可串行化）<br>这是最高的隔离级别，它通过强制事务排序，使之不可能相互冲突，从而解决幻读问题。简言之，它是在每个读的数据行上加上共享锁。在这个级别，可能导致大量的超时现象和锁竞争。<br>对于不同的事务，采用不同的隔离级别分别有不同的结果。不同的隔离级别有不同的现象。主要有下面3种现在：<br>1、脏读（dirty read）：一个事务可以读取另一个尚未提交事务的修改数据。<br>2、非重复读（nonrepeatable read）：在同一个事务中，同一个查询在T1时间读取某一行，在T2时间重新读取这一行时候，这一行的数据已经发生修改，可能被更新了（update），也可能被删除了（delete）。<br>3、幻像读（phantom read）：在同一事务中，同一查询多次进行时候，由于其他插入操作（insert）的事务提交，导致每次返回不同的结果集。<br>不同的隔离级别有不同的现象，并有不同的锁定/并发机制，隔离级别越高，数据库的并发性就越差，4种事务隔离级别分别表现的现象如下表：<br>这里写图片描述</p><h3 id="mysql数据库引擎MyISAM和InnoDB的区别"><a href="#mysql数据库引擎MyISAM和InnoDB的区别" class="headerlink" title="mysql数据库引擎MyISAM和InnoDB的区别"></a>mysql数据库引擎MyISAM和InnoDB的区别</h3><p>这里写图片描述</p><h3 id="mysql有关权限的表都有哪几个"><a href="#mysql有关权限的表都有哪几个" class="headerlink" title="mysql有关权限的表都有哪几个"></a>mysql有关权限的表都有哪几个</h3><p>MySQL服务器通过权限表来控制用户对数据库的访问，权限表存放在mysql数据库里，由mysql_install_db脚本初始化。这些权限表分别user，db，table_priv，columns_priv和host。下面分别介绍一下这些表的结构和内容：<br>user权限表：记录允许连接到服务器的用户帐号信息，里面的权限是全局级的。<br>db权限表：记录各个帐号在各个数据库上的操作权限。<br>table_priv权限表：记录数据表级的操作权限。<br>columns_priv权限表：记录数据列级的操作权限。<br>host权限表：配合db权限表对给定主机上数据库级操作权限作更细致的控制。这个权限表不受GRANT和REVOKE语句的影响。</p><h3 id="mysql存储引擎有哪些？如何修改mysql存储引擎？"><a href="#mysql存储引擎有哪些？如何修改mysql存储引擎？" class="headerlink" title="mysql存储引擎有哪些？如何修改mysql存储引擎？"></a>mysql存储引擎有哪些？如何修改mysql存储引擎？</h3><p>MyISAM indexed sequential access method (有索引的顺序访问方法)<br>MyISAM 具有检查和修复表格的大多数工具。表格可以被压缩，而且支持全文收索<br>不是事务安全的，而且不支持外键。<br>MEMORY 也是以前的(HEAP) 该类型表存储在内存中，表的索引是哈希分布的。<br>merge 这些表为了查询目的，把myisam 表集合作为单个表，因此你可以在某些操作系统中避开最大文件大小的限制。<br>archive 这种类型的表只支持，insert ,select 不支持delete,update,replace ,不使用索引。<br>csv 这些表保存在服务器的单个文件中，它包含了用逗号间隔的数据。</p><p>innodb 这种表是事务安全的。提供了commit（提交） rollback（实务回滚）支持外键，比myisam慢。<br>修改mysql存储引擎alter table tablename type = innodb;</p><h3 id="MYSQL-数据表修复及数据恢复面试题"><a href="#MYSQL-数据表修复及数据恢复面试题" class="headerlink" title="MYSQL 数据表修复及数据恢复面试题"></a>MYSQL 数据表修复及数据恢复面试题</h3><p>MYSQL数据表在什么情况下容易损坏？<br>服务器突然断电导致数据文件损坏。<br>强制关机，没有先关闭mysql 服务等。<br>数据表损坏后的主要现象是什么？<br>从表中选择数据之时，得到如下错误：Incorrect key file for table: ‘…’. Try to repair it<br>查询不能在表中找到行或返回不完全的数据。<br>Error: Table ‘p’ is marked as crashed and should be repaired 。<br>打开表失败： Can’t open file: ‘×××.MYI’ (errno: 145) 。<br>数据表损坏的修复方式有哪些？<br>使用 myisamchk 来修复，具体步骤：<br>1）修复前将mysql服务停止。<br>2）打开命令行方式，然后进入到mysql的/bin目录。<br>3）执行myisamchk –recover 数据库所在路径/*.MYI<br>使用repair table 或者 OPTIMIZE table命令来修复，REPAIR TABLE table_name 修复表 OPTIMIZE TABLE table_name 优化表 REPAIR TABLE 用于修复被破坏的表。<br>OPTIMIZE TABLE 用于回收闲置的数据库空间，当表上的数据行被删除时，所占据的磁盘空间并没有立即被回收，使用了OPTIMIZE TABLE命令后这些空间将被回收，并且对磁盘上的数据行进行重排（注意：是磁盘上，而非数据库）</p><h3 id="MYSQL数据库服务器性能分析的方法命令有哪些"><a href="#MYSQL数据库服务器性能分析的方法命令有哪些" class="headerlink" title="MYSQL数据库服务器性能分析的方法命令有哪些?"></a>MYSQL数据库服务器性能分析的方法命令有哪些?</h3><p>Show status<br>一些值得监控的变量值：<br>Bytes_received和Bytes<em>sent<br>和服务器之间来往的流量。<br>Com</em><em>服务器正在执行的命令。<br>Created_</em>在查询执行期限间创建的临时表和文件。<br>Handler<em>*存储引擎操作。<br>Select</em><em>不同类型的联接执行计划。<br>Sort_</em>几种排序信息。<br>Show session status like ‘Select’;<br>Show profiles<br>SET profiling=1;<br>Show profiles\G<br>Show profile;</p><h3 id="mysql里记录货币用什么字段类型好"><a href="#mysql里记录货币用什么字段类型好" class="headerlink" title="mysql里记录货币用什么字段类型好"></a>mysql里记录货币用什么字段类型好</h3><p>NUMERIC和DECIMAL类型被MySQL实现为同样的类型，这在SQL92标准允许。他们被用于保存值，该值的准确精度是极其重要的值，例如与金钱有关的数据。当声明一个类是这些类型之一时，精度和规模的能被(并且通常是)指定；例如：<br>salary DECIMAL(9,2)<br>在这个例子中，9(precision)代表将被用于存储值的总的小数位数，而2(scale)代表将被用于存储小数点后的位数。因此，在这种情况下，能被存储在salary列中的值的范围是从-9999999.99到9999999.99。在ANSI/ISO SQL92中，句法DECIMAL(p)等价于DECIMAL(p,0)。同样，句法DECIMAL等价于DECIMAL(p,0)，这里实现被允许决定值p。MySQL当前不支持DECIMAL/NUMERIC数据类型的这些变种形式的任一种。这一般说来不是一个严重的问题，因为这些类型的主要益处得自于明显地控制精度和规模的能力。<br>DECIMAL和NUMERIC值作为字符串存储，而不是作为二进制浮点数，以便保存那些值的小数精度。一个字符用于值的每一位、小数点(如果scale&gt;0)和“-”符号(对于负值)。如果scale是0，DECIMAL和NUMERIC值不包含小数点或小数部分。<br>DECIMAL和NUMERIC值得最大的范围与DOUBLE一样，但是对于一个给定的DECIMAL或NUMERIC列，实际的范围可由制由给定列的precision或scale限制。当这样的列赋给了小数点后面的位超过指定scale所允许的位的值，该值根据scale四舍五入。当一个DECIMAL或NUMERIC列被赋给了其大小超过指定(或缺省的）precision和scale隐含的范围的值，MySQL存储表示那个范围的相应的端点值。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;   在准备面试，就在网上收集了一些MySQL面试题目。&lt;/p&gt;
    
    </summary>
    
      <category term="Database" scheme="http://yoursite.com/categories/Database/"/>
    
    
      <category term="MySQL" scheme="http://yoursite.com/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>Mybatis</title>
    <link href="http://yoursite.com/2017/02/12/Mybatis%E5%85%A5%E9%97%A8/"/>
    <id>http://yoursite.com/2017/02/12/Mybatis入门/</id>
    <published>2017-02-12T13:02:25.000Z</published>
    <updated>2017-09-25T17:51:49.006Z</updated>
    
    <content type="html"><![CDATA[<p>   初学mybatis。</p><a id="more"></a><h2 id="SqlSession"><a href="#SqlSession" class="headerlink" title="SqlSession"></a>SqlSession</h2><p>SqlSession的作用：</p><ul><li>向SQL语句传入参数</li><li>执行SQL语句</li><li>获取执行SQL语句的结果</li><li>事务的控制</li></ul><p>如何得到SqlSession:</p><ul><li>通过配置文件获取数据库连接相关信息</li><li>通过配置信息构建SqlSessionFactory</li><li>通过SqlSessionFactory打开数据库会话<h2 id="各层分工"><a href="#各层分工" class="headerlink" title="各层分工"></a>各层分工</h2>servlet 负责接收页面的值，向页面传值，如果有相应的业务逻辑需要处理，则调用相应service层。<br>service 负责接收servlet传过来的值，并做执行处理，业务的操作、算法等等，如果有需要要调用相应的dao层。<br>dao 完成与数据库的交互，执行相应的sql语句<br>bean 对象</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;   初学mybatis。&lt;/p&gt;
    
    </summary>
    
      <category term="Mybatis" scheme="http://yoursite.com/categories/Mybatis/"/>
    
    
      <category term="Mybatis" scheme="http://yoursite.com/tags/Mybatis/"/>
    
  </entry>
  
  <entry>
    <title>Nginx</title>
    <link href="http://yoursite.com/2017/02/11/Nginx/"/>
    <id>http://yoursite.com/2017/02/11/Nginx/</id>
    <published>2017-02-10T17:43:50.000Z</published>
    <updated>2017-03-10T02:29:36.537Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Nginx安装手册"><a href="#Nginx安装手册" class="headerlink" title="Nginx安装手册"></a>Nginx安装手册</h2><a id="more"></a><h3 id="nginx安装环境"><a href="#nginx安装环境" class="headerlink" title="nginx安装环境"></a>nginx安装环境</h3><p>nginx是C语言开发，建议在linux上运行，本教程使用Centos6.5作为安装环境。</p><ul><li>gcc<br>安装nginx需要先将官网下载的源码进行编译，编译依赖gcc环境，如果没有gcc环境，需要安装gcc：<strong>yum install gcc-c++</strong></li><li>PCRE<br>PCRE(Perl Compatible Regular Expressions)是一个Perl库，包括 perl 兼容的正则表达式库。nginx的http模块使用pcre来解析正则表达式，所以需要在linux上安装pcre库。<br><strong>yum install -y pcre pcre-devel</strong><br>注：pcre-devel是使用pcre开发的一个二次开发库。nginx也需要此库。</li><li>zlib<br>zlib库提供了很多种压缩和解压缩的方式，nginx使用zlib对http包的内容进行gzip，所以需要在linux上安装zlib库。<br><strong>yum install -y zlib zlib-devel</strong></li><li>openssl<br>OpenSSL 是一个强大的安全套接字层密码库，囊括主要的密码算法、常用的密钥和证书封装管理功能及SSL协议，并提供丰富的应用程序供测试或其它目的使用。<br>  nginx不仅支持http协议，还支持https（即在ssl协议上传输http），所以需要在linux安装openssl库。<br><strong>yum install -y openssl openssl-devel</strong></li></ul><h3 id="编译安装"><a href="#编译安装" class="headerlink" title="编译安装"></a>编译安装</h3><p>将nginx-1.8.0.tar.gz拷贝至linux服务器。<br>解压：<br>  <strong>tar -zxvf nginx-1.8.0.tar.gz</strong><br>  <strong>cd nginx-1.8.0</strong></p><ul><li>configure<br>./configure –help查询详细参数</li></ul><p>参数设置如下：<br><strong>./configure \</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">--prefix=/usr/local/nginx \</div><div class="line">--pid-path=/var/run/nginx/nginx.pid \</div><div class="line">--lock-path=/var/lock/nginx.lock \</div><div class="line">--error-log-path=/var/log/nginx/error.log \</div><div class="line">--http-log-path=/var/log/nginx/access.log \</div><div class="line">--with-http_gzip_static_module \</div><div class="line">--http-client-body-temp-path=/var/temp/nginx/client \</div><div class="line">--http-proxy-temp-path=/var/temp/nginx/proxy \</div><div class="line">--http-fastcgi-temp-path=/var/temp/nginx/fastcgi \</div><div class="line">--http-uwsgi-temp-path=/var/temp/nginx/uwsgi \</div><div class="line">--http-scgi-temp-path=/var/temp/nginx/scgi</div></pre></td></tr></table></figure></p><p><strong>注意：上边将临时文件目录指定为/var/temp/nginx，需要在/var下创建temp及nginx目录</strong></p><ul><li>编译安装<br><strong>make</strong><br><strong>make  install</strong><br>安装成功查看安装目录 ：</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Nginx安装手册&quot;&gt;&lt;a href=&quot;#Nginx安装手册&quot; class=&quot;headerlink&quot; title=&quot;Nginx安装手册&quot;&gt;&lt;/a&gt;Nginx安装手册&lt;/h2&gt;
    
    </summary>
    
      <category term="operations" scheme="http://yoursite.com/categories/operations/"/>
    
    
      <category term="Nginx" scheme="http://yoursite.com/tags/Nginx/"/>
    
  </entry>
  
  <entry>
    <title>MySQL数据库应用从入门到精通</title>
    <link href="http://yoursite.com/2017/01/12/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E5%BA%94%E7%94%A8%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/"/>
    <id>http://yoursite.com/2017/01/12/MySQL数据库应用从入门到精通/</id>
    <published>2017-01-12T13:02:25.000Z</published>
    <updated>2017-02-20T19:23:01.929Z</updated>
    
    <content type="html"><![CDATA[<p>   最近在看《MySQL数据库应用从入门到精通》这本书是基于MySQL5.5版本的，下面是看书过程记录下来的笔记。</p><a id="more"></a><h3 id="数据库概述"><a href="#数据库概述" class="headerlink" title="数据库概述"></a>数据库概述</h3><p>   SQL主要功能：数据定义语言（DDL）,数据操作语言（DML）,数据控制语言（DCL).</p><h3 id="数据可基本操作"><a href="#数据可基本操作" class="headerlink" title="数据可基本操作"></a>数据可基本操作</h3><p><code>create Database database_name;</code>创建数据库<br><code>SHOW DATABASES;</code>查看数据库<br><code>USE database_name;</code> 选择数据库<br><code>DROP DATABASE database_name;</code>删除数据库<br>    在执行SQL语句中，可以用”;”、”\g”、”\G”符号表示语句结束。其中前两个符号的作用一样，而最后一个符号除了表示语句结束外，还可以使得结果显示的更加美观。</p><h3 id="mysql中的存储引擎和数据类型"><a href="#mysql中的存储引擎和数据类型" class="headerlink" title="mysql中的存储引擎和数据类型"></a>mysql中的存储引擎和数据类型</h3><h4 id="存储引擎"><a href="#存储引擎" class="headerlink" title="存储引擎"></a>存储引擎</h4><h5 id="查询存储引擎"><a href="#查询存储引擎" class="headerlink" title="查询存储引擎"></a>查询存储引擎</h5><p>  存储引擎是MySQL数据库管理系统的一个重要特征，在具体开发时，为了提高MySQL数据库管理系统的使用效率和灵活性，可以根据实际需要来选择存储引擎。因为存储引擎指定了表的类型，即如何存储和索引数据、是否支持事物等，同时存储引擎也决定了表在计算机中的存储方式。<br><code>SHOW ENGINES;</code>显示支持的存储引擎<br><code>show variables like &#39;%storage_engine%&#39;;</code>当前默认的存储引擎:</p><h5 id="选择存储引擎"><a href="#选择存储引擎" class="headerlink" title="选择存储引擎"></a>选择存储引擎</h5><p>  下图是3种常用的存储引擎介绍。<br>  <img src="/images/mysql/mysql_ccyq.png" alt="存储引擎特性"><br>   上面主要介绍了MyISAM、InnoDB和MEMORY三种存储引擎特性的对比，接下来将详细介绍这3个存储引擎的应用场合并给出相应的建议。</p><ul><li>MyISAM:由于该存储引擎不支持事务、也不支持外键，所以访问速度比较快。因为此对事务完整性没有要求并以访问为主的应用适用于该存储引擎。</li><li>InnoDB:由于该存储引擎在事务上具有优势，即支持具有提交、回滚和崩溃恢复能力的事务安装，所以比MyISAM存储引擎占用更多的磁盘空间。因此需要进行频繁的更新、删除操作，同时还对事务的完整性要求比较高，需要实现必发控制，此时适用适用该存储引擎。</li><li>MEMORY:该存储引擎使用内存来存储数据，因此该存储引擎的数据访问速度比较快，但是安全上没有保障。如果应用中涉及数据比较小，需要进行快速访问，则适用使用该存储引擎。</li></ul><p>关于图形化的存储引擎修改这里不做记录，下面讲解通过修改my.ini配置来配置存储引擎。<br>  <img src="/images/mysql/mysq_myini.png" alt="my.ini配置文件，关于“[mysqld]”组的内容"><br>  如果想要修改默认存储引擎，只需修改[mysqld]组中的<code>default-storage-engine</code>参数。如：<code>default-storage-engine=MyISAM</code><br>   <strong>注意：如果修改参数后，需重启MySQL服务才能生效</strong></p><h4 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h4><h5 id="整形"><a href="#整形" class="headerlink" title="整形"></a>整形</h5><p><strong> 整型具体特性如下图：</strong><br><img src="/images/mysql/mysql_int.png" alt=""></p><h5 id="浮点数类型、定点数类型和位类型"><a href="#浮点数类型、定点数类型和位类型" class="headerlink" title="浮点数类型、定点数类型和位类型"></a>浮点数类型、定点数类型和位类型</h5><p>当需要精确到小数点后10位以上是，需要选择DOUBLE类型。当需要小数数据精确度非常高时，则可以选择DEC和DECIMAL类型，它们的精确度比DOUBLE类型还要高。FLOAT、DOUBLE数据类型存储数据是存储的是近似数，而DECIMAL存储的是字符串，因此提供了更高的精度。<br><strong> 浮点数类型具体特性如下图：</strong><br><img src="/images/mysql/mysql_fd.png" alt=""><br><strong> 定点数类型具体特性如下图：</strong><br><img src="/images/mysql/mysql_dec.png" alt=""><br><strong> FLOAT数据类型和DECIMAL数据类型的区别如下：</strong><br><img src="/images/mysql/mysql_decf.png" alt=""><br>结果为：<img src="/images/mysql/mysql_decfl.png" alt=""><br><strong> 位类型具体类型如下：</strong><br><img src="/images/mysql/mysql_wei.png" alt=""><br>BIT类型的使用<br><img src="/images/mysql/mysql_bit.png" alt=""></p><h5 id="日期和时间类型"><a href="#日期和时间类型" class="headerlink" title="日期和时间类型"></a>日期和时间类型</h5><p><strong> 日期和时间类型具体特性如下图：</strong><br><img src="/images/mysql/mysql_time.png" alt=""></p><h5 id="字符串类型"><a href="#字符串类型" class="headerlink" title="字符串类型"></a>字符串类型</h5><p><strong> CHAR系列字符串类型具体特性如下：</strong><br><img src="/images/mysql/mysql_char.png" alt=""><br><strong> TEXT系列字符串类型具体特性如下：</strong><br><img src="/images/mysql/mysql_text.png" alt=""><br><strong> BINARY系列字符串类型具体特性如下：</strong><br><img src="/images/mysql/mysql_binary.png" alt=""><br>BINARY可以存储二进制数据（例如图片、音乐或者视频文件），而后者只能存储字符数据。如果二进制数据长度经常变化则选择VARBINARY类型，否则选择BINARY。<br><strong> BLOB系列字符类型具体特性如下：</strong><br><img src="/images/mysql/mysql_blob.png" alt=""><br>上面的四种类型与TEXT系列字符串类型非常类似，不同的是，前者可以存储二进制数据（例如图片、音乐或者视频文件），而后者只能存储字符数据。如果需要存储电影等视频文件时则根据实际选择合适长度的BLOB类型</p><h3 id="表的操作"><a href="#表的操作" class="headerlink" title="表的操作"></a>表的操作</h3><h4 id="表的基本概念"><a href="#表的基本概念" class="headerlink" title="表的基本概念"></a>表的基本概念</h4><p>表是包含数据库中所有数据的数据库对象，表中的数据库对象包含列、索引和触发器。</p><h4 id="表的基本语法"><a href="#表的基本语法" class="headerlink" title="表的基本语法"></a>表的基本语法</h4><p>使用<code>USE database_name;</code>进入要操作的数据库。</p><h5 id="创建表的语法形式"><a href="#创建表的语法形式" class="headerlink" title="创建表的语法形式"></a>创建表的语法形式</h5><p><img src="/images/mysql/mysql_yufa.png" alt=""></p><h5 id="可以使用下面几种语法查看表定义"><a href="#可以使用下面几种语法查看表定义" class="headerlink" title="可以使用下面几种语法查看表定义"></a>可以使用下面几种语法查看表定义</h5><p><code>DESCRIBE table_name;</code><br><code>SHOW CREATE TABLE table_name;</code><br><code>DESC table_name;</code></p><h5 id="删除表"><a href="#删除表" class="headerlink" title="删除表"></a>删除表</h5><p><code>DROP TABLE table_name</code>;</p><h5 id="修改表"><a href="#修改表" class="headerlink" title="修改表"></a>修改表</h5><p><code>ALTER TABLE old_name RENAME [TO] new_table_name;</code>修改表名<br><code>ALTER TABLE table_name ADD 属性名 属性类型；</code>在表的最后一个位置添加字段<br><code>ALTER TABLE table_name ADD 属性名 属性类型 FIRST；</code>在表的第一个位置添加字段<br><code>ALTER TABLE table_name ADD 属性名 属性类型 AFTER 属性名；</code>在表指定字段之后添加字段<br><code>ALTER TABLE table_name DROP 属性名;</code>删除表中指定的属性<br><code>ALTER TABLE table_name MODIFY 属性名 数据类型;</code>修改字段的数据类型<br><code>ALTER TABLE table_name CHANGE 旧属性名 新属性名 旧属类型;</code>修改字段名字<br><code>ALTER TABLE table_name CHANGE 旧属性名 新属性名  新属类型;</code>同时修改字段名字和属性<br><code>ALTER TABLE table_name MODIFY 属性名1 数据类型 FIRST |AFTER 属性名2;</code>修改字段的顺序</p><h5 id="MySQL支持的完整性约束"><a href="#MySQL支持的完整性约束" class="headerlink" title="MySQL支持的完整性约束"></a>MySQL支持的完整性约束</h5><p>所谓完整性是指数据的准确性和一致性，而完整性检查就是指检查数据的准确性和一致性。MySQL数据库管理系统提供了一致机制来检查数据库表中的数据是否满足规定的条件，以保证数据库中数据的准确性和一致性，这种机制就是约束。<br>完整性约束如下图：<img src="/images/mysql/mysql_ys.png" alt=""><br><code>CREATE TABLE table_name(  属性名 数据类型 NOT NULL,  ......);</code>非空约束（NOT NULL,NK）<br><code>CREATE TABLE table_name(  属性名 数据类型 DEFAULT 默认值,  ......);</code>默认值（DEFAULT）<br><code>CREATE TABLE table_name(  属性名 数据类型 UNIQUE,  ......);</code>唯一约束（UNIQUE,UK）<br><code>CREATE TABLE table_name(  属性名 数据类型 PRIMARY KEY,  .....);</code>单字段主键（PRIMARY KEY,PK）<br><code>CREATE TABLE table_name(  属性名 数据类型,.....[CONSTRAINT 约束名]PRIMARY KEY(属性名,属性名......));</code>多字段主键（PRIMARY KEY,PK）<br><code>CREATE TABLE table_name(  属性名 数据类型 AUTO_INCREMENT,  .....);</code>自动增加（AUTO_INCREMENT）<br><code>CREATE TABLE table_name(  属性名 数据类型,  属性名 数据类型,  .....  CONSTRAINT 外键约束名 FOREIGN KEY (属性名) REFERENCES 表名 （属性名2）);</code>外键约束（FOREIGN KEY,FK）<br><strong> 注意：如果想给字段上的约束设置一个约束名字，可以执行SQL语句CONSTRAINT.例如：<code>CONSTRAINT  约束名字 约束 (属性名);</code></strong></p><h3 id="索引的操作"><a href="#索引的操作" class="headerlink" title="索引的操作"></a>索引的操作</h3><p>数据库对象索引其实与书的目录非常类似，主要是为了提高从表中检索数据的速度。<br>InnoDB和MyISAM存储引擎支持BTREE类型索引，MEMORY存储引擎支持HASH类型索引，默认为前者索引。<br>MySQL支持6种索引，分别为普通索引、唯一索引、全文索引、单列索引、多列索引和空间索引。</p><h4 id="创建和查看索引"><a href="#创建和查看索引" class="headerlink" title="创建和查看索引"></a>创建和查看索引</h4><p><strong><code>ASC</code>参数用来指定为升序排序，<code>DESC</code>参数用来指定为降序排序</strong></p><h5 id="普通索引"><a href="#普通索引" class="headerlink" title="普通索引"></a>普通索引</h5><p>创表时创建普通索引如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">CREATE TABLE table_name(</div><div class="line">  属性名 数据类型,</div><div class="line">  属性名 数据类型,</div><div class="line">  ......</div><div class="line">  属性名 数据类型,</div><div class="line">  INDEX|KEY [索引名] (属性名1 [(长度)] [ASC|DESC])</div><div class="line">);</div></pre></td></tr></table></figure><p><code>CREATE INDEX 索引名 ON表名(属性名 [(长度)] [ASC|DESC]);</code>在已经存在的表上创建普通索引<br><code>ALTER TABLE table_name ADD INDEX|KEY 索引名 （属性名 [(长度)] [ASC|DESC]);</code>通过SQL语句ALTER TABLE 创建普通索引</p><h5 id="唯一索引"><a href="#唯一索引" class="headerlink" title="唯一索引"></a>唯一索引</h5><p><strong>注意：explain用法<code>EXPLAIN tbl_name或EXPLAIN [EXTENDED] SELECT select_options</code>前者可以得出一个表的字段结构等等，后者主要是给出相关的一些索引信息，而今天要讲述的重点是后者。</strong><br>创建表时创建唯一索引如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">CREATE TABLE table_name(</div><div class="line">  属性名 数据类型,</div><div class="line">  属性名 数据类型,</div><div class="line">  ......</div><div class="line">  属性名 数据类型,</div><div class="line">  UNIQUE INDEX|KEY [索引名] （属性名1 [(长度)] [ASC|DESC])</div><div class="line">);</div></pre></td></tr></table></figure><p><code>CREATE UNIQUE INDEX 索引名 ON表名(属性名 [(长度)] [ASC|DESC]);</code>在已经存在的表上创建唯一索引<br><code>ALTER TABLE table_name ADD UNIQUE INDEX|KEY 索引名 （属性名 [(长度)] [ASC|DESC]);</code>通过SQL语句ALTER TABLE 创建唯一索引</p><h5 id="全文索引"><a href="#全文索引" class="headerlink" title="全文索引"></a>全文索引</h5><p>创建表时创建全文索引如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">CREATE TABLE table_name(</div><div class="line">  属性名 数据类型,</div><div class="line">  属性名 数据类型,</div><div class="line">  ......</div><div class="line">  属性名 数据类型,</div><div class="line">  FULLTEXT INDEX|KEY [索引名] （属性名1 [(长度)] [ASC|DESC])</div><div class="line">  );</div></pre></td></tr></table></figure><p><code>CREATE FULLTEXT INDEX 索引名 ON表名(属性名 [(长度)] [ASC|DESC]);</code>在已经存在的表上创建全文索引<br>  <code>ALTER TABLE table_name ADD FULLTEXT INDEX|KEY 索引名 （属性名 [(长度)] [ASC|DESC]);</code>通过SQL语句ALTER TABLE 创建全文索引</p><h5 id="多列索引"><a href="#多列索引" class="headerlink" title="多列索引"></a>多列索引</h5><p>创建表时创建全文索引如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">CREATE TABLE table_name(</div><div class="line"> 属性名 数据类型,</div><div class="line"> 属性名 数据类型,</div><div class="line"> ......</div><div class="line"> 属性名 数据类型,</div><div class="line"> INDEX|KEY [索引名] （属性名1 [(长度)] [ASC|DESC], </div><div class="line">                     ......</div><div class="line">                     属性名n [(长度)] [ASC|DESC])</div><div class="line">  );</div></pre></td></tr></table></figure><p>在已经存在的表上创建多列索引如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">CREATE INDEX 索引名</div><div class="line">   ON 表名（属性名1 [(长度)] [ASC|DESC],</div><div class="line">      ......</div><div class="line">          属性名n [(长度)] [ASC|DESC]</div><div class="line">   ）;</div></pre></td></tr></table></figure><p>通过SQL语句ALTER TABLE创建多列索引</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">ALTER TABLE table_name(</div><div class="line">  ADD INDEX|KEY 索引名（属性名1 [(长度)] [ASC|DESC],</div><div class="line">                       ......</div><div class="line">                      属性名n [(长度)] [ASC|DESC]</div><div class="line">   ）;</div></pre></td></tr></table></figure><h4 id="删除索引"><a href="#删除索引" class="headerlink" title="删除索引"></a>删除索引</h4><p><code>DROP INDEX index_name ON table_name;</code>删除索引</p><h3 id="视图的操作"><a href="#视图的操作" class="headerlink" title="视图的操作"></a>视图的操作</h3><h4 id="视图的特点"><a href="#视图的特点" class="headerlink" title="视图的特点"></a>视图的特点</h4><p>特点如下：</p><ul><li>视图的列可以来自不同的表，是表的抽象和在逻辑意义上建立的新关系。</li><li>视图是由基本表（实表）产生的表（虚表）。</li><li>视图的建立和删除不影响基本表。</li><li>对视图内容的更新（添加、删除和修改）直接影响基本表。</li><li>当视图来自多个基本表是，不允许添加和删除数据。</li></ul><h4 id="创建视图"><a href="#创建视图" class="headerlink" title="创建视图"></a>创建视图</h4><p><code>CREATE VIEW view_name AS 查询语句;</code>创建视图<br><code>USE view;</code>使用视图</p><h5 id="常量视图"><a href="#常量视图" class="headerlink" title="常量视图"></a>常量视图</h5><p>具体语句如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">CREATE VIEW view_test1</div><div class="line">  AS </div><div class="line">    SELECT 3.1415926;</div></pre></td></tr></table></figure></p><h5 id="封装使用聚合函数（SUM、MIN、MAX、COUNT等）查询语句的视图"><a href="#封装使用聚合函数（SUM、MIN、MAX、COUNT等）查询语句的视图" class="headerlink" title="封装使用聚合函数（SUM、MIN、MAX、COUNT等）查询语句的视图"></a>封装使用聚合函数（SUM、MIN、MAX、COUNT等）查询语句的视图</h5><p>具体语句如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">CREATE VIEW view_test2</div><div class="line">   AS </div><div class="line">     SELECT COUNT(name)</div><div class="line">     FROM database_name;</div></pre></td></tr></table></figure></p><h5 id="封装了实现功能（ORDER-BY）查询语句的视图"><a href="#封装了实现功能（ORDER-BY）查询语句的视图" class="headerlink" title="封装了实现功能（ORDER BY）查询语句的视图"></a>封装了实现功能（ORDER BY）查询语句的视图</h5><p>具体语句如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">CREATE VIEW view_test3</div><div class="line">  AS</div><div class="line">    SELECT name</div><div class="line">       FROM table_name</div><div class="line">         ORDER BY id DESC;</div></pre></td></tr></table></figure></p><h5 id="封装了实现表内连接查询语句的视图"><a href="#封装了实现表内连接查询语句的视图" class="headerlink" title="封装了实现表内连接查询语句的视图"></a>封装了实现表内连接查询语句的视图</h5><p>具体语句如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">CREATE VIEW view_test4</div><div class="line">  AS </div><div class="line">   SELECT s.name</div><div class="line">     FROM t_student as s,t_group as g</div><div class="line">       WHERE s.group_id=g.id AND g.id=2;</div></pre></td></tr></table></figure></p><h5 id="封装了实现表外连接（LEFT-JOIN-和RIGHT-JOIN）查询语句视图"><a href="#封装了实现表外连接（LEFT-JOIN-和RIGHT-JOIN）查询语句视图" class="headerlink" title="封装了实现表外连接（LEFT JOIN 和RIGHT JOIN）查询语句视图"></a>封装了实现表外连接（LEFT JOIN 和RIGHT JOIN）查询语句视图</h5><p>具体语句如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">CREATE VIEW view_test5</div><div class="line">  AS </div><div class="line">    SELECT s.name </div><div class="line">       FROM t_student as s LEFT JOIN t_group as g ON s.group_id=g.id</div><div class="line">        where g.id=2;</div></pre></td></tr></table></figure></p><h5 id="封装了实现子查询相关查询语句的视图"><a href="#封装了实现子查询相关查询语句的视图" class="headerlink" title="封装了实现子查询相关查询语句的视图"></a>封装了实现子查询相关查询语句的视图</h5><p>具体语句如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">CREATE VIEW view_test6</div><div class="line"> AS </div><div class="line"> SELECT s.name</div><div class="line"> FROM t_student AS s</div><div class="line">     WHERE s.grop_id IN(SELECT id FROM t_group);</div></pre></td></tr></table></figure></p><h5 id="封装了实现记录联合（UNION和UNION-ALL）查询语句的视图"><a href="#封装了实现记录联合（UNION和UNION-ALL）查询语句的视图" class="headerlink" title="封装了实现记录联合（UNION和UNION ALL）查询语句的视图"></a>封装了实现记录联合（UNION和UNION ALL）查询语句的视图</h5><p>具体语句如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">CREATE VIEW view_test7</div><div class="line">  AS</div><div class="line">    SELECT id,name FROM t_student</div><div class="line">    UNION ALL</div><div class="line">    SELECT id,name FROM t_group;</div></pre></td></tr></table></figure></p><h4 id="查看视图"><a href="#查看视图" class="headerlink" title="查看视图"></a>查看视图</h4><p><code>USE dababase_name; SHOW TABLES;</code>查看视图名<br><code>USE database_name; SHOW CREATE VIEW viewname;</code>查看视图定义信息<br><code>USE database_name; DESCRIBE | DESC  viewname;</code>查看视图设计信息<br><code>SHOW TABLE STATUS [FROM db_name] [LIKE &#39;pattern&#39;];</code>查看视图（和表）详细信息<br>SHOW TABLE STATUS返回字段含义如下图：<br><img src="/images/mysql/mysql_sta.png" alt=""></p><h4 id="删除视图"><a href="#删除视图" class="headerlink" title="删除视图"></a>删除视图</h4><p><code>USE database_name; DROP VIEW view_name [,view_name] ...;</code>删除视图</p><h4 id="修改视图"><a href="#修改视图" class="headerlink" title="修改视图"></a>修改视图</h4><h5 id="CREATE-OR-REPLACE-VIEW语句修改视图"><a href="#CREATE-OR-REPLACE-VIEW语句修改视图" class="headerlink" title="CREATE OR REPLACE VIEW语句修改视图"></a>CREATE OR REPLACE VIEW语句修改视图</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">`USE database_name;</div><div class="line"> CREATE OR REPLACE VIEW view_selectproduct</div><div class="line">    AS</div><div class="line">       SELECT name</div><div class="line">            FROM  t_products;</div></pre></td></tr></table></figure><h5 id="ALTER-语句修改视图"><a href="#ALTER-语句修改视图" class="headerlink" title="ALTER 语句修改视图"></a>ALTER 语句修改视图</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">`USE database_name;</div><div class="line"> ALTER VIEW view_selectproduct</div><div class="line">    AS</div><div class="line">       SELECT name</div><div class="line">            FROM  t_products;</div></pre></td></tr></table></figure><h4 id="利用视图操作基本表"><a href="#利用视图操作基本表" class="headerlink" title="利用视图操作基本表"></a>利用视图操作基本表</h4><h5 id="检索（查询）数据"><a href="#检索（查询）数据" class="headerlink" title="检索（查询）数据"></a>检索（查询）数据</h5><p><code>SELECT * FROM view_name;</code></p><h5 id="利用视图操作基本表数据"><a href="#利用视图操作基本表数据" class="headerlink" title="利用视图操作基本表数据"></a>利用视图操作基本表数据</h5><ul><li>对视图数据进行添加、删除和更新操作直接影响基本表。</li><li>视图来自多个基本表时，不允许添加和删除数据。</li></ul><p><strong>添加数据操作</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">INSERT INTO view_name(属性1,属性2，属性3...)</div><div class="line"> VALUES(value1,value2,value3...);</div></pre></td></tr></table></figure></p><p><strong>删除数据操作</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">DELETE FROM view_name</div><div class="line">   WHERE name=’属性名‘;</div></pre></td></tr></table></figure></p><p><strong>更新数据操作</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">UPDATE view_name</div><div class="line"> set 属性1=value</div><div class="line">    WHERE 属性2=value；</div></pre></td></tr></table></figure></p><h3 id="触发器的操作"><a href="#触发器的操作" class="headerlink" title="触发器的操作"></a>触发器的操作</h3><p>在具体的应用中，之所以经常使用触发器数据对象，是由与该对象能够加强数据库表中数据的完整性约束和业务规则等。</p><h4 id="创建有一条执行语句的触发器"><a href="#创建有一条执行语句的触发器" class="headerlink" title="创建有一条执行语句的触发器"></a>创建有一条执行语句的触发器</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">create trigger trigger_name</div><div class="line">   BEFORE|AFTER trigger_EVENT</div><div class="line">      ON TABLE_NAME FOR EACH ROW trigger_STMT;</div></pre></td></tr></table></figure><h4 id="创建包含多条执行语句的触发器"><a href="#创建包含多条执行语句的触发器" class="headerlink" title="创建包含多条执行语句的触发器"></a>创建包含多条执行语句的触发器</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">create trigger trigger_name</div><div class="line">   BEFORE|AFTER trigger_EVENT</div><div class="line">    ON TABLE_NAME FOR EACH ROW</div><div class="line">     BEGIN</div><div class="line">     trigger_STMT</div><div class="line">     END;</div></pre></td></tr></table></figure><h4 id="查看触发器"><a href="#查看触发器" class="headerlink" title="查看触发器"></a>查看触发器</h4><p><code>SHOW TRIGGERS;</code>语句查看触发器<br>通过查看系统表triggers实现查看触发器，如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">USE information_schema;</div><div class="line">SELECT * FROM triggers (WHERE TRIGGER_NAME=&apos;trigger_name&apos;) \G</div></pre></td></tr></table></figure></p><h4 id="删除触发器"><a href="#删除触发器" class="headerlink" title="删除触发器"></a>删除触发器</h4><p><code>DROP TRIGGER trigger_name;</code>删除触发器</p><h3 id="数据操作"><a href="#数据操作" class="headerlink" title="数据操作"></a>数据操作</h3><h4 id="插入数据"><a href="#插入数据" class="headerlink" title="插入数据"></a>插入数据</h4><h5 id="插入一部分数据"><a href="#插入一部分数据" class="headerlink" title="插入一部分数据"></a>插入一部分数据</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">INSERT INTO table_name(field1,field2,field3,......fieldn)</div><div class="line">  VALUES(value1,value2,value3......valuen);</div></pre></td></tr></table></figure><h5 id="插入完整数据"><a href="#插入完整数据" class="headerlink" title="插入完整数据"></a>插入完整数据</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">INSERT INTO table_name</div><div class="line">  VALUES(value1,value2,value3......valuen);</div></pre></td></tr></table></figure><h5 id="插入多天数据"><a href="#插入多天数据" class="headerlink" title="插入多天数据"></a>插入多天数据</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">#插入多条部分数据</div><div class="line">INSERT INTO table_name(field1,field2,field3,...fieldn)</div><div class="line">  VALUES(value11,value21,value31...valuen1),</div><div class="line">        (value11,value21,value31...valuen1),</div><div class="line">        (value11,value21,value31...valuen1),</div><div class="line">         ......</div><div class="line">        (value1m,value2m,value3m...valuenm);</div><div class="line"></div><div class="line">#插入多条完整数据</div><div class="line">INSERT INTO table_name</div><div class="line">  VALUES(value11,value21,value31...valuen1),</div><div class="line">        (value11,value21,value31...valuen1),</div><div class="line">        (value11,value21,value31...valuen1),</div><div class="line">         ......</div><div class="line">        (value1m,value2m,value3m...valuenm);</div></pre></td></tr></table></figure><h5 id="插入查询结果"><a href="#插入查询结果" class="headerlink" title="插入查询结果"></a>插入查询结果</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">INSERT INTO table_name1(field11,field12,field13,...field1n)</div><div class="line">    SELECT (field21,field22,field23,...field2n)</div><div class="line">        FROM table name2</div><div class="line">          WHERE ...</div></pre></td></tr></table></figure><h4 id="更新数据记录"><a href="#更新数据记录" class="headerlink" title="更新数据记录"></a>更新数据记录</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">UPDATE table_name</div><div class="line">  SET field1=value1,</div><div class="line">      field2=value2,</div><div class="line">      field3=value3,</div><div class="line">  WHERE CONDITION</div></pre></td></tr></table></figure><h4 id="删除特定数据记录"><a href="#删除特定数据记录" class="headerlink" title="删除特定数据记录"></a>删除特定数据记录</h4> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">DELETE FROM table_name</div><div class="line">WHERE CONDITION</div></pre></td></tr></table></figure><h3 id="单表数据记录查询"><a href="#单表数据记录查询" class="headerlink" title="单表数据记录查询"></a>单表数据记录查询</h3><h4 id="简单数据查询"><a href="#简单数据查询" class="headerlink" title="简单数据查询"></a>简单数据查询</h4><h5 id="一般查询"><a href="#一般查询" class="headerlink" title="一般查询"></a>一般查询</h5><p><code>SELECT field1 field2 ...fieldn FROM table_name;</code> 查询指定字段数据<br><code>SELECT * FROM table_name;</code> 查询所有字段数据<br><code>SELECT DISTINCT field1 field2 ...fieldn FROM table_name;</code>避免数据重复查询–DISTINCT</p><h5 id="实现数学四则运算数据查询"><a href="#实现数学四则运算数据查询" class="headerlink" title="实现数学四则运算数据查询"></a>实现数学四则运算数据查询</h5><p>mysql支持的关系运算符如下：<br><img src="/images/mysql/mysql_sta.png" alt=""><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">SELECT field1 [AS] otherfield1,field2 [AS] otherfield2,...fieldn [AS] otherfieldn</div><div class="line">FROM table_name</div><div class="line">#例如：</div><div class="line">SELECT ename,sal*12 [AS] yearsalary</div><div class="line">FROM t_employee;</div></pre></td></tr></table></figure></p><h5 id="设置显示格式数据查询"><a href="#设置显示格式数据查询" class="headerlink" title="设置显示格式数据查询"></a>设置显示格式数据查询</h5><p>如下显示的是以固定的格式（ename雇员的年薪为：sal）显示查询到数据<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">SELECT CONCAT(ename,&apos;雇员的年薪为：&apos;,sal*12) yearsalary</div><div class="line">   FROM t_employee;</div></pre></td></tr></table></figure></p><p>结果为：<br><img src="/images/mysql/mysql_a.png" alt=""></p><h4 id="条件数据记录查询"><a href="#条件数据记录查询" class="headerlink" title="条件数据记录查询"></a>条件数据记录查询</h4><p>条件查询的语法格式<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">SELECT field1、field2 ...field3</div><div class="line"> FROM table_name</div><div class="line"> WNERE CONDITION;</div></pre></td></tr></table></figure></p><p><strong>带关系运算符和逻辑运算符的条件数据查询</strong><br><img src="/images/mysql/mysql_bijiao.png" alt=""><br><img src="/images/mysql/mysql_yusuanfu.png" alt=""><br><strong>带（not）between value1 and value2查询（不）符合范围之内</strong><br><strong>IS （NOT） NULL查询是（不是）空值 </strong><br><strong>带IN关键字的集合查询</strong><br>注意：IN查询时，查询集合中包括NULL,则不会影响结果；NOT IN查询时，查询集合中包括NULL,则查询不到结果。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">SELECT field1 field2 ...fieldn</div><div class="line">FROM table_name</div><div class="line">WHERE field IN(value1,value2,value3,...,valuen);//在集合中</div><div class="line">WHERE field NOT IN(value1,value2,value3,...,valuen);//不在集合中</div></pre></td></tr></table></figure></p><p><strong>带LIKE关键字模糊查询</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">SELECT field1 field2 ...fieldn</div><div class="line">FROM table_name</div><div class="line">WHERE field [NOT] LIKE value;</div></pre></td></tr></table></figure></p><p>LIKE支持的通配符如下：</p><ul><li>“_”通配符，该通配符值能匹配单个字符</li><li>“%”通配符，该通配符可以匹配任意长度单位字符串，可以0个字符、1个或者更多</li></ul><p><strong>排序数据记录查询</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">SELECT field1 field2 ...fieldn</div><div class="line">FROM table_name</div><div class="line">WHERE CONDITION</div><div class="line">ORDER BY fieldm1 [ASC|DESC] [,fieldm2 [ASC|DESC],];</div></pre></td></tr></table></figure></p><p><strong>限制数据记录查询数量</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">SELECT field1 field2 ...fieldn</div><div class="line">FROM table_name</div><div class="line"> where CONDITION</div><div class="line"> LIMIT OFFSET_START,ROW_COUNT;</div><div class="line">#OFFSET_START为初始位置，可以选择不指定数据。</div></pre></td></tr></table></figure></p><p><strong>统计函数和分组数据记录查询</strong></p><ul><li>COUNT()：记录条数。</li><li>AVG()：平均值。</li><li>SUN():总和。</li><li>MAX():最大值。</li><li>MIN():最小值。</li></ul><p>注意：如果操作表中没有数据，则COUNT()函数返回为0，其它返回为NULL.</p><h4 id="分组数据查询"><a href="#分组数据查询" class="headerlink" title="分组数据查询"></a>分组数据查询</h4><p>分组查询的简单格式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">SELECT function()</div><div class="line">  FROM table_name</div><div class="line">  WHER CONDITION</div><div class="line">   GROUP BY field;</div></pre></td></tr></table></figure></p><p>下面为分组查询不同情况：</p><ul><li>function()为*时是简单分组查询</li><li>function()为GROUP_CONCAT(field)时实现统计功能分组查询，如下：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">SELECT deptno,GROUP_CONCAT(ename),COUNT(ename) number</div><div class="line"> FROM t_employee</div><div class="line"> GROUP BY deptno;</div></pre></td></tr></table></figure><ul><li>多字段分组查询</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">SELECT GROUP_COUNT(field),function(field)</div><div class="line">FROM table_name</div><div class="line">WHERE CONDITION</div><div class="line">GROUP BY field1,field2,...fieldn;</div></pre></td></tr></table></figure><ul><li>实现HAVING字句限定分组查询</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">SELECT function(field)</div><div class="line">FROM table_name</div><div class="line">WHERE CONDITION</div><div class="line">GROUP BY field1,field2,...fieldn</div><div class="line">HAVING CONDITION;</div><div class="line"></div><div class="line">#例如：</div><div class="line">SELECT deptno,AVG(sal) average,GROUP_CONCAT(ename) ename,COUNT(ename) number</div><div class="line">FROM t_employee</div><div class="line">GROUP BY deptno</div><div class="line">HAVING AVG(sal)&gt;2000;</div></pre></td></tr></table></figure><h4 id="自定义排序"><a href="#自定义排序" class="headerlink" title="自定义排序"></a>自定义排序</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">原表 user：</div><div class="line">id  name   roleId</div><div class="line">1    aaa     1</div><div class="line">2    bbb     2</div><div class="line">3    ccc     3</div><div class="line">4    ddd     4</div><div class="line">5    eee     5</div><div class="line">- MySQL可以通过field()函数自定义排序，格式：field(value,str1,str2,str3,str4)，value与str1、str2、str3、str4比较，返回1、2、3、4，如遇到null或者不在列表中的数据则返回0.</div><div class="line">例如：select * from user order by field(roleId,2,3,4,1,5);</div><div class="line">结果：</div><div class="line">id  name   roleId</div><div class="line">2    bbb     2</div><div class="line">3    ccc     3</div><div class="line">4    ddd     4</div><div class="line">1    aaa     1</div><div class="line">5    eee     5</div><div class="line"></div><div class="line">- locate（substr,str）函数返回子串substr在字符串str中第一次出现的位置，可以根据该函数进行排序</div><div class="line">例如：select * from user order by locate(id,&apos;2,3,1,5,4&apos;);</div><div class="line">结果：</div><div class="line">id  name   roleId</div><div class="line">2    bbb     2</div><div class="line">3    ccc     3</div><div class="line">1    aaa     1</div><div class="line">5    eee     5</div><div class="line">4    ddd     4</div></pre></td></tr></table></figure><h3 id="多表数据记录查询"><a href="#多表数据记录查询" class="headerlink" title="多表数据记录查询"></a>多表数据记录查询</h3><h4 id="关系数据库操作"><a href="#关系数据库操作" class="headerlink" title="关系数据库操作"></a>关系数据库操作</h4><h5 id="并（UNION）"><a href="#并（UNION）" class="headerlink" title="并（UNION）"></a>并（UNION）</h5><p>UNION指令的目的是将两个SQL语句的结果合并起来.UNION的一个限制是两个SQL语句所产生的栏位需要是同样的资料种类。另外，当我们用UNION这个指令时，我们只会看到不同的资料值（类似于SELECT DISTINCT），而UNION ALL会将每一笔符合条件的资料都显示出来，无论资料有没有重复。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">SELECT DATA FROM database1</div><div class="line">UNION ALL</div><div class="line">SELECT DATA FROM database2;</div></pre></td></tr></table></figure></p><h5 id="笛卡尔积"><a href="#笛卡尔积" class="headerlink" title="笛卡尔积"></a>笛卡尔积</h5><p><code>SELECT *FROM table1 CROSS JOIN table2;</code>交叉连接<br>笛卡尔积在SQL中的实现方式既是交叉连接(Cross Join)。所有连接方式都会先生成临时笛卡尔积表，笛卡尔积是关系代数里的一个概念，表示两个表中的每一行数据任意组合.</p><h5 id="内连接-INNER-JOIN"><a href="#内连接-INNER-JOIN" class="headerlink" title="内连接(INNER JOIN)"></a>内连接(INNER JOIN)</h5><p>内连接语法形式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">SELECT field1 field2...fieldn</div><div class="line">FROM join_tablename1 INNER JOIN join_tablename2 [INNER JOIN join_tablename]</div><div class="line">ON join_condition;</div></pre></td></tr></table></figure></p><p><strong>自然连接</strong></p><p>在表关系的笛卡尔积中，首先根据表关系中相同名称的字段自动进行记录匹配，然后去掉重复的字段。<br>是一种特殊的等值连接，它要求两个关系进行比较的分量必须是相同的属性组，并且在结果集中将重复属性列去掉。<br>一个简单的例子，将下列关系R和S进行自然连接：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">SELECT *</div><div class="line">from R natural join S;</div><div class="line"></div><div class="line">R：</div><div class="line">A    B     C</div><div class="line">a    b     c</div><div class="line">b    a     d</div><div class="line">c    d     e</div><div class="line">d    f     g</div><div class="line">S：</div><div class="line">A    C    D</div><div class="line">a    c    d</div><div class="line">d    f    g</div><div class="line">b    d    g</div></pre></td></tr></table></figure><p>首先要对两个关系中相同属性组的分量进行比较，即比较R.A，R.C和S.A,S.C。 显然在R中只有第一行和第二行满足条件，因此进行连接得到结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">ABCD</div><div class="line">abcd</div><div class="line">badg</div></pre></td></tr></table></figure></p><p><strong>等值连接</strong><br>表关系的笛卡尔积中，选择所匹配字段值相等（=符号）的数据记录。<br>下面为等值连接与自然连接的区别：</p><ul><li>等值连接中不要求相等属性值的属性名相同，而自然连接要求相等属性值的属性名必须相同，即两关系只有在同名属性才能进行自然连接。</li><li>等值连接不将重复属性去掉，而自然连接去掉重复属性，也可以说，自然连接是去掉重复列的等值连接。<br>一个简单的例子，将下列关系R和S进行等值连接：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">select *</div><div class="line">from R inner join S</div><div class="line">ON  R.B=S.C;</div><div class="line">R：</div><div class="line">A    B     C</div><div class="line">a    b     c</div><div class="line">b    a     d</div><div class="line">c    d     e</div><div class="line">d    f     g</div><div class="line">S：</div><div class="line">A    C    D</div><div class="line">a    c    d</div><div class="line">d    f    g</div><div class="line">b    d    g</div></pre></td></tr></table></figure><p>比较R.B=S.C。 显然在R中只有第一行和第二行满足条件，因此进行连接得到结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">R.AR.BR.CS.A S.C S.D</div><div class="line">c       d       e     b    d   g</div><div class="line">d       f       g     d    f   g</div></pre></td></tr></table></figure></p><p><strong>不等查询</strong><br>表关系的笛卡尔积中，选择所匹配字段不相等的数据操作。<br>内连接查询中的不等连接，就是在关键字ON后的匹配条件中通过除了等于关系运算符来实现不等条件外，可以使用的关系运算符包含”&gt;””&gt;=””&lt;””&lt;=”和”!=”等运算符号。<br>一个简单的例子，将下列关系R和S进行不等值连接：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">select *</div><div class="line">from R inner join S</div><div class="line">ON  R.B!=S.C AND R.A!=&quot;c&quot;;</div><div class="line">R：</div><div class="line">A    B     C</div><div class="line">a    b     c</div><div class="line">b    a     d</div><div class="line">c    d     e</div><div class="line">d    f     g</div><div class="line">S：</div><div class="line">A    C    D</div><div class="line">a    c    d</div><div class="line">d    f    g</div><div class="line">b    d    g</div></pre></td></tr></table></figure><p>比较R.B=S.C 和 R.A!=”c”。 显然在R中只有第一行和第二行满足条件，因此进行连接得到结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">R.AR.BR.CS.A S.C S.D</div><div class="line">c       d      e      b    d   g</div></pre></td></tr></table></figure></p><h5 id="外连接"><a href="#外连接" class="headerlink" title="外连接"></a>外连接</h5><p>所谓外连接(OUTER JOIN),就是在表关系的笛卡尔积数据记录中，不仅保留关系中所有匹配的数据记录，而且还会保留部分不匹配的数据记录。按照保留不匹配的数据记录来源可以分为左外连接（LEFT OUTER JOIN）、右外连接（RIGHT OUTER JOIN)和全外连接（FULL OUTER JOIN).</p><p>一个简单的例子，为外连接的各种情况：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">a表     id   name     </div><div class="line">        1   张3            </div><div class="line">        2   李四                 </div><div class="line">        3   王武           </div><div class="line">b表     id jod parent_id</div><div class="line">1 23 1</div><div class="line">2 34 2</div><div class="line">3 34 4</div><div class="line"></div><div class="line">  左连接   </div><div class="line">  select   a.*,b.*   from   a   left   join   b     on   a.id=b.parent_id       </div><div class="line">  结果是     </div><div class="line">  1   张3                   1     23     1   </div><div class="line">  2   李四                  2     34     2   </div><div class="line">  3   王武                  null   </div><div class="line"></div><div class="line"> </div><div class="line"></div><div class="line"> 右连接   </div><div class="line">  select   a.*,b.*   from   a   right   join   b     on   a.id=b.parent_id       </div><div class="line">  结果是     </div><div class="line">  1   张3                    1     23     1   </div><div class="line">  2   李四                   2     34     2   </div><div class="line">  null                      3     34     4   </div><div class="line">    </div><div class="line"> 完全连接   </div><div class="line">  select   a.*,b.*   from   a   full   join   b     on   a.id=b.parent_id   </div><div class="line"></div><div class="line">  结果是     </div><div class="line">  1   张3                  1     23     1   </div><div class="line">  2   李四                 2     34     2   </div><div class="line">  null               　　  3     34     4   </div><div class="line">  3   王武                 null</div></pre></td></tr></table></figure><h5 id="合并查询记录结果"><a href="#合并查询记录结果" class="headerlink" title="合并查询记录结果"></a>合并查询记录结果</h5><p>语法如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">SELECT field1 field2  ...fieldn</div><div class="line">    FROM tablename1</div><div class="line">UNION |UNION ALL</div><div class="line">SELECT field1 field2  ...fieldn</div><div class="line">    FROM tablename2</div><div class="line">UNION |UNION ALL</div><div class="line">SELECT field1 field2  ...fieldn</div><div class="line">    FROM tablename3</div><div class="line">UNION |UNION ALL</div></pre></td></tr></table></figure></p><h5 id="子查询"><a href="#子查询" class="headerlink" title="子查询"></a>子查询</h5><p>例子如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">- 单行子查询</div><div class="line">        select ename,deptno,sal</div><div class="line">        from emp</div><div class="line">        where deptno=(select deptno from dept where loc=&apos;NEW YORK&apos;)；</div><div class="line"></div><div class="line">- 多行子查询</div><div class="line">        SELECT ename,job,sal</div><div class="line">        FROM EMP</div><div class="line">        WHERE deptno in ( SELECT deptno FROM dept WHERE dname LIKE &apos;A%&apos;)；</div><div class="line"></div><div class="line">- 多列子查询</div><div class="line">        SELECT deptno,ename,job,sal</div><div class="line">        FROM EMP</div><div class="line">        WHERE (deptno,sal) IN (SELECT deptno,MAX(sal) FROM EMP GROUP BY deptno)；</div><div class="line"></div><div class="line">- 内联视图子查询</div><div class="line">       (1)SELECT ename,job,sal,rownum</div><div class="line">          FROM (SELECT ename,job,sal FROM EMP ORDER BY sal)；</div><div class="line">       (2)SELECT ename,job,sal,rownum</div><div class="line">          FROM ( SELECT ename,job,sal FROM EMP ORDER BY sal)</div><div class="line">          WHERE rownum&lt;=5；</div><div class="line">  </div><div class="line">- 在HAVING子句中使用子查询</div><div class="line">        SELECT deptno,job,AVG(sal) FROM EMP GROUP BY deptno,job HAVING AVG(sal)&gt;(SELECT sal FROM EMP WHERE ename=&apos;MARTIN&apos;)； ·</div></pre></td></tr></table></figure></p><h3 id="使用MySQL运算符"><a href="#使用MySQL运算符" class="headerlink" title="使用MySQL运算符"></a>使用MySQL运算符</h3><p>算术、比较、逻辑和位运算符</p><h4 id="算术运算符"><a href="#算术运算符" class="headerlink" title="算术运算符"></a>算术运算符</h4><p>如下图：<img src="/images/mysql/mysql_ss.png" alt=""><br>注意：”&gt;”、”&lt;”、”&gt;=”和”=&lt;”比较运算符不能操作NULL(空值)。</p><h4 id="比较运算符"><a href="#比较运算符" class="headerlink" title="比较运算符"></a>比较运算符</h4><p>如下图：<img src="/images/mysql/mysql_bjiao.png" alt=""><br>特殊功能运算符（实现正则表达式匹配的需要REGEXP）：<br>如下图：<img src="/images/mysql/mysql_ts.png" alt=""><br>如下图：<img src="/images/mysql/mysql_ts2.png" alt=""></p><h4 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h4><p>如下图：<br><img src="/images/mysql/mysql_luoji.png" alt=""></p><h4 id="位运算符"><a href="#位运算符" class="headerlink" title="位运算符"></a>位运算符</h4><p><img src="/images/mysql/mysql_w.png" alt=""></p><h3 id="MySQL常用的函数"><a href="#MySQL常用的函数" class="headerlink" title="MySQL常用的函数"></a>MySQL常用的函数</h3><h4 id="使用字符串函数"><a href="#使用字符串函数" class="headerlink" title="使用字符串函数"></a>使用字符串函数</h4><p><img src="/images/mysql/mysql_zfc.png" alt=""></p><h5 id="合并字符串函数"><a href="#合并字符串函数" class="headerlink" title="合并字符串函数"></a>合并字符串函数</h5><p><code>CONCAT(S1,S2...SN)</code><br><code>CONCAT_WS(SEP,S1,S2...SN)</code> SEP为分隔符可以为一个字符串，也可以为其他参数，如果为NULL时返回NULL，其它位置的NULL则可忽略;</p><h5 id="比较字符串大小函数STRCMP"><a href="#比较字符串大小函数STRCMP" class="headerlink" title="比较字符串大小函数STRCMP()"></a>比较字符串大小函数STRCMP()</h5><p><code>STRCMP(str1,str2);</code>str1&gt;str2为1，str1&lt; str2为-1，str1=str2为0</p><h5 id="获取字符串的长度函数LENGTH-和字符数函数CHAT-LENGTH"><a href="#获取字符串的长度函数LENGTH-和字符数函数CHAT-LENGTH" class="headerlink" title="获取字符串的长度函数LENGTH()和字符数函数CHAT_LENGTH()"></a>获取字符串的长度函数LENGTH()和字符数函数CHAT_LENGTH()</h5><p><code>LENGTH(str);</code>参数str的长度<br><code>CHAR_LENGTH(str);</code>参数str的字符数</p><h5 id="大小写转换"><a href="#大小写转换" class="headerlink" title="大小写转换"></a>大小写转换</h5><p><code>UPPER(S)或者UCASE(S)</code>转换为大写<br><code>LOWER(S)或者LCASE(S)</code>转换为小写</p><h5 id="查找字符串位置"><a href="#查找字符串位置" class="headerlink" title="查找字符串位置"></a>查找字符串位置</h5><p><code>FIND_IN_SET(str1,str2);</code>返回字符串str2中与str1相匹配的字符串位置，str2包含若干个用逗号隔开的字符串。<br><code>FIELD(str,str1,str2...);</code>返回一个与字符串str匹配的位置（str1位置为1开始）</p><h5 id="返回字符串相匹配的开始位置"><a href="#返回字符串相匹配的开始位置" class="headerlink" title="返回字符串相匹配的开始位置"></a>返回字符串相匹配的开始位置</h5><p><code>LOCATE(str1,str)、POSITION(str1 IN str)和INSTR(str,str1)</code>在str中返回str1的开始位置。</p><h5 id="从现有字符串中截取子字符串"><a href="#从现有字符串中截取子字符串" class="headerlink" title="从现有字符串中截取子字符串"></a>从现有字符串中截取子字符串</h5><p><code>LEFT(str ,num)</code>返回字符串中str中包含前num个字母（从左边数）的字符串。<br><code>RIGHT(str ,num)</code>返回字符串中str中包含后num个字母（从左边数）的字符串。</p><h5 id="去除字符串的首尾空格"><a href="#去除字符串的首尾空格" class="headerlink" title="去除字符串的首尾空格"></a>去除字符串的首尾空格</h5><p><code>LTRIM(str);</code>去除字符串开始处空格<br><code>RTRIM(str);</code>去除字符串结束处空格<br><code>TRIM(str);</code>去除字符串首尾空格</p><h5 id="替代字符串"><a href="#替代字符串" class="headerlink" title="替代字符串"></a>替代字符串</h5><p><code>INSERT(str,pos,len,newstr);</code>字符串中的pos位置开始长度为len的字符串用字符串newstr来替换。如果参数pos的值超过字符串的长度，这返回值为原始字符串str.如果len的长度大于原来字符串（str)中所剩字符串的长度，则从位置pos开始进行全部替换。若任何一个参数为NULL，则返回Null.<br><code>REPLACE(str,substr,newstr);</code>字符串substr用字符串newstr来替代。</p><h4 id="使用数值函数"><a href="#使用数值函数" class="headerlink" title="使用数值函数"></a>使用数值函数</h4><p>常用的数值函数：<br><img src="/images/mysql/mysql_shuzuhanshu.png" alt=""></p><h5 id="0-1随机数"><a href="#0-1随机数" class="headerlink" title="0~1随机数"></a>0~1随机数</h5><p><code>RAND();</code>完全随机<br><code>RAND(X);</code>X相同时返回相同的值</p><h5 id="整数随机数"><a href="#整数随机数" class="headerlink" title="整数随机数"></a>整数随机数</h5><p><code>CEIl(X)或CEILING(X);</code>大于或者等于数值X的最小整数<br><code>FLOOR(X);</code>小于或者等于数值X的最大整数</p><h5 id="截取数值函数"><a href="#截取数值函数" class="headerlink" title="截取数值函数"></a>截取数值函数</h5><p><code>TRUNCATE(x,y);</code>返回数值x保留到小数点后y位的值，y可以为负数。</p><h5 id="四舍五入"><a href="#四舍五入" class="headerlink" title="四舍五入"></a>四舍五入</h5><p><code>ROUND(x,y);</code> 返回数值x保留到小数点后y位的值，在具体截取数值是需要进行四舍五入的操作。单没有y时默认为四舍五入到整数。</p><h4 id="使用日期和时间函数"><a href="#使用日期和时间函数" class="headerlink" title="使用日期和时间函数"></a>使用日期和时间函数</h4><p>常用的时间日期函数：<br><img src="/images/mysql/mysql_timehanshu.png" alt=""></p><h5 id="获取当前时间"><a href="#获取当前时间" class="headerlink" title="获取当前时间"></a>获取当前时间</h5><p><strong>当前时间</strong><br><code>NOW(),CURRENT_TIMESTAMP(),LOCALTIME(),SYSDATE();</code>2017-03-20 17:38:50<br><code>CURDATE(),CURRENT_DATE();</code>2017-05-02<br><code>CURTIME(),CURRENT_TIME();</code>16:29:59<br><code>UNIX_TIMESTAMP(NOW());</code>unix格式，可以不用参数表示当前时间，从1970年1月1号开始计算，以秒为单位。<br><code>FROM_UNIXTIME(UNIX_TIMESTAMP(NOW()));</code>把NUIX格式转换为普通格式同NOW()格式。<br><code>UTC_DATE();</code>UTC日期 2012-05-22<br><code>UTC_TIME();</code>UTC时间 13:00:01</p><p><strong>获取时间和日期的各个部分</strong><br>获取时间和日期的各个部分的功能如下：<br><img src="/images/mysql/mysql_timeq.png" alt=""><br>关于月份：<br><code>MONTH(NOW());</code>月<br><code>MONTHNAME(NOW());</code>月<br>关于星期：<br><img src="/images/mysql/mysql_xq.png" alt=""><br>关于天的函数：<br><code>DAYOFYEAR(NOW());</code>年中第几天<br><code>DAYOFMONTH(NOW());</code>月中第几天<br><strong>获取指定值得EXTRACT()函数</strong><br><code>EXTRACT(tye FROM date);</code>函数会从时间和日期参数中获取指定类型type的值。关于type参数的值可以是YEAR、MONTH、DAY、HOUR、MINUTE和SECOND。</p><p><strong>计算日期和时间函数</strong><br><code>TO_DAYS(date);</code>从0000年1月1日开始算起多少天。<br><code>FROM_DAYS(TO_DAYS(NOW()));</code>一段时间后日期和时间。<br><code>DATEDIFF(DATE1,DATE2);</code>日期参数之间的相隔天数。<br><code>ADDTIME(DATE,n);</code>date加上n秒后的时间。<br><code>SUBTIME(DATE,n);</code>date减上n秒后的时间。<br><code>ADDDATE(DATE,n);</code>date加上n天后的日期。<br><code>SUBDATE(DATE,n);</code>date减上n天后的日期。<br>关于ADDDATE()和SUBDATE()函数另外用法：<br><code>ADDDATE(d,INTERVAL expr type);</code>日期d加上一段时间后的日期，expr决定时间的长度，type决定了操作对象。<br><code>SUBDATE(d,INTERVAL expr type);</code>日期d减去一段时间后的日期，expr决定时间的长度，type决定了操作对象。<br>参数type类型：<br><img src="/images/mysql/mysql_timedate.png" alt=""><br>例子如下：<br><img src="/images/mysql/mysql_caozuoriqi.png" alt=""></p><h4 id="使用系统信息函数"><a href="#使用系统信息函数" class="headerlink" title="使用系统信息函数"></a>使用系统信息函数</h4><h5 id="常用系统信息函数"><a href="#常用系统信息函数" class="headerlink" title="常用系统信息函数"></a>常用系统信息函数</h5><p><img src="/images/mysql/mysql_xt.png" alt=""></p><h4 id="其它函数"><a href="#其它函数" class="headerlink" title="其它函数"></a>其它函数</h4><h5 id="流程函数"><a href="#流程函数" class="headerlink" title="流程函数"></a>流程函数</h5><p>如下：<br><img src="/images/mysql/mysql_liuc.png" alt=""></p><h5 id="特殊函数"><a href="#特殊函数" class="headerlink" title="特殊函数"></a>特殊函数</h5><p>如下：<br><img src="/images/mysql/mysql_tes.png" alt=""></p><h3 id="存储过程和函数的操作"><a href="#存储过程和函数的操作" class="headerlink" title="存储过程和函数的操作"></a>存储过程和函数的操作</h3><p>存储过程和函数的执行效率要比在程序中拼sql语句的执行效率要高。<br>存储过程与函数区别：<br>函数必须有返回值，而存储过程则没有，存储过程的参数类型远远多于函数。<br><img src="/images/mysql/mysql_hanshu.png" alt=""></p><h4 id="创建存储过程和函数"><a href="#创建存储过程和函数" class="headerlink" title="创建存储过程和函数"></a>创建存储过程和函数</h4><h5 id="创建存储过程语法形式"><a href="#创建存储过程语法形式" class="headerlink" title="创建存储过程语法形式"></a>创建存储过程语法形式</h5><p>如下图：<br><img src="/images/mysql/mysql_cuncgc.png" alt=""></p><p><img src="/images/mysql/mysql_ccccc.png" alt=""></p><h5 id="创建函数语法形式"><a href="#创建函数语法形式" class="headerlink" title="创建函数语法形式"></a>创建函数语法形式</h5><p><img src="/images/mysql/mysql_Bnnn.png" alt=""></p><h5 id="创建简单的存储过程和函数"><a href="#创建简单的存储过程和函数" class="headerlink" title="创建简单的存储过程和函数"></a>创建简单的存储过程和函数</h5><p>存储过程简单sql语句：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">USE company;</div><div class="line"></div><div class="line">DELIMITER $$</div><div class="line">CREATE PROCEDURE proce_employee_sal()</div><div class="line">COMMENT&apos;查询所有雇员的工资&apos;</div><div class="line">BEGIN </div><div class="line">    SELECT sal</div><div class="line">    FROM t_employee;</div><div class="line">END$$</div><div class="line">DELIMITER ;</div></pre></td></tr></table></figure></p><p>函数简单SQL语句：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">USE company;</div><div class="line"></div><div class="line">DELIMITER $$</div><div class="line">CREATE FUNCTION func_employee_sal(empno INT(11))</div><div class="line">    RETURNS DOUBLE(10,2)</div><div class="line">COMMENT&apos;查询所有雇员的工资&apos;</div><div class="line">BEGIN </div><div class="line">   RETURN (SELECT sal</div><div class="line">    FROM t_employee</div><div class="line">    WHERE t_employee.empno=empno);</div><div class="line">END$$</div><div class="line">DELIMITER ;</div></pre></td></tr></table></figure></p><h3 id="MySQL事务"><a href="#MySQL事务" class="headerlink" title="MySQL事务"></a>MySQL事务</h3><p>当多个用户访问同一份数据，一个用户在更改数据的过程中可能有其他客户同时发起更改请求，为了保证数据库记录的更新从一个一致性状态更改为另外一个一致性状态，使用事务处理是非常必要的，事务有以下4个特性：</p><ul><li>原子性（Atimicity):事务中所有的操作视为一个原子单位，即对事务所进行的数据修改等操作只能完全提交或者完全回滚。</li><li>一致性（Consistency):事务在完成时，必须是所有的数据从一种一致性状态变更为另外一种一致性状态，所有的变更都必须应用于事务的修改，以确保数据的完整性。</li><li>隔离性（ISOLATION):一个事务中的操作语句所做的修改必须与其他事务所做的修改相隔离。</li><li>持久性（Durability):事务完成后，所做的修改对数据的影响是永久的，即使系统重启或者出现系统故障数据仍可以恢复。</li></ul><h3 id="MySQL数据库维护和性能提高"><a href="#MySQL数据库维护和性能提高" class="headerlink" title="MySQL数据库维护和性能提高"></a>MySQL数据库维护和性能提高</h3><h4 id="MySQL数据库性能优化"><a href="#MySQL数据库性能优化" class="headerlink" title="MySQL数据库性能优化"></a>MySQL数据库性能优化</h4><p>建议如下：</p><ul><li>MySQL软件具有特定的硬件建议，在具体安装和使用数据库软件时，该软件所依托的计算机服务器最好能够遵循这些硬件建议。一般来说MySQL软件应该运行在自己的专用计算机服务器上。</li><li>MySQL软件安装成功后，会进行一系列的默认配置，这些配置开始通常是比较适合的，但是一段时间后，就需要调整内存分配、缓存区大小。可以通过执行SHOW VARIABLES 和SHOW STATES来实现。</li><li>MySQL软件是一个多用户多线程的数据库管理系统，对于该类型的服务器，经常会同时执行多个任务。如果这些任务中的某一个执行缓慢，则其他所有任务都会执行缓慢。为了解决这个问题，可以通过执行SQL语句show processlist显示所有的活动进程，或者通过执行kill命令终结消耗太多资源的进程。</li><li>通过SELECT语句实现多表查询时，应该多次试验连接和子查询等各种方式，找出最佳的方式。在具体判断select语句执行性能时，可以通过explain查看select语句的执行情况。</li><li>使用数据储存过程比一条一条执行语句速度要快许多。</li><li>不要查找比需求还要多的数据内容，换言之，不要执行“select *”语句，除非要真正需要查询所有字段。</li><li>通过UNION关键字连接的select语句，替代包含一系列复杂OR条件的SELECT语句，可以极大的改进性能。</li><li>数据库对象索引可以改善数据检索的性能，但会损失数据CUD操作（数据插入、数据更新和删除）性能。因此不经常查询的表，最好不要创建索引。</li><li>关键字LIKE的执行效率很低，一般来说，会通过“full text”来替代关键字LIKE;</li><li>数据库中的表时不断变化的实体。一组结构优良的表，使用一段时间后，表的使用和内容就会需要进行更改，因此当初理想的优化和配置就需要改变。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;   最近在看《MySQL数据库应用从入门到精通》这本书是基于MySQL5.5版本的，下面是看书过程记录下来的笔记。&lt;/p&gt;
    
    </summary>
    
      <category term="Database" scheme="http://yoursite.com/categories/Database/"/>
    
    
      <category term="MySQL" scheme="http://yoursite.com/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>Markdown using</title>
    <link href="http://yoursite.com/2017/01/12/Markdown/"/>
    <id>http://yoursite.com/2017/01/12/Markdown/</id>
    <published>2017-01-12T13:02:25.000Z</published>
    <updated>2017-03-08T09:07:29.048Z</updated>
    
    <content type="html"><![CDATA[<p> Markdown 和 Haroopad 介绍文档<br><a id="more"></a></p><hr><p><strong>要想写一遍自己的博客，一个好的工具往往会带来很多的便利</strong><br><strong>这里我推荐本人使用的一款工具Markdown编辑器Haroopad</strong></p><h3 id="Markdown简介"><a href="#Markdown简介" class="headerlink" title="Markdown简介"></a>Markdown简介</h3><blockquote><p>是一种轻量级标记语言，创始人为约翰·格鲁伯（John Gruber）。它允许人们“使用易读易写的纯文本格式编写文档，然后转换成有效的XHTML(或者HTML)文档”。这种语言吸收了很多在电子邮件中已有的纯文本标记的特性。    —— <a href="https://zh.wikipedia.org/wiki/Markdown" target="_blank" rel="external">维基百科</a><br>可以理解是通过类似html的语法渲染文本的工具。</p></blockquote><p>正如您在阅读的这份文档，它使用简单的符号标识不同的标题，将某些文字标记为<strong>粗体</strong>或者<em>斜体</em>，跨平台，代码高亮，Vim 键绑定，多列模式，行号，折叠， Github Flavored Markdown 等功能~下面列举了几个高级功能，更多语法可以查看<a href="http://daringfireball.net/projects/markdown/" target="_blank" rel="external">官网</a>或者<a href="http://www.appinn.com/markdown/" target="_blank" rel="external">中文文档</a>。</p><h3 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h3><p><strong>可以在标题内容前输入特定数量的井号(‘#’)来实现对应级别的HTML样式的标题(HTML提供六级标题)</strong></p><hr><p><img src="http://ojo6kjb1v.bkt.clouddn.com/title.png" alt="标题" title="title"></p><hr><h3 id="特殊格式的字体"><a href="#特殊格式的字体" class="headerlink" title="特殊格式的字体"></a>特殊格式的字体</h3><p><strong>在需要改变的文字片段前后 使用一对符号可以改变文字为特殊格式：</strong></p><ul><li>粗体     使用<code>**文字**</code>或者<code>__文字__</code>    效果：<strong>这里请大家尤其注意！</strong>  </li><li>斜体    使用<code>*文字*</code>或者<code>_文字_</code>    效果：会不调用父类的 <em>析构函数</em> 呢？  </li><li>高亮    使用 <code>==文字==</code>    效果：==这里是高亮的重点==，但这里不是。  </li><li>下划线    使用<code>++文字++</code>    效果：如果此时的++判断结果为真++……  </li><li>删除线    使用<code>~~文字~~</code>    效果：<del>1.2的版本已经修复这个Bug？</del>  </li><li>上角标    使用<code>^文字^</code>    效果：单位圆的方程式是x^2^+y^2^=1。  </li><li>下角标    使用<code>~文字~</code>    效果：最常见的氧化反应是C+O~2~=CO~2~  </li></ul><h3 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h3><p><strong>引用代码块的时候，先空一行，按tab接着就可以编写您需要的代码了</strong></p><pre><code>function a(){return(&quot;这是引用代码，亦即使代码块在浏览器显示的时候，区别对待&quot;)；}</code></pre><h3 id="LaTeX-公式"><a href="#LaTeX-公式" class="headerlink" title="LaTeX 公式"></a>LaTeX 公式</h3><p><strong>为了让haroopad支持数学公式首先需要在配置里面开启数学公式支持</strong><br><strong>点击文件-&gt;偏好设置-&gt;markdown-&gt;将数学表达式全部勾选</strong><br><img src="http://ojo6kjb1v.bkt.clouddn.com/math.png" alt="配置说明" title="config"></p><p>可以创建行内公式，例如<br> $$<br>\sqrt{3x-1}+{1+x}^2<br>$$<br>或者块级公式：</p><p>$$<br>x = \dfrac{-b \pm \sqrt{b^2 - 4ac}}{2a}<br>$$</p><h3 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h3><p><strong>Haroopad中绘制表格的语法如下:  <br></strong><br><img src="http://ojo6kjb1v.bkt.clouddn.com/table.png" alt="表格" title="table"><br><strong>效果如下:  <br></strong></p><table><thead><tr><th>姓名</th><th>性别</th><th>年龄</th></tr></thead><tbody><tr><td>张三</td><td>男</td><td>20</td></tr><tr><td>李四</td><td>女</td><td>20</td></tr></tbody></table><h3 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h3><p><strong>Haroopad支持 <a href="https://github.com/knsv/mermaid/wiki" target="_blank" rel="external">mermaid</a> 扩展。Mermaid是一套绘图的符号语言扩展，支持绘制各种关系图，序列图</strong></p><ul><li>Haroopad中mermaid绘图以 ~~~mermaid 单独一行开始，以 ~~~ 单独一行结束。</li><li>其中graph TD指定绘图方向是从上而下</li><li>改为graph LR则是从左至右</li></ul><p><strong>绘制流程图的语法如下：  <br></strong></p><p><img src="http://ojo6kjb1v.bkt.clouddn.com/mer_maid.png" alt="流程图" title="流程图"><br><strong>效果如下:  <br></strong><br><img src="http://ojo6kjb1v.bkt.clouddn.com/col_img.png" alt="流程图" title="横向"><br><img src="http://ojo6kjb1v.bkt.clouddn.com/row_img.png" alt="流程图" title="纵向"></p><p>Mermaid扩展还支持其它绘图方式，以及调整绘图样式，具体见<a href="https://github.com/knsv/mermaid/wiki" target="_blank" rel="external">绘图介绍</a></p><pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">graph TD;</div><div class="line">         subgraph 子图;</div><div class="line">         a1[矩形];</div><div class="line">         a2&gt;旗帜形];</div><div class="line">         a3(圆角方形);</div><div class="line">         end;</div><div class="line">         subgraph 第二个子图;</div><div class="line">         b1((圆形));</div><div class="line">         b2&#123;斜方形&#125;;</div><div class="line">         end;</div><div class="line">         a1--&gt;|实线箭头|a2;</div><div class="line">         a2--&gt;a1;</div><div class="line">         a2-.-&gt;|虚线箭头|a3;</div><div class="line">         a3-.-&gt;a2;</div><div class="line">         a3==&gt;|加粗箭头|a1;</div><div class="line">         a1==&gt;a3;</div><div class="line">         b1---b2;</div><div class="line">         b2---|实线无箭头|b1;</div><div class="line">         a1--&gt;b1;</div></pre></td></tr></table></figure></pre><h3 id="时序图"><a href="#时序图" class="headerlink" title="时序图"></a>时序图</h3><p><img src="http://ojo6kjb1v.bkt.clouddn.com/time.png" alt="时序图" title="时序图"></p><pre>~~~mermaid  sequenceDiagram          Alice->>Bob: Hello Bob, how are you?          alt is sick              Bob->>Alice: Not so good :(          else is well              Bob->>Alice: Feeling fresh like a daisy          end          opt Extra response              Bob->>Alice: Thanks for asking          end  ~~~  </pre><h3 id="复选框（任务清单）"><a href="#复选框（任务清单）" class="headerlink" title="复选框（任务清单）"></a>复选框（任务清单）</h3><p><strong>使用 <code>- [ ]</code> 和 <code>- [x]</code> 语法可以创建复选框，实现 todo-list 等功能。</strong><br><strong>Haroopad扩展支持tasklist，语法如下：</strong></p><ul><li>[x] a</li><li>[ ] b</li><li>[ ] c</li><li>[ ] d</li></ul><blockquote><p>**目前支持尚不完全，在编辑器勾选复选框是无效、不能同步的</p></blockquote><p>###兼容HTML</p><ul><li>一些 HTML 区块元素――比如 <code>&lt;div&gt;、&lt;table&gt;、&lt;pre&gt;、&lt;p&gt;</code> 等标签，需在标签前后加上空行，且标签本身不能缩进</li></ul><blockquote><p><strong>在HTML里面的Markdown是不被解析的</strong></p></blockquote><ul><li>在Markdown里面可以是直接<code>空格+enter键</code>换行，也可以是使用<code>&lt;br/&gt;</code>标签进行换行</li></ul><blockquote><p><strong>使用标签换行的方法是在需要换行的地方键入两个空格，回车之后加上<code>&lt;br/&gt;</code>标签即可</strong><br>语法示例：<br><img src="http://ojo6kjb1v.bkt.clouddn.com/br.png" alt="流程图" title="换行"><br>效果显示：</p><pre>我要  <br>在第二个字换行</pre></blockquote><ul><li>区块引用，直接在文本前面增加<code>&gt;</code>符号即可（使用不同数量的<code>&gt;</code>符号可以进行引用的嵌套，并且还支持Markdown语法）</li><li>段落和换行</li></ul><blockquote><p>你可以在一行中用三个以上的星号、减号、底线来建立一个分隔线，行内不能有其他东西。你也可以在星号或是减号中间插入空格。</p></blockquote><ul><li><p>链接（行内式和参考式）</p><blockquote><p>行内式语法加效果<br><code>This is [an example](http://example.com/ &quot;Title&quot;) inline link.</code><br>This is <a href="http://example.com/" title="Title" target="_blank" rel="external">an example</a> inline link.  <br><br>参考式语法加效果<br><code>This is [an example] [id] reference-style link.</code><br>This is [an example][id] reference-style link.</p></blockquote></li><li><p>强调(在需要强调的文字两边加上<code>*</code>或者<code>_</code>字符)</p></li><li>反引号<code>` </code>起到保护不被解析的作用</li><li><p>图片（行内式和参考式）</p><blockquote><p><code>![Alt text](/path/to/img.jpg)</code><br><code>![Alt text](/path/to/img.jpg &quot;Optional title&quot;)</code><br><code>[id]: url/to/image  &quot;Optional title attribute&quot;</code></p></blockquote></li><li><p>自动链接<br>Markdown 支持以比较简短的自动链接形式来处理网址和电子邮件信箱，只要是用尖括号包起来， Markdown 就会自动把它转成链接。一般网址的链接文字就和链接地址一样</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3></li></ul><blockquote><p>由于其简单易用，Markdown在社区已经越来越流行。甚至有些项目将自动化测试用例都用markdown语法来写，可以直接发布给客户当作说明文档，执行的时候靠一段解释代码将其翻译成目标语言执行，真的做到测试即文档。而Haroopad是一款非常强大的markdown编辑器，它内置的很多mardown扩展都是为了方便程序员，避免了大家到处寻找插件自行配制的繁琐。到目前为止haroopad是我找到的最好用的markdown编辑器，这篇文档就是用haroopad撰写。最后在支持如此多的特性后，haroopad依然非常轻量！ 希望Haroopad同样适合你！</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt; Markdown 和 Haroopad 介绍文档&lt;br&gt;
    
    </summary>
    
      <category term="blog" scheme="http://yoursite.com/categories/blog/"/>
    
    
      <category term="Markdown" scheme="http://yoursite.com/tags/Markdown/"/>
    
  </entry>
  
  <entry>
    <title>了解如何搭建自己的hexo博客</title>
    <link href="http://yoursite.com/2016/12/11/%E4%BA%86%E8%A7%A3%E5%A6%82%E4%BD%95%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84hexo%E5%8D%9A%E5%AE%A2/"/>
    <id>http://yoursite.com/2016/12/11/了解如何搭建自己的hexo博客/</id>
    <published>2016-12-11T01:42:47.000Z</published>
    <updated>2017-02-12T15:27:06.723Z</updated>
    
    <content type="html"><![CDATA[<p>前段时间在朋友的帮助下，也找过很多资料来搭建自己的hexo博客，之前也就是在简述上写自己的博客文章，说真的，自己如果懂得如何搭建博客来写，更有些自豪感。废话就不多说了，下面就来了解一下hexo以及如何搭建一个属于自己的hexo博客。<br><a id="more"></a></p><h3 id="了解hexo"><a href="#了解hexo" class="headerlink" title="了解hexo"></a>了解hexo</h3><p><a href="https://hexo.io/zh-cn/docs/" target="_blank" rel="external">hexo文档</a>给出的hexo定义是：Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。</p><blockquote><p>hexo出自台湾的tommy351之手，一个基于Node.js的静态博客程序，可以很方便的生成静态网页托管于github、gitcafe和Heroku，类似于jekyll，但Jekyll需要的git命令稍有点繁琐。</p></blockquote><p>重要的是hexo是免费的，可以在各个平台上搭建，如GitHub、GitCafe、coding、七牛。可以快速渲染自己编写的markdown文件。</p><h3 id="hexo的依赖"><a href="#hexo的依赖" class="headerlink" title="hexo的依赖"></a>hexo的依赖</h3><ul><li>搭建nodejs环境 <strong> （必须） </strong><br><a href="https://nodejs.org/zh-cn/" target="_blank" rel="external">node官网</a></li><li><p>git <strong> （必须） </strong></p><ul><li>windows 下载：<a href="https://git-scm.com/downloads" target="_blank" rel="external">git</a></li><li>linux 下载：<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ sudo apt-get update</div><div class="line">$ sudo apt-get install git</div></pre></td></tr></table></figure></li></ul></li><li><p>coding（<strong> 必须 </strong> ，可以用github来搭建）</p></li><li><p>域名（个性化）<br>域名只是让你的博客访问更有个性化，coding默认的访问博客的地址是 <code>http://your-coding-name.coding.me/your-repo-name</code> ，在github中的访问地址是：<code>https://your-github-name.github.io/your-repo-name/</code></p></li></ul><p>编写hexo可以使用Atom，我挺喜欢这款编辑器的markdown预览功能</p><h3 id="安装hexo"><a href="#安装hexo" class="headerlink" title="安装hexo"></a>安装hexo</h3><p>安装hexo，打开git bash操作界面（cmd界面也可以）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm install -g hexo</div></pre></td></tr></table></figure></p><p>初始化blog项目，并安装依赖<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">mkdir blog</div><div class="line">cd blog</div><div class="line">hexo init</div><div class="line">npm install</div></pre></td></tr></table></figure></p><p>运行hexo，在本地中预览 - 全称（hexo server）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">hexo s</div></pre></td></tr></table></figure></p><p>直接输入<code>http://localhost:4000/</code>就可以看到本地部署的hexo</p><p>紧接着就创建自己的coding项目，把本地的hexo放到远程的coding上运行。</p><p>本人是把hexo放在master分支，博文放到coding-pages分支中。</p><h3 id="在coding中创建博客项目"><a href="#在coding中创建博客项目" class="headerlink" title="在coding中创建博客项目"></a>在coding中创建博客项目</h3><h4 id="创建博客项目"><a href="#创建博客项目" class="headerlink" title="创建博客项目"></a>创建博客项目</h4><p><img src="/pic/hexo-blog-1.png" alt="创建博客项目"></p><img src="/pic/hexo-blog-1.png" title="[创建博客项目[创建博客项目]]"><p>这时写上项目名以及项目的描述。</p><h4 id="绑定ssh"><a href="#绑定ssh" class="headerlink" title="绑定ssh"></a>绑定ssh</h4><h5 id="检查本地是否存在ssh-key："><a href="#检查本地是否存在ssh-key：" class="headerlink" title="检查本地是否存在ssh key："></a>检查本地是否存在ssh key：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ cd ~/.ssh</div></pre></td></tr></table></figure><h5 id="生成ssh"><a href="#生成ssh" class="headerlink" title="生成ssh"></a>生成ssh</h5><p>如果本地没有，那么就在本地中生成ssh证书，生成的证书中有两个文件，一个是私钥，一个是公钥。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ssh-keygen -t rsa -C &quot;邮箱地址&quot;</div></pre></td></tr></table></figure></p><p>执行以上代码，会弹出是否需要输入密码，输不输入密码关系不大，这里选择不输入密码。</p><p>把公钥(id_rsa.pub)的内容拷贝到coding账户 -&gt; SSH公钥 -&gt; 新增公钥的内容中去，写上公钥名字，以及将公钥的有效期的<code>永久有效勾上</code></p><h5 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h5><p>对于coding，git@git.coding.net<br>（在windows中是没有ssh指令，可以使用git bash命令窗口就能找到）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ ssh -T git@git.coding.net</div></pre></td></tr></table></figure></p><p>对于github，git@github.com不需要修改<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ ssh -T git@github.com</div></pre></td></tr></table></figure></p><p>会出现类以下的反馈<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">The authenticity of host &apos;github.com (207.97.227.239)&apos; can&apos;t be established.</div><div class="line">RSA key fingerprint is 16:27:ac:a5:76:28:2d:36:63:1b:56:4d:eb:df:a6:48.</div><div class="line">Are you sure you want to continue connecting (yes/no)?</div></pre></td></tr></table></figure></p><p>点击yes，就ok了。</p><h3 id="在hexo中配置与coding相连"><a href="#在hexo中配置与coding相连" class="headerlink" title="在hexo中配置与coding相连"></a>在hexo中配置与coding相连</h3><p>打开你在本地创建的项目blog，找到_config.yml,打开<br>配置如下，将内容推送到coding-pages分支中<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">deploy:</div><div class="line">  type: git</div><div class="line">  repo: git@git.coding.net:your-coding-name/your-repo-name.git</div><div class="line">  branch: coding-pages</div></pre></td></tr></table></figure></p><h3 id="在你的博客项目blog，初始化为git仓库"><a href="#在你的博客项目blog，初始化为git仓库" class="headerlink" title="在你的博客项目blog，初始化为git仓库"></a>在你的博客项目blog，初始化为git仓库</h3><p>安装完git，需要配置以下信息<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ git config --global user.name &quot;username&quot; //用户名</div><div class="line">$ git config --global user.email  &quot;youremail&quot; //填写自己的邮箱</div></pre></td></tr></table></figure></p><p>初始化项目<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git init</div></pre></td></tr></table></figure></p><p>选择要添加进仓库的文件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git add .</div></pre></td></tr></table></figure></p><p>如果你想分享这个文件夹里所有代码，就在add后面加“.”，如果指定某个文件，只需把“.”改为文件名即可。<br>添加进入仓库：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git commit -m &quot;first commit&quot;</div></pre></td></tr></table></figure></p><p><code>-m</code>后面的参数，表示说明，将代码提交到GitHub后，将会给出一个提交说明，表明这是我哪次提交的。<br>所有工作已准备充分，现在开始提交，还是几条命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">// 添加coding源</div><div class="line">git remote add origin git@git.coding.net:your-coding-name/your-repo-name.git</div><div class="line">// 执行 git push 没有指定分支时，只有当前分支会被 push 到你使用 git pull 获取的代码。</div><div class="line">git config --global push.default simple</div><div class="line">// 上传本地项目代码到master分支</div><div class="line">git push -u origin master</div></pre></td></tr></table></figure></p><h3 id="开启Pages服务及配置域名"><a href="#开启Pages服务及配置域名" class="headerlink" title="开启Pages服务及配置域名"></a>开启Pages服务及配置域名</h3><h4 id="域名的使用"><a href="#域名的使用" class="headerlink" title="域名的使用"></a>域名的使用</h4><p>购买域名后，可以配置子域名来绑定hexo博客</p><ul><li>将记录类型设置成CNAME</li><li>主机记录，你喜欢</li><li>记录值设置成，pages.coding.me<br>设置成那样就可以了</li></ul><h4 id="Pages里添加域名访问呢"><a href="#Pages里添加域名访问呢" class="headerlink" title="Pages里添加域名访问呢"></a>Pages里添加域名访问呢</h4><p>进入刚才创建的项目中，点击左侧的代码，再进入Pages服务页面中，点击立即开启，部署来源选择coding-pages分支。</p><p>好像是找不到coding-pages分支的，那么就要手动创建一个coding-pages分支，然后指定分支开启服务。</p><p>在自定义域名里，可以填写自己已经注册的域名，这样就可以通过自己的域名去访问你的博客</p><h3 id="开始使用"><a href="#开始使用" class="headerlink" title="开始使用"></a>开始使用</h3><p>以上配置好后，使用域名就可以访问了</p><h4 id="新建文章"><a href="#新建文章" class="headerlink" title="新建文章"></a>新建文章</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">hexo n &quot;postName&quot; 相当于 hexo new &quot;postName&quot;</div></pre></td></tr></table></figure><h4 id="新建页面"><a href="#新建页面" class="headerlink" title="新建页面"></a>新建页面</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">hexo n page &quot;pageName&quot; 相当于hexo new page &quot;pageName&quot;</div></pre></td></tr></table></figure><h4 id="生成静态页面至public目录"><a href="#生成静态页面至public目录" class="headerlink" title="生成静态页面至public目录"></a>生成静态页面至public目录</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">hexo g 相当于hexo generate</div></pre></td></tr></table></figure><h4 id="开启预览本地博客服务，地址为http-localhost-4000"><a href="#开启预览本地博客服务，地址为http-localhost-4000" class="headerlink" title="开启预览本地博客服务，地址为http://localhost:4000/"></a>开启预览本地博客服务，地址为<code>http://localhost:4000/</code></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">hexo s 相当于hexo server</div></pre></td></tr></table></figure><h4 id="将-deploy目录部署到远程项目中"><a href="#将-deploy目录部署到远程项目中" class="headerlink" title="将.deploy目录部署到远程项目中"></a>将.deploy目录部署到远程项目中</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">hexo d 相当于hexo deplog</div></pre></td></tr></table></figure><p>安装<code>hexo-deployer-git</code>插件 - 第一次使用要安装这个插件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm install hexo-deployer-git --save</div></pre></td></tr></table></figure></p><h4 id="清除缓存文件-db-json-和已生成的静态文件-public"><a href="#清除缓存文件-db-json-和已生成的静态文件-public" class="headerlink" title="清除缓存文件 (db.json) 和已生成的静态文件 (public)"></a>清除缓存文件 (db.json) 和已生成的静态文件 (public)</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">hexo clean</div></pre></td></tr></table></figure><h4 id="查看帮助"><a href="#查看帮助" class="headerlink" title="查看帮助"></a>查看帮助</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">hexo h 相当于hexo help</div></pre></td></tr></table></figure><h4 id="查看hexo的版本"><a href="#查看hexo的版本" class="headerlink" title="查看hexo的版本"></a>查看hexo的版本</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">hexo v 相当于hexo version</div></pre></td></tr></table></figure><p>一般你写好自己的文章或配置好自己的设置，使用以下命令即可<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">hexo clean</div><div class="line">hexo g</div><div class="line">hexo d</div></pre></td></tr></table></figure></p><h3 id="主题-我这个主题为Next"><a href="#主题-我这个主题为Next" class="headerlink" title="主题 - 我这个主题为Next"></a>主题 - 我这个主题为Next</h3><h4 id="下载Next主题"><a href="#下载Next主题" class="headerlink" title="下载Next主题"></a>下载Next主题</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ cd your-hexo-site`</div><div class="line">$ git clone https://github.com/iissnan/hexo-theme-next themes/next</div></pre></td></tr></table></figure><h4 id="修改配置文件"><a href="#修改配置文件" class="headerlink" title="修改配置文件"></a>修改配置文件</h4><p>找到根目录下的_config.yml文件，修改theme使支持<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"># Extensions</div><div class="line">## Plugins: http://hexo.io/plugins/</div><div class="line">## Themes: http://hexo.io/themes/</div><div class="line">#theme: landscape</div><div class="line">theme: next</div></pre></td></tr></table></figure></p><h4 id="选择Scheme为Mist，自己觉得这个样式会比较好看"><a href="#选择Scheme为Mist，自己觉得这个样式会比较好看" class="headerlink" title="选择Scheme为Mist，自己觉得这个样式会比较好看"></a>选择Scheme为Mist，自己觉得这个样式会比较好看</h4><p>找到主题配置文件，blog/themes/next目录下的_config.yml文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"># Schemes</div><div class="line">#scheme: Muse</div><div class="line">scheme: Mist</div><div class="line">#scheme: Pisces</div></pre></td></tr></table></figure></p><h4 id="添加tags标签，与页面中的tag对应"><a href="#添加tags标签，与页面中的tag对应" class="headerlink" title="添加tags标签，与页面中的tag对应"></a>添加tags标签，与页面中的tag对应</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">hexo new page &quot;tags&quot;</div></pre></td></tr></table></figure><p>修改/source/tags/index.md文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">title: tags</div><div class="line">date: 2016-12-04 09:06:02</div><div class="line">type: &quot;tags&quot;</div><div class="line">---</div></pre></td></tr></table></figure></p><h3 id="其他配置"><a href="#其他配置" class="headerlink" title="其他配置"></a>其他配置</h3><h4 id="配置域名与hexo关联"><a href="#配置域名与hexo关联" class="headerlink" title="配置域名与hexo关联"></a>配置域名与hexo关联</h4><p>前面配置的是，域名与coding之间的关联。</p><p>找到根目录的_config.yml文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"># URL</div><div class="line">## If your site is put in a subdirectory, set url as &apos;http://yoursite.com/child&apos; and root as &apos;/child/&apos;</div><div class="line">url: 填写你的域名地址</div><div class="line">root: /</div><div class="line">permalink: :year/:month/:day/:title/</div><div class="line">permalink_defaults:</div></pre></td></tr></table></figure></p><h4 id="配置头像"><a href="#配置头像" class="headerlink" title="配置头像"></a>配置头像</h4><p>在根目录的_config.yml，me.jpg需要放到/blog/source/images目录下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"># 头像</div><div class="line">avatar: /images/me.jpg</div></pre></td></tr></table></figure></p><h4 id="配置多说评论"><a href="#配置多说评论" class="headerlink" title="配置多说评论"></a>配置多说评论</h4><p>在根目录下的配置文件_config.yml添加字段<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">duoshuo_shortname: commit</div></pre></td></tr></table></figure></p><p>commit为你注册多说域名的子域名，就如你多说的域名为：<code>http://commit.duoshuo.com</code></p><h4 id="使你的菜单栏显示中文"><a href="#使你的菜单栏显示中文" class="headerlink" title="使你的菜单栏显示中文"></a>使你的菜单栏显示中文</h4><p>在根目录下的配置文件_config.yml找到language字段，修改为<code>zh-Hans</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"># Site</div><div class="line">language: zh-Hans</div></pre></td></tr></table></figure></p><h4 id="配置社交链接"><a href="#配置社交链接" class="headerlink" title="配置社交链接"></a>配置社交链接</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"># Social links</div><div class="line">social:</div><div class="line">  GitHub: git地址</div><div class="line"># Social Icons</div><div class="line">social_icons:</div><div class="line">  enable: true</div><div class="line">  # Icon Mappings</div><div class="line">  GitHub: github</div></pre></td></tr></table></figure><p>如果想添加其他社交链接，可以查看官方文档</p><h4 id="配置hexo插件"><a href="#配置hexo插件" class="headerlink" title="配置hexo插件"></a>配置hexo插件</h4><h5 id="添加网站地图"><a href="#添加网站地图" class="headerlink" title="添加网站地图"></a>添加网站地图</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">npm install hexo-generator-sitemap --save</div><div class="line">npm install hexo-generator-baidu-sitemap --save</div></pre></td></tr></table></figure><p>在站点配置文件_config.yml中添加如下代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"># hexo sitemap</div><div class="line">sitemap:</div><div class="line">path: sitemap.xml</div><div class="line">baidusitemap:</div><div class="line">path: baidusitemap.xml</div></pre></td></tr></table></figure></p><p>配置成功后，会生成在public目录下生成sitemap.xml 和 baidusitemap.xml，前者适合提交给谷歌搜素引擎，后者适合提交百度搜索引擎。</p><p>其次，在 robots.txt 中添加下面的一段代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Sitemap: http://blog.tangxiaozhu.com/sitemap.xml</div><div class="line">Sitemap: http://blog.tangxiaozhu.com/baidusitemap.xml</div></pre></td></tr></table></figure></p><p>将<code>robots.txt</code> 放置在<code>\source</code> 目录下。</p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://hexo.io/zh-cn/docs/" target="_blank" rel="external">hexo官方文档</a><br><a href="http://theme-next.iissnan.com/theme-settings.html" target="_blank" rel="external">next主题文档</a><br><a href="http://blog.tangxiaozhu.com/p/45374067/" target="_blank" rel="external">使用 Hexo 搭建博客的深度优化与定制</a><br><a href="http://zhiho.github.io/2015/09/29/hexo-next/" target="_blank" rel="external">Hexo搭建GitHub博客（三）- NexT主题配置使用</a><br><a href="http://www.jianshu.com/p/465830080ea9" target="_blank" rel="external">HEXO+Github,搭建属于自己的博客</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前段时间在朋友的帮助下，也找过很多资料来搭建自己的hexo博客，之前也就是在简述上写自己的博客文章，说真的，自己如果懂得如何搭建博客来写，更有些自豪感。废话就不多说了，下面就来了解一下hexo以及如何搭建一个属于自己的hexo博客。&lt;br&gt;
    
    </summary>
    
      <category term="blog" scheme="http://yoursite.com/categories/blog/"/>
    
    
      <category term="hexo" scheme="http://yoursite.com/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>ByteBuf和相关辅助类</title>
    <link href="http://yoursite.com/2016/03/07/ByteBuf%E5%92%8C%E7%9B%B8%E5%85%B3%E8%BE%85%E5%8A%A9%E7%B1%BB/"/>
    <id>http://yoursite.com/2016/03/07/ByteBuf和相关辅助类/</id>
    <published>2016-03-07T15:02:25.000Z</published>
    <updated>2017-09-26T07:20:08.322Z</updated>
    
    <content type="html"><![CDATA[<p>当我们进行数据传输的时候，往往需要使用到缓冲区，常用的缓冲区就是JDK NIO类库提供的java.nio.Buffer。但是ByteBuffer的API功能有限，一些高级和实用的特性它不支持，需要使用者自己编程实现。<br>为了弥补这些不足，Netty提供了自己的ByteBuffer实现——ByteBuf。<br><a id="more"></a></p><h3 id="ByteBuf功能说明"><a href="#ByteBuf功能说明" class="headerlink" title="ByteBuf功能说明"></a>ByteBuf功能说明</h3><p>实际上，7种基础类型（Boolean除外）都有自己的缓冲区实现，对于NIO编程而言，我们主要使用的是ByteBuffer。ByteBuffer的实现类如图1所示。</p><div align="center"><br><img src="/images/netty/15-1.jpg" alt=""><br>图1 ByteBuffer的实现类</div><p>从功能角度而言，ByteBuffer完全可以满足NIO编程的需要，但是由于NIO编程的复杂性，ByteBuffer也有其局限性，它的主要缺点如下。</p><ul><li>ByteBuffer长度固定，一旦分配完成，它的容量不能动态扩展和收缩，当需要编码的POJO对象大于ByteBuffer的容量时，会发生索引越界异常；</li><li>ByteBuffer只有一个标识位置的指针position，读写的时候需要手工调用flip()和rewind()等，使用者必须小心谨慎地处理这些API，否则很容易导致程序处理失败；</li><li>ByteBuffer的API功能有限，一些高级和实用的特性它不支持，需要使用者自己编程实现。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;当我们进行数据传输的时候，往往需要使用到缓冲区，常用的缓冲区就是JDK NIO类库提供的java.nio.Buffer。但是ByteBuffer的API功能有限，一些高级和实用的特性它不支持，需要使用者自己编程实现。&lt;br&gt;为了弥补这些不足，Netty提供了自己的ByteBuffer实现——ByteBuf。&lt;br&gt;
    
    </summary>
    
      <category term="Netty" scheme="http://yoursite.com/categories/Netty/"/>
    
    
      <category term="network" scheme="http://yoursite.com/tags/network/"/>
    
  </entry>
  
</feed>
